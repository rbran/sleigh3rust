use sleigh4rust::*;
pub type AddrType = u32;
pub trait GlobalSetTrait {
    fn set_TMode(&mut self, address: Option<u32>, value: i128);
    fn set_T(&mut self, address: Option<u32>, value: i128);
    fn set_LowBitCodeMode(&mut self, address: Option<u32>, value: i128);
    fn set_ISA_MODE(&mut self, address: Option<u32>, value: i128);
    fn set_LRset(&mut self, address: Option<u32>, value: i128);
    fn set_REToverride(&mut self, address: Option<u32>, value: i128);
    fn set_CALLoverride(&mut self, address: Option<u32>, value: i128);
    fn set_counter(&mut self, address: Option<u32>, value: i128);
    fn set_regNum(&mut self, address: Option<u32>, value: i128);
    fn set_counter2(&mut self, address: Option<u32>, value: i128);
    fn set_reg2Num(&mut self, address: Option<u32>, value: i128);
    fn set_regInc(&mut self, address: Option<u32>, value: i128);
    fn set_ARMcond(&mut self, address: Option<u32>, value: i128);
    fn set_ARMcondCk(&mut self, address: Option<u32>, value: i128);
}
#[derive(Default)]
pub struct GlobalSetDefault<C: ContextTrait>(
    pub std::collections::HashMap<AddrType, C>,
);
impl<C: ContextTrait> GlobalSetTrait for GlobalSetDefault<C> {
    fn set_TMode(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_TMode_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_T(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context.register_mut().write_T_disassembly(value).unwrap();
            context
        });
    }
    fn set_LowBitCodeMode(
        &mut self,
        inst_start: Option<AddrType>,
        value: i128,
    ) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_LowBitCodeMode_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_ISA_MODE(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_ISA_MODE_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_LRset(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_LRset_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_REToverride(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_REToverride_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_CALLoverride(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_CALLoverride_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_counter(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_counter_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_regNum(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_regNum_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_counter2(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_counter2_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_reg2Num(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_reg2Num_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_regInc(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_regInc_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_ARMcond(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_ARMcond_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_ARMcondCk(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_ARMcondCk_disassembly(value)
                .unwrap();
            context
        });
    }
}
pub trait ContextregisterTrait:
    MemoryRead<AddressType = u32> + MemoryWrite
{
    fn read_TMode_raw(&self) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(0, 0, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_TMode_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 0, 0, 1)
    }
    fn read_TMode_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_TMode_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_TMode_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_TMode_raw(param as u8)
    }
    fn read_TMode_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_TMode_raw()
    }
    fn write_TMode_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_TMode_raw(param)
    }
    fn TMode_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_TMode_raw()?))
    }
    fn read_T_raw(&self) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(0, 0, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_T_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 0, 0, 1)
    }
    fn read_T_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_T_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_T_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_T_raw(param as u8)
    }
    fn read_T_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_T_raw()
    }
    fn write_T_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_T_raw(param)
    }
    fn T_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_T_raw()?))
    }
    fn read_LowBitCodeMode_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(0, 0, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_LowBitCodeMode_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 0, 0, 1)
    }
    fn read_LowBitCodeMode_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_LowBitCodeMode_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_LowBitCodeMode_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_LowBitCodeMode_raw(param as u8)
    }
    fn read_LowBitCodeMode_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_LowBitCodeMode_raw()
    }
    fn write_LowBitCodeMode_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_LowBitCodeMode_raw(param)
    }
    fn LowBitCodeMode_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_LowBitCodeMode_raw()?))
    }
    fn read_ISA_MODE_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(0, 0, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_ISA_MODE_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 0, 0, 1)
    }
    fn read_ISA_MODE_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_ISA_MODE_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_ISA_MODE_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_ISA_MODE_raw(param as u8)
    }
    fn read_ISA_MODE_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_ISA_MODE_raw()
    }
    fn write_ISA_MODE_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_ISA_MODE_raw(param)
    }
    fn ISA_MODE_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_ISA_MODE_raw()?))
    }
    fn read_LRset_raw(&self) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(0, 1, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_LRset_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 0, 1, 1)
    }
    fn read_LRset_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_LRset_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_LRset_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_LRset_raw(param as u8)
    }
    fn read_LRset_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_LRset_raw()
    }
    fn write_LRset_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_LRset_raw(param)
    }
    fn LRset_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_LRset_raw()?))
    }
    fn read_REToverride_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(0, 2, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_REToverride_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 0, 2, 1)
    }
    fn read_REToverride_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_REToverride_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_REToverride_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_REToverride_raw(param as u8)
    }
    fn read_REToverride_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_REToverride_raw()
    }
    fn write_REToverride_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_REToverride_raw(param)
    }
    fn REToverride_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_REToverride_raw()?))
    }
    fn read_CALLoverride_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(0, 3, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_CALLoverride_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 0, 3, 1)
    }
    fn read_CALLoverride_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_CALLoverride_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_CALLoverride_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_CALLoverride_raw(param as u8)
    }
    fn read_CALLoverride_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_CALLoverride_raw()
    }
    fn write_CALLoverride_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_CALLoverride_raw(param)
    }
    fn CALLoverride_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_CALLoverride_raw()?))
    }
    fn read_counter_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u16::<false>(1, 6, 5)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_counter_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u16::<false>(u16::from(param), 1, 6, 5)
    }
    fn read_counter_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_counter_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_counter_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_counter_raw(param as u8)
    }
    fn read_counter_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_counter_raw()
    }
    fn write_counter_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_counter_raw(param)
    }
    fn counter_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_counter_raw()?))
    }
    fn read_regNum_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(2, 3, 5)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_regNum_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 2, 3, 5)
    }
    fn read_regNum_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_regNum_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_regNum_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_regNum_raw(param as u8)
    }
    fn read_regNum_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_regNum_raw()
    }
    fn write_regNum_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_regNum_raw(param)
    }
    fn regNum_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_regNum_raw()?))
    }
    fn read_counter2_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(3, 0, 3)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_counter2_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 3, 0, 3)
    }
    fn read_counter2_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_counter2_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_counter2_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_counter2_raw(param as u8)
    }
    fn read_counter2_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_counter2_raw()
    }
    fn write_counter2_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_counter2_raw(param)
    }
    fn counter2_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_counter2_raw()?))
    }
    fn read_reg2Num_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(3, 3, 5)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_reg2Num_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 3, 3, 5)
    }
    fn read_reg2Num_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_reg2Num_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_reg2Num_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_reg2Num_raw(param as u8)
    }
    fn read_reg2Num_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_reg2Num_raw()
    }
    fn write_reg2Num_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_reg2Num_raw(param)
    }
    fn reg2Num_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_reg2Num_raw()?))
    }
    fn read_regInc_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(4, 0, 2)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_regInc_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 4, 0, 2)
    }
    fn read_regInc_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_regInc_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_regInc_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_regInc_raw(param as u8)
    }
    fn read_regInc_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_regInc_raw()
    }
    fn write_regInc_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_regInc_raw(param)
    }
    fn regInc_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_regInc_raw()?))
    }
    fn read_ARMcond_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(4, 2, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_ARMcond_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 4, 2, 1)
    }
    fn read_ARMcond_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_ARMcond_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_ARMcond_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_ARMcond_raw(param as u8)
    }
    fn read_ARMcond_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_ARMcond_raw()
    }
    fn write_ARMcond_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_ARMcond_raw(param)
    }
    fn ARMcond_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_ARMcond_raw()?))
    }
    fn read_ARMcondCk_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(4, 3, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_ARMcondCk_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 4, 3, 1)
    }
    fn read_ARMcondCk_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_ARMcondCk_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_ARMcondCk_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_ARMcondCk_raw(param as u8)
    }
    fn read_ARMcondCk_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_ARMcondCk_raw()
    }
    fn write_ARMcondCk_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_ARMcondCk_raw(param)
    }
    fn ARMcondCk_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_ARMcondCk_raw()?))
    }
}
pub trait ContextTrait: Default {
    type Typeregister: ContextregisterTrait;
    fn register(&self) -> &Self::Typeregister;
    fn register_mut(&mut self) -> &mut Self::Typeregister;
}
#[derive(Debug, Clone, Copy)]
pub struct ContextregisterStructDebug {
    pub chunk_0x0: [Option<bool>; 64],
}
impl Default for ContextregisterStructDebug {
    fn default() -> Self {
        Self {
            chunk_0x0: [None; 64],
        }
    }
}
impl ContextregisterStructDebug {
    fn read_bits(
        &self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &mut [u8],
        mask: &[u8],
    ) -> Result<(), MemoryReadError<<Self as MemoryRead>::AddressType>> {
        assert_eq!(buf.len(), mask.len());
        let buf_len =
            <<Self as MemoryRead>::AddressType>::try_from(buf.len()).unwrap();
        let addr_end = addr + ((buf_len + 7) / 8);
        match (addr, addr_end) {
            (0..=7, 0..=8) => {
                let byte_offset = usize::try_from(addr - 0).unwrap();
                for ((buf_byte, mask_byte), byte) in
                    buf.iter_mut().zip(mask.iter()).zip(byte_offset..)
                {
                    for bit in (0..8)
                        .into_iter()
                        .filter(|bit| ((*mask_byte >> bit) & 1) != 0)
                    {
                        *buf_byte |= (self.chunk_0x0[(byte * 8) + bit].unwrap()
                            as u8)
                            << bit;
                    }
                }
            }
            (addr_start, addr_end) => {
                return Err(MemoryReadError::UnableToReadMemory(
                    addr_start, addr_end,
                ))
            }
        }
        Ok(())
    }
    fn write_bits(
        &mut self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &[u8],
        mask: &[u8],
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        assert_eq!(buf.len(), mask.len());
        let buf_len =
            <<Self as MemoryRead>::AddressType>::try_from(buf.len()).unwrap();
        let addr_end = addr + ((buf_len + 7) / 8);
        match (addr, addr_end) {
            (0..=7, 0..=8) => {
                let byte_offset = usize::try_from(addr - 0).unwrap();
                for ((buf_byte, mask_byte), byte) in
                    buf.iter().zip(mask.iter()).zip(byte_offset..)
                {
                    for bit in (0..8)
                        .into_iter()
                        .filter(|bit| ((*mask_byte >> bit) & 1) != 0)
                    {
                        self.chunk_0x0[(byte * 8) + bit] =
                            Some(*buf_byte & (1 << bit) != 0);
                    }
                }
            }
            (addr_start, addr_end) => {
                return Err(MemoryWriteError::UnableToWriteMemory(
                    addr_start, addr_end,
                ))
            }
        }
        Ok(())
    }
}
impl ContextregisterTrait for ContextregisterStructDebug {}
impl MemoryRead for ContextregisterStructDebug {
    type AddressType = u32;
    fn read(
        &self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &mut [u8],
    ) -> Result<(), MemoryReadError<<Self as MemoryRead>::AddressType>> {
        let mut inner_buf = vec![0xFF; buf.len()];
        self.read_bits(addr, buf, &mut inner_buf)
    }
    fn read_u8<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u8, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u8>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u8>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u8>::from_be_bytes(data)
        } else {
            <u8>::from_le_bytes(data)
        };
        let value_mask = <u8>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u16<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u16, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u16>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u16>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u16>::from_be_bytes(data)
        } else {
            <u16>::from_le_bytes(data)
        };
        let value_mask = <u16>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u32<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u32, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u32>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u32>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u32>::from_be_bytes(data)
        } else {
            <u32>::from_le_bytes(data)
        };
        let value_mask = <u32>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u64<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u64, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u64>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u64>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u64>::from_be_bytes(data)
        } else {
            <u64>::from_le_bytes(data)
        };
        let value_mask = <u64>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u128<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u128, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u128>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u128>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u128>::from_be_bytes(data)
        } else {
            <u128>::from_le_bytes(data)
        };
        let value_mask = <u128>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
}
impl MemoryWrite for ContextregisterStructDebug {
    fn write(
        &mut self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &[u8],
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        let mut inner_buf = vec![0xFF; buf.len()];
        self.write_bits(addr, buf, &inner_buf)
    }
    fn write_u8<const BIG_ENDIAN: bool>(
        &mut self,
        value: u8,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u8>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u8>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u16<const BIG_ENDIAN: bool>(
        &mut self,
        value: u16,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u16>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u16>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u32<const BIG_ENDIAN: bool>(
        &mut self,
        value: u32,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u32>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u32>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u64<const BIG_ENDIAN: bool>(
        &mut self,
        value: u64,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u64>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u64>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u128<const BIG_ENDIAN: bool>(
        &mut self,
        value: u128,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u128>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u128>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
}
#[derive(Debug, Clone, Copy, Default)]
pub struct SpacesStruct {
    pub register: ContextregisterStructDebug,
}
impl ContextTrait for SpacesStruct {
    type Typeregister = ContextregisterStructDebug;
    fn register(&self) -> &Self::Typeregister {
        &self.register
    }
    fn register_mut(&mut self) -> &mut Self::Typeregister {
        &mut self.register
    }
}
fn meaning_number<T>(hex: bool, num: T) -> DisplayElement
where
    i128: TryFrom<T>,
    <i128 as TryFrom<T>>::Error: core::fmt::Debug,
{
    DisplayElement::Number(hex, i128::try_from(num).unwrap())
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::sp,
        14 => Register::lr,
        15 => Register::pc,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r1,
        2 => Register::r3,
        4 => Register::r5,
        6 => Register::r7,
        8 => Register::r9,
        10 => Register::r11,
        12 => Register::sp,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cr0,
        1 => Register::cr1,
        2 => Register::cr2,
        3 => Register::cr3,
        4 => Register::cr4,
        5 => Register::cr5,
        6 => Register::cr6,
        7 => Register::cr7,
        8 => Register::cr8,
        9 => Register::cr9,
        10 => Register::cr10,
        11 => Register::cr11,
        12 => Register::cr12,
        13 => Register::cr13,
        14 => Register::cr14,
        15 => Register::cr15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_6_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_6_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::sp,
        14 => Register::lr,
        15 => Register::pc,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_7_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_7_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::sp,
        14 => Register::lr,
        15 => Register::pc,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_8_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_8_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_8_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_9_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_9_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_9_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cr0,
        1 => Register::cr1,
        2 => Register::cr2,
        3 => Register::cr3,
        4 => Register::cr4,
        5 => Register::cr5,
        6 => Register::cr6,
        7 => Register::cr7,
        8 => Register::cr8,
        9 => Register::cr9,
        10 => Register::cr10,
        11 => Register::cr11,
        12 => Register::cr12,
        13 => Register::cr13,
        14 => Register::cr14,
        15 => Register::cr15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_10_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_10_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_10_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r8,
        1 => Register::r9,
        2 => Register::r10,
        3 => Register::r11,
        4 => Register::r12,
        5 => Register::sp,
        6 => Register::lr,
        7 => Register::pc,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("p0"),
        1 => DisplayElement::Literal("p1"),
        2 => DisplayElement::Literal("p2"),
        3 => DisplayElement::Literal("p3"),
        4 => DisplayElement::Literal("p4"),
        5 => DisplayElement::Literal("p5"),
        6 => DisplayElement::Literal("p6"),
        7 => DisplayElement::Literal("p7"),
        8 => DisplayElement::Literal("p8"),
        9 => DisplayElement::Literal("p9"),
        10 => DisplayElement::Literal("p10"),
        11 => DisplayElement::Literal("p11"),
        12 => DisplayElement::Literal("p12"),
        13 => DisplayElement::Literal("p13"),
        14 => DisplayElement::Literal("p14"),
        15 => DisplayElement::Literal("p15"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("opt0"),
        1 => DisplayElement::Literal("opt1"),
        2 => DisplayElement::Literal("OSHST"),
        3 => DisplayElement::Literal("OSH"),
        4 => DisplayElement::Literal("opt4"),
        5 => DisplayElement::Literal("opt5"),
        6 => DisplayElement::Literal("NSHST"),
        7 => DisplayElement::Literal("NSH"),
        8 => DisplayElement::Literal("opt8"),
        9 => DisplayElement::Literal("opt9"),
        10 => DisplayElement::Literal("ISHST"),
        11 => DisplayElement::Literal("ISH"),
        12 => DisplayElement::Literal("opt12"),
        13 => DisplayElement::Literal("opt13"),
        14 => DisplayElement::Literal("ST"),
        15 => DisplayElement::Literal("SY"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("opt0"),
        1 => DisplayElement::Literal("opt1"),
        2 => DisplayElement::Literal("opt2"),
        3 => DisplayElement::Literal("opt3"),
        4 => DisplayElement::Literal("opt4"),
        5 => DisplayElement::Literal("opt5"),
        6 => DisplayElement::Literal("opt6"),
        7 => DisplayElement::Literal("opt7"),
        8 => DisplayElement::Literal("opt8"),
        9 => DisplayElement::Literal("opt9"),
        10 => DisplayElement::Literal("opt10"),
        11 => DisplayElement::Literal("opt11"),
        12 => DisplayElement::Literal("opt12"),
        13 => DisplayElement::Literal("opt13"),
        14 => DisplayElement::Literal("opt14"),
        15 => DisplayElement::Literal("SY"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_11_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("p0"),
        1 => DisplayElement::Literal("p1"),
        2 => DisplayElement::Literal("p2"),
        3 => DisplayElement::Literal("p3"),
        4 => DisplayElement::Literal("p4"),
        5 => DisplayElement::Literal("p5"),
        6 => DisplayElement::Literal("p6"),
        7 => DisplayElement::Literal("p7"),
        8 => DisplayElement::Literal("p8"),
        9 => DisplayElement::Literal("p9"),
        10 => DisplayElement::Literal("p10"),
        11 => DisplayElement::Literal("p11"),
        12 => DisplayElement::Literal("p12"),
        13 => DisplayElement::Literal("p13"),
        14 => DisplayElement::Literal("p14"),
        15 => DisplayElement::Literal("p15"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_pref(u32);
impl TokenField_pref {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_cond(u8);
impl TokenField_cond {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_I25(u8);
impl TokenField_I25 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_P24(u8);
impl TokenField_P24 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_H24(u8);
impl TokenField_H24 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_L24(u8);
impl TokenField_L24 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_U23(u8);
impl TokenField_U23 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_B22(u8);
impl TokenField_B22 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_N22(u8);
impl TokenField_N22 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_S22(u8);
impl TokenField_S22 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op(u8);
impl TokenField_op {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_W21(u8);
impl TokenField_W21 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_S20(u8);
impl TokenField_S20 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_L20(u8);
impl TokenField_L20 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rn(u8);
impl TokenField_Rn {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RnLo(u8);
impl TokenField_RnLo {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_msb(u8);
impl TokenField_msb {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_satimm5(u8);
impl TokenField_satimm5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_satimm4(u8);
impl TokenField_satimm4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_mask(u8);
impl TokenField_mask {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rd(u8);
impl TokenField_Rd {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rd2(u8);
impl TokenField_Rd2 {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRd(u8);
impl TokenField_CRd {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRn(u8);
impl TokenField_CRn {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRm(u8);
impl TokenField_CRm {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RdHi(u8);
impl TokenField_RdHi {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RdLo(u8);
impl TokenField_RdLo {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_smRd(u8);
impl TokenField_smRd {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_smRa(u8);
impl TokenField_smRa {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_smRm(u8);
impl TokenField_smRm {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_smRn(u8);
impl TokenField_smRn {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed12(u16);
impl TokenField_immed12 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rs(u8);
impl TokenField_Rs {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rotate(u8);
impl TokenField_rotate {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immedH(u8);
impl TokenField_immedH {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_cpn(u8);
impl TokenField_cpn {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_opc1(u8);
impl TokenField_opc1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_opcode1(u8);
impl TokenField_opcode1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_opc2(u8);
impl TokenField_opc2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_opcode2(u8);
impl TokenField_opcode2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_opcode3(u8);
impl TokenField_opcode3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_lsb(u8);
impl TokenField_lsb {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sftimm(u8);
impl TokenField_sftimm {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sh(u8);
impl TokenField_sh {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_shft(u8);
impl TokenField_shft {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed24(u32);
impl TokenField_immed24 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_addr24(i32);
impl TokenField_addr24 {
    fn execution(&self) -> i32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_offset_12(u16);
impl TokenField_offset_12 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed(u8);
impl TokenField_immed {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_srsMode(u8);
impl TokenField_srsMode {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immedL(u8);
impl TokenField_immedL {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed4(u8);
impl TokenField_immed4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_dbOption(u8);
impl TokenField_dbOption {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ibOption(u8);
impl TokenField_ibOption {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rm(u8);
impl TokenField_Rm {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RmHi(u8);
impl TokenField_RmHi {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rm2(u8);
impl TokenField_Rm2 {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_x(u8);
impl TokenField_x {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_r(u8);
impl TokenField_r {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_y(u8);
impl TokenField_y {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_D22(u8);
impl TokenField_D22 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_N7(u8);
impl TokenField_N7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_L7(u8);
impl TokenField_L7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Q6(u8);
impl TokenField_Q6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_M5(u8);
impl TokenField_M5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Qn0(u8);
impl TokenField_Qn0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Qd0(u8);
impl TokenField_Qd0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Qm0(u8);
impl TokenField_Qm0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Qn1(u8);
impl TokenField_Qn1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Qd1(u8);
impl TokenField_Qd1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Qm1(u8);
impl TokenField_Qm1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dn0(u8);
impl TokenField_Dn0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd0(u8);
impl TokenField_Dd0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_1(u8);
impl TokenField_Dd_1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_2(u8);
impl TokenField_Dd_2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_3(u8);
impl TokenField_Dd_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_4(u8);
impl TokenField_Dd_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_5(u8);
impl TokenField_Dd_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_6(u8);
impl TokenField_Dd_6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_7(u8);
impl TokenField_Dd_7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_8(u8);
impl TokenField_Dd_8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_9(u8);
impl TokenField_Dd_9 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_10(u8);
impl TokenField_Dd_10 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_11(u8);
impl TokenField_Dd_11 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_12(u8);
impl TokenField_Dd_12 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_13(u8);
impl TokenField_Dd_13 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_14(u8);
impl TokenField_Dd_14 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_15(u8);
impl TokenField_Dd_15 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_16(u8);
impl TokenField_Dd_16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dm0(u8);
impl TokenField_Dm0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dn1(u8);
impl TokenField_Dn1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd1(u8);
impl TokenField_Dd1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dm1(u8);
impl TokenField_Dm1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dm_3(u8);
impl TokenField_Dm_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dm_4(u8);
impl TokenField_Dm_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sn0(u8);
impl TokenField_Sn0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sd0(u8);
impl TokenField_Sd0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sm0(u8);
impl TokenField_Sm0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sm0next(u8);
impl TokenField_Sm0next {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sn1(u8);
impl TokenField_Sn1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sd1(u8);
impl TokenField_Sd1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sm1(u8);
impl TokenField_Sm1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sm1next(u8);
impl TokenField_Sm1next {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sm0_3(u8);
impl TokenField_Sm0_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sm1_3(u8);
impl TokenField_Sm1_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_cmode(u8);
impl TokenField_cmode {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit31(u8);
impl TokenField_bit31 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit30(u8);
impl TokenField_bit30 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit29(u8);
impl TokenField_bit29 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit28(u8);
impl TokenField_bit28 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2831(u8);
impl TokenField_c2831 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2627(u8);
impl TokenField_c2627 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2531(u8);
impl TokenField_c2531 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2527(u8);
impl TokenField_c2527 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2525(u8);
impl TokenField_c2525 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2427(u8);
impl TokenField_c2427 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2424(u8);
impl TokenField_c2424 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2331(u16);
impl TokenField_c2331 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2327(u8);
impl TokenField_c2327 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2324(u8);
impl TokenField_c2324 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2323(u8);
impl TokenField_c2323 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2222(u8);
impl TokenField_c2222 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2131(u16);
impl TokenField_c2131 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2127(u8);
impl TokenField_c2127 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2124(u8);
impl TokenField_c2124 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2123(u8);
impl TokenField_c2123 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2122(u8);
impl TokenField_c2122 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2121(u8);
impl TokenField_c2121 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2027(u8);
impl TokenField_c2027 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2024(u8);
impl TokenField_c2024 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2022(u8);
impl TokenField_c2022 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2021(u8);
impl TokenField_c2021 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2020(u8);
impl TokenField_c2020 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1921(u8);
impl TokenField_c1921 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1919(u8);
impl TokenField_c1919 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1821(u8);
impl TokenField_c1821 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1819(u8);
impl TokenField_c1819 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1818(u8);
impl TokenField_c1818 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1721(u8);
impl TokenField_c1721 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1719(u8);
impl TokenField_c1719 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1718(u8);
impl TokenField_c1718 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1717(u8);
impl TokenField_c1717 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1631(u16);
impl TokenField_c1631 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1627(u16);
impl TokenField_c1627 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1621(u8);
impl TokenField_c1621 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1620(u8);
impl TokenField_c1620 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1619(u8);
impl TokenField_c1619 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1618(u8);
impl TokenField_c1618 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1617(u8);
impl TokenField_c1617 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1616(u8);
impl TokenField_c1616 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1515(u8);
impl TokenField_c1515 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1415(u8);
impl TokenField_c1415 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1414(u8);
impl TokenField_c1414 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1315(u8);
impl TokenField_c1315 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1313(u8);
impl TokenField_c1313 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1215(u8);
impl TokenField_c1215 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1212(u8);
impl TokenField_c1212 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1115(u8);
impl TokenField_c1115 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1111(u8);
impl TokenField_c1111 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1015(u8);
impl TokenField_c1015 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1011(u8);
impl TokenField_c1011 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1010(u8);
impl TokenField_c1010 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0916(u8);
impl TokenField_c0916 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0915(u8);
impl TokenField_c0915 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0911(u8);
impl TokenField_c0911 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0909(u8);
impl TokenField_c0909 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0815(u8);
impl TokenField_c0815 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0811(u8);
impl TokenField_c0811 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0809(u8);
impl TokenField_c0809 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0808(u8);
impl TokenField_c0808 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0715(u16);
impl TokenField_c0715 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0711(u8);
impl TokenField_c0711 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0709(u8);
impl TokenField_c0709 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0708(u8);
impl TokenField_c0708 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0707(u8);
impl TokenField_c0707 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0615(u16);
impl TokenField_c0615 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0611(u8);
impl TokenField_c0611 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0607(u8);
impl TokenField_c0607 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0606(u8);
impl TokenField_c0606 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0515(u16);
impl TokenField_c0515 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0508(u8);
impl TokenField_c0508 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0507(u8);
impl TokenField_c0507 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0506(u8);
impl TokenField_c0506 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0505(u8);
impl TokenField_c0505 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0431(u32);
impl TokenField_c0431 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0427(u32);
impl TokenField_c0427 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0415(u16);
impl TokenField_c0415 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0411(u8);
impl TokenField_c0411 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0409(u8);
impl TokenField_c0409 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0408(u8);
impl TokenField_c0408 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0407(u8);
impl TokenField_c0407 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0406(u8);
impl TokenField_c0406 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0405(u8);
impl TokenField_c0405 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0404(u8);
impl TokenField_c0404 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0315(u16);
impl TokenField_c0315 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0303(u8);
impl TokenField_c0303 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0215(u16);
impl TokenField_c0215 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0202(u8);
impl TokenField_c0202 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0115(u16);
impl TokenField_c0115 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0101(u8);
impl TokenField_c0101 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0031(u32);
impl TokenField_c0031 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0027(u32);
impl TokenField_c0027 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0014(u16);
impl TokenField_c0014 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0013(u16);
impl TokenField_c0013 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0012(u16);
impl TokenField_c0012 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0011(u16);
impl TokenField_c0011 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0010(u16);
impl TokenField_c0010 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0009(u16);
impl TokenField_c0009 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0008(u16);
impl TokenField_c0008 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0007(u8);
impl TokenField_c0007 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0006(u8);
impl TokenField_c0006 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0005(u8);
impl TokenField_c0005 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0004(u8);
impl TokenField_c0004 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0003(u8);
impl TokenField_c0003 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0002(u8);
impl TokenField_c0002 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0001(u8);
impl TokenField_c0001 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0000(u8);
impl TokenField_c0000 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_D22(u8);
impl TokenField_thv_D22 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_N7(u8);
impl TokenField_thv_N7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_L7(u8);
impl TokenField_thv_L7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Q6(u8);
impl TokenField_thv_Q6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_M5(u8);
impl TokenField_thv_M5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Qn0(u8);
impl TokenField_thv_Qn0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Qd0(u8);
impl TokenField_thv_Qd0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Qm0(u8);
impl TokenField_thv_Qm0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Qn1(u8);
impl TokenField_thv_Qn1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Qd1(u8);
impl TokenField_thv_Qd1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Qm1(u8);
impl TokenField_thv_Qm1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dn0(u8);
impl TokenField_thv_Dn0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd0(u8);
impl TokenField_thv_Dd0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_1(u8);
impl TokenField_thv_Dd_1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_2(u8);
impl TokenField_thv_Dd_2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_3(u8);
impl TokenField_thv_Dd_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_4(u8);
impl TokenField_thv_Dd_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_5(u8);
impl TokenField_thv_Dd_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_6(u8);
impl TokenField_thv_Dd_6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_7(u8);
impl TokenField_thv_Dd_7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_8(u8);
impl TokenField_thv_Dd_8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_9(u8);
impl TokenField_thv_Dd_9 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_10(u8);
impl TokenField_thv_Dd_10 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_11(u8);
impl TokenField_thv_Dd_11 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_12(u8);
impl TokenField_thv_Dd_12 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_13(u8);
impl TokenField_thv_Dd_13 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_14(u8);
impl TokenField_thv_Dd_14 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_15(u8);
impl TokenField_thv_Dd_15 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_16(u8);
impl TokenField_thv_Dd_16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dm0(u8);
impl TokenField_thv_Dm0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dn1(u8);
impl TokenField_thv_Dn1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd1(u8);
impl TokenField_thv_Dd1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dm1(u8);
impl TokenField_thv_Dm1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dm_3(u8);
impl TokenField_thv_Dm_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dm_4(u8);
impl TokenField_thv_Dm_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sn0(u8);
impl TokenField_thv_Sn0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sd0(u8);
impl TokenField_thv_Sd0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sm0(u8);
impl TokenField_thv_Sm0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sm0next(u8);
impl TokenField_thv_Sm0next {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sn1(u8);
impl TokenField_thv_Sn1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sd1(u8);
impl TokenField_thv_Sd1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sm1(u8);
impl TokenField_thv_Sm1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sm1next(u8);
impl TokenField_thv_Sm1next {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_cmode(u8);
impl TokenField_thv_cmode {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sm0_3(u8);
impl TokenField_thv_Sm0_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sm1_3(u8);
impl TokenField_thv_Sm1_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Rd(u8);
impl TokenField_thv_Rd {
    fn execution(&self) -> Register {
        meaning_6_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_6_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Rt(u8);
impl TokenField_thv_Rt {
    fn execution(&self) -> Register {
        meaning_6_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_6_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Rn(u8);
impl TokenField_thv_Rn {
    fn execution(&self) -> Register {
        meaning_6_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_6_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Rm(u8);
impl TokenField_thv_Rm {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Rt2(u8);
impl TokenField_thv_Rt2 {
    fn execution(&self) -> Register {
        meaning_6_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_6_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_immed(u8);
impl TokenField_thv_immed {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit31(u8);
impl TokenField_thv_bit31 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit30(u8);
impl TokenField_thv_bit30 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit29(u8);
impl TokenField_thv_bit29 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit28(u8);
impl TokenField_thv_bit28 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit23(u8);
impl TokenField_thv_bit23 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit21(u8);
impl TokenField_thv_bit21 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit20(u8);
impl TokenField_thv_bit20 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit07(u8);
impl TokenField_thv_bit07 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit06(u8);
impl TokenField_thv_bit06 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit00(u8);
impl TokenField_thv_bit00 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2931(u8);
impl TokenField_thv_c2931 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2831(u8);
impl TokenField_thv_c2831 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2828(u8);
impl TokenField_thv_c2828 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2627(u8);
impl TokenField_thv_c2627 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2531(u8);
impl TokenField_thv_c2531 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2527(u8);
impl TokenField_thv_c2527 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2525(u8);
impl TokenField_thv_c2525 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2427(u8);
impl TokenField_thv_c2427 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2424(u8);
impl TokenField_thv_c2424 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2331(u16);
impl TokenField_thv_c2331 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2327(u8);
impl TokenField_thv_c2327 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2324(u8);
impl TokenField_thv_c2324 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2323(u8);
impl TokenField_thv_c2323 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2222(u8);
impl TokenField_thv_c2222 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2131(u16);
impl TokenField_thv_c2131 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2127(u8);
impl TokenField_thv_c2127 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2124(u8);
impl TokenField_thv_c2124 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2123(u8);
impl TokenField_thv_c2123 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2122(u8);
impl TokenField_thv_c2122 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2121(u8);
impl TokenField_thv_c2121 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2031(u16);
impl TokenField_thv_c2031 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2027(u8);
impl TokenField_thv_c2027 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2024(u8);
impl TokenField_thv_c2024 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2022(u8);
impl TokenField_thv_c2022 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2021(u8);
impl TokenField_thv_c2021 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2020(u8);
impl TokenField_thv_c2020 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1921(u8);
impl TokenField_thv_c1921 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1919(u8);
impl TokenField_thv_c1919 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1821(u8);
impl TokenField_thv_c1821 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1819(u8);
impl TokenField_thv_c1819 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1818(u8);
impl TokenField_thv_c1818 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1721(u8);
impl TokenField_thv_c1721 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1719(u8);
impl TokenField_thv_c1719 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1718(u8);
impl TokenField_thv_c1718 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1717(u8);
impl TokenField_thv_c1717 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1631(u16);
impl TokenField_thv_c1631 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1627(u16);
impl TokenField_thv_c1627 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1621(u8);
impl TokenField_thv_c1621 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1620(u8);
impl TokenField_thv_c1620 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1619(u8);
impl TokenField_thv_c1619 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1618(u8);
impl TokenField_thv_c1618 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1617(u8);
impl TokenField_thv_c1617 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1616(u8);
impl TokenField_thv_c1616 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1515(u8);
impl TokenField_thv_c1515 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1415(u8);
impl TokenField_thv_c1415 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1414(u8);
impl TokenField_thv_c1414 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1313(u8);
impl TokenField_thv_c1313 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1215(u8);
impl TokenField_thv_c1215 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1212(u8);
impl TokenField_thv_c1212 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1111(u8);
impl TokenField_thv_c1111 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1011(u8);
impl TokenField_thv_c1011 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1010(u8);
impl TokenField_thv_c1010 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0911(u8);
impl TokenField_thv_c0911 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0909(u8);
impl TokenField_thv_c0909 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0811(u8);
impl TokenField_thv_c0811 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0809(u8);
impl TokenField_thv_c0809 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0808(u8);
impl TokenField_thv_c0808 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0711(u8);
impl TokenField_thv_c0711 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0709(u8);
impl TokenField_thv_c0709 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0708(u8);
impl TokenField_thv_c0708 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0707(u8);
impl TokenField_thv_c0707 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0611(u8);
impl TokenField_thv_c0611 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0607(u8);
impl TokenField_thv_c0607 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0606(u8);
impl TokenField_thv_c0606 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0508(u8);
impl TokenField_thv_c0508 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0507(u8);
impl TokenField_thv_c0507 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0506(u8);
impl TokenField_thv_c0506 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0505(u8);
impl TokenField_thv_c0505 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0431(u32);
impl TokenField_thv_c0431 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0427(u32);
impl TokenField_thv_c0427 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0411(u8);
impl TokenField_thv_c0411 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0409(u8);
impl TokenField_thv_c0409 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0407(u8);
impl TokenField_thv_c0407 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0406(u8);
impl TokenField_thv_c0406 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0405(u8);
impl TokenField_thv_c0405 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0404(u8);
impl TokenField_thv_c0404 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0303(u8);
impl TokenField_thv_c0303 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0215(u16);
impl TokenField_thv_c0215 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0202(u8);
impl TokenField_thv_c0202 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0101(u8);
impl TokenField_thv_c0101 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0104(u8);
impl TokenField_thv_c0104 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0031(u32);
impl TokenField_thv_c0031 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0027(u32);
impl TokenField_thv_c0027 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0015(u16);
impl TokenField_thv_c0015 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0011(u16);
impl TokenField_thv_c0011 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0010(u16);
impl TokenField_thv_c0010 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0008(u16);
impl TokenField_thv_c0008 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0007(u8);
impl TokenField_thv_c0007 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0006(u8);
impl TokenField_thv_c0006 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0004(u8);
impl TokenField_thv_c0004 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0003(u8);
impl TokenField_thv_c0003 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0001(u8);
impl TokenField_thv_c0001 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0000(u8);
impl TokenField_thv_c0000 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_option(u8);
impl TokenField_thv_option {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2op(u8);
impl TokenField_part2op {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2J1(u8);
impl TokenField_part2J1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2J2(u8);
impl TokenField_part2J2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2cond(u8);
impl TokenField_part2cond {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2imm6(u8);
impl TokenField_part2imm6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2S(u8);
impl TokenField_part2S {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2imm11(u16);
impl TokenField_part2imm11 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2imm10(u16);
impl TokenField_part2imm10 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2off(u16);
impl TokenField_part2off {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2off_10(u16);
impl TokenField_part2off_10 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2c1415(u8);
impl TokenField_part2c1415 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2c1212(u8);
impl TokenField_part2c1212 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2c0615(u16);
impl TokenField_part2c0615 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2Rt(u8);
impl TokenField_part2Rt {
    fn execution(&self) -> Register {
        meaning_7_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2c0011(u16);
impl TokenField_part2c0011 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2c0909(u8);
impl TokenField_part2c0909 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2c0808(u8);
impl TokenField_part2c0808 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2c0707(u8);
impl TokenField_part2c0707 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2c0505(u8);
impl TokenField_part2c0505 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2c0404(u8);
impl TokenField_part2c0404 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_part2Rd0003(u8);
impl TokenField_part2Rd0003 {
    fn execution(&self) -> Register {
        meaning_7_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op4(u16);
impl TokenField_op4 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op6(u16);
impl TokenField_op6 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op7(u16);
impl TokenField_op7 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op8(u8);
impl TokenField_op8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op9(u8);
impl TokenField_op9 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op11(u8);
impl TokenField_op11 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op12(u8);
impl TokenField_op12 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op0(u16);
impl TokenField_op0 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sop0407(u8);
impl TokenField_sop0407 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sop0507(u8);
impl TokenField_sop0507 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sop0508(u8);
impl TokenField_sop0508 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sop0003(u8);
impl TokenField_sop0003 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sop0608(u8);
impl TokenField_sop0608 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sop0610(u8);
impl TokenField_sop0610 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sopit(u8);
impl TokenField_sopit {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Ra1215(u8);
impl TokenField_Ra1215 {
    fn execution(&self) -> Register {
        meaning_7_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rd0002(u8);
impl TokenField_Rd0002 {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rd0003(u8);
impl TokenField_Rd0003 {
    fn execution(&self) -> Register {
        meaning_7_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rd0810(u8);
impl TokenField_Rd0810 {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rd0811(u8);
impl TokenField_Rd0811 {
    fn execution(&self) -> Register {
        meaning_7_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rn0002(u8);
impl TokenField_Rn0002 {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rn0003(u8);
impl TokenField_Rn0003 {
    fn execution(&self) -> Register {
        meaning_7_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rn0305(u8);
impl TokenField_Rn0305 {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rn0810(u8);
impl TokenField_Rn0810 {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rm0305(u8);
impl TokenField_Rm0305 {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rm0306(u8);
impl TokenField_Rm0306 {
    fn execution(&self) -> Register {
        meaning_7_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rm0608(u8);
impl TokenField_Rm0608 {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rm0003(u8);
impl TokenField_Rm0003 {
    fn execution(&self) -> Register {
        meaning_7_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rs0305(u8);
impl TokenField_Rs0305 {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rt1215(u8);
impl TokenField_Rt1215 {
    fn execution(&self) -> Register {
        meaning_7_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rt0811(u8);
impl TokenField_Rt0811 {
    fn execution(&self) -> Register {
        meaning_7_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thI9(u8);
impl TokenField_thI9 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thP8(u8);
impl TokenField_thP8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thH8(u8);
impl TokenField_thH8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thL8(u8);
impl TokenField_thL8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thU7(u8);
impl TokenField_thU7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thB6(u8);
impl TokenField_thB6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thN6(u8);
impl TokenField_thN6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thS6(u8);
impl TokenField_thS6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thW5(u8);
impl TokenField_thW5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thL4(u8);
impl TokenField_thL4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thCRd(u8);
impl TokenField_thCRd {
    fn execution(&self) -> Register {
        meaning_9_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_9_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thCRn(u8);
impl TokenField_thCRn {
    fn execution(&self) -> Register {
        meaning_9_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_9_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thCRm(u8);
impl TokenField_thCRm {
    fn execution(&self) -> Register {
        meaning_9_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_9_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_hrn0002(u8);
impl TokenField_hrn0002 {
    fn execution(&self) -> Register {
        meaning_10_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_10_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_hrm0305(u8);
impl TokenField_hrm0305 {
    fn execution(&self) -> Register {
        meaning_10_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_10_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rm0306(u8);
impl TokenField_rm0306 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_hrd0002(u8);
impl TokenField_hrd0002 {
    fn execution(&self) -> Register {
        meaning_10_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_10_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed3(u8);
impl TokenField_immed3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed5(u8);
impl TokenField_immed5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed6(u8);
impl TokenField_immed6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed7(u8);
impl TokenField_immed7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed8(u8);
impl TokenField_immed8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed12_i(u8);
impl TokenField_immed12_i {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed12_imm3(u8);
impl TokenField_immed12_imm3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed12_imm8(u8);
impl TokenField_immed12_imm8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_soffset8(i8);
impl TokenField_soffset8 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_offset10(u16);
impl TokenField_offset10 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_offset10S(u8);
impl TokenField_offset10S {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_offset11(u16);
impl TokenField_offset11 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_soffset11(i16);
impl TokenField_soffset11 {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_offset12(u16);
impl TokenField_offset12 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thcond(u8);
impl TokenField_thcond {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thcpn(u8);
impl TokenField_thcpn {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_11_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thopcode1(u8);
impl TokenField_thopcode1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thopcode2(u8);
impl TokenField_thopcode2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_l07(u8);
impl TokenField_l07 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_l11(u8);
impl TokenField_l11 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_h1(u8);
impl TokenField_h1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_h2(u8);
impl TokenField_h2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_R(u8);
impl TokenField_R {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sbz(u8);
impl TokenField_sbz {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thwbit(u8);
impl TokenField_thwbit {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_th_psrmask(u8);
impl TokenField_th_psrmask {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_addr_pbit(u8);
impl TokenField_addr_pbit {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_addr_ubit(u8);
impl TokenField_addr_ubit {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_addr_wbit(u8);
impl TokenField_addr_wbit {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_addr_puw(u8);
impl TokenField_addr_puw {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_addr_puw1(u8);
impl TokenField_addr_puw1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thsrsMode(u8);
impl TokenField_thsrsMode {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fcond(u8);
impl TokenField_fcond {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_throt(u8);
impl TokenField_throt {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm3_12(u8);
impl TokenField_imm3_12 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm3_shft(u8);
impl TokenField_imm3_shft {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm2_shft(u8);
impl TokenField_imm2_shft {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm5(u8);
impl TokenField_imm5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sysm(u8);
impl TokenField_sysm {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sysm37(u8);
impl TokenField_sysm37 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sysm02(u8);
impl TokenField_sysm02 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0001(u8);
impl TokenField_thc0001 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0002(u8);
impl TokenField_thc0002 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0003(u8);
impl TokenField_thc0003 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0004(u8);
impl TokenField_thc0004 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0005(u8);
impl TokenField_thc0005 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0006(u8);
impl TokenField_thc0006 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0007(u8);
impl TokenField_thc0007 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0011(u16);
impl TokenField_thc0011 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0107(u8);
impl TokenField_thc0107 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0207(u8);
impl TokenField_thc0207 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0307(u8);
impl TokenField_thc0307 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0407(u8);
impl TokenField_thc0407 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0405(u8);
impl TokenField_thc0405 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0409(u8);
impl TokenField_thc0409 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0506(u8);
impl TokenField_thc0506 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0507(u8);
impl TokenField_thc0507 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0607(u8);
impl TokenField_thc0607 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0810(u8);
impl TokenField_thc0810 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0811(u8);
impl TokenField_thc0811 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0910(u8);
impl TokenField_thc0910 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc1414(u8);
impl TokenField_thc1414 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc1313(u8);
impl TokenField_thc1313 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc1212(u8);
impl TokenField_thc1212 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc1214(u8);
impl TokenField_thc1214 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc1111(u8);
impl TokenField_thc1111 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc1010(u8);
impl TokenField_thc1010 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0909(u8);
impl TokenField_thc0909 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0808(u8);
impl TokenField_thc0808 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0707(u8);
impl TokenField_thc0707 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0606(u8);
impl TokenField_thc0606 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0505(u8);
impl TokenField_thc0505 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0404(u8);
impl TokenField_thc0404 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0303(u8);
impl TokenField_thc0303 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0202(u8);
impl TokenField_thc0202 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0101(u8);
impl TokenField_thc0101 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0000(u8);
impl TokenField_thc0000 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0115(u16);
impl TokenField_thc0115 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0215(u16);
impl TokenField_thc0215 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0315(u16);
impl TokenField_thc0315 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0415(u16);
impl TokenField_thc0415 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0515(u16);
impl TokenField_thc0515 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0615(u16);
impl TokenField_thc0615 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0715(u16);
impl TokenField_thc0715 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0815(u8);
impl TokenField_thc0815 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc0915(u8);
impl TokenField_thc0915 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc1015(u8);
impl TokenField_thc1015 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc1112(u8);
impl TokenField_thc1112 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc1115(u8);
impl TokenField_thc1115 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc1215(u8);
impl TokenField_thc1215 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc1315(u8);
impl TokenField_thc1315 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc1415(u8);
impl TokenField_thc1415 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thc1515(u8);
impl TokenField_thc1515 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
struct TokenParser<const LEN: usize>([u8; LEN]);
impl<const LEN: usize> MemoryRead for TokenParser<LEN> {
    type AddressType = usize;
    fn read(
        &self,
        addr: Self::AddressType,
        buf: &mut [u8],
    ) -> Result<(), MemoryReadError<Self::AddressType>> {
        let end = addr + buf.len();
        self.0
            .get(addr..end)
            .map(|src| buf.copy_from_slice(src))
            .ok_or(MemoryReadError::UnableToReadMemory(addr, end))
    }
}
impl<const LEN: usize> TokenParser<LEN> {
    fn new(data: &[u8]) -> Option<Self> {
        let token_slice: &[u8] = data.get(..LEN)?;
        let token_data = <[u8; LEN]>::try_from(token_slice).unwrap();
        Some(Self(token_data))
    }
    fn TokenFieldpref(&self) -> TokenField_pref {
        let inner_value = self.read_u32::<false>(0, 0, 32).unwrap();
        TokenField_pref(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldcond(&self) -> TokenField_cond {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_cond(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldI25(&self) -> TokenField_I25 {
        let inner_value = self.read_u8::<false>(3, 1, 1).unwrap();
        TokenField_I25(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldP24(&self) -> TokenField_P24 {
        let inner_value = self.read_u8::<false>(3, 0, 1).unwrap();
        TokenField_P24(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldH24(&self) -> TokenField_H24 {
        let inner_value = self.read_u8::<false>(3, 0, 1).unwrap();
        TokenField_H24(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldL24(&self) -> TokenField_L24 {
        let inner_value = self.read_u8::<false>(3, 0, 1).unwrap();
        TokenField_L24(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldU23(&self) -> TokenField_U23 {
        let inner_value = self.read_u8::<false>(2, 7, 1).unwrap();
        TokenField_U23(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldB22(&self) -> TokenField_B22 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_B22(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldN22(&self) -> TokenField_N22 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_N22(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldS22(&self) -> TokenField_S22 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_S22(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldop(&self) -> TokenField_op {
        let inner_value = self.read_u16::<false>(2, 5, 4).unwrap();
        TokenField_op(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldW21(&self) -> TokenField_W21 {
        let inner_value = self.read_u8::<false>(2, 5, 1).unwrap();
        TokenField_W21(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldS20(&self) -> TokenField_S20 {
        let inner_value = self.read_u8::<false>(2, 4, 1).unwrap();
        TokenField_S20(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldL20(&self) -> TokenField_L20 {
        let inner_value = self.read_u8::<false>(2, 4, 1).unwrap();
        TokenField_L20(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRn(&self) -> TokenField_Rn {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_Rn(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRnLo(&self) -> TokenField_RnLo {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_RnLo(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldmsb(&self) -> TokenField_msb {
        let inner_value = self.read_u8::<false>(2, 0, 5).unwrap();
        TokenField_msb(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsatimm5(&self) -> TokenField_satimm5 {
        let inner_value = self.read_u8::<false>(2, 0, 5).unwrap();
        TokenField_satimm5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsatimm4(&self) -> TokenField_satimm4 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_satimm4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldmask(&self) -> TokenField_mask {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_mask(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRd(&self) -> TokenField_Rd {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Rd(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRd2(&self) -> TokenField_Rd2 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Rd2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldCRd(&self) -> TokenField_CRd {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_CRd(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldCRn(&self) -> TokenField_CRn {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_CRn(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldCRm(&self) -> TokenField_CRm {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_CRm(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRdHi(&self) -> TokenField_RdHi {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_RdHi(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRdLo(&self) -> TokenField_RdLo {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_RdLo(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsmRd(&self) -> TokenField_smRd {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_smRd(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsmRa(&self) -> TokenField_smRa {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_smRa(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsmRm(&self) -> TokenField_smRm {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_smRm(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsmRn(&self) -> TokenField_smRn {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_smRn(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed12(&self) -> TokenField_immed12 {
        let inner_value = self.read_u16::<false>(1, 0, 12).unwrap();
        TokenField_immed12(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldRs(&self) -> TokenField_Rs {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_Rs(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrotate(&self) -> TokenField_rotate {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_rotate(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmedH(&self) -> TokenField_immedH {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_immedH(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldcpn(&self) -> TokenField_cpn {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_cpn(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldopc1(&self) -> TokenField_opc1 {
        let inner_value = self.read_u8::<false>(2, 5, 3).unwrap();
        TokenField_opc1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldopcode1(&self) -> TokenField_opcode1 {
        let inner_value = self.read_u8::<false>(2, 4, 4).unwrap();
        TokenField_opcode1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldopc2(&self) -> TokenField_opc2 {
        let inner_value = self.read_u8::<false>(0, 5, 3).unwrap();
        TokenField_opc2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldopcode2(&self) -> TokenField_opcode2 {
        let inner_value = self.read_u8::<false>(0, 5, 3).unwrap();
        TokenField_opcode2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldopcode3(&self) -> TokenField_opcode3 {
        let inner_value = self.read_u8::<false>(0, 4, 4).unwrap();
        TokenField_opcode3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldlsb(&self) -> TokenField_lsb {
        let inner_value = self.read_u16::<false>(0, 7, 5).unwrap();
        TokenField_lsb(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsftimm(&self) -> TokenField_sftimm {
        let inner_value = self.read_u16::<false>(0, 7, 5).unwrap();
        TokenField_sftimm(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsh(&self) -> TokenField_sh {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_sh(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldshft(&self) -> TokenField_shft {
        let inner_value = self.read_u8::<false>(0, 5, 2).unwrap();
        TokenField_shft(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed24(&self) -> TokenField_immed24 {
        let inner_value = self.read_u32::<false>(0, 0, 24).unwrap();
        TokenField_immed24(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldaddr24(&self) -> TokenField_addr24 {
        let inner_value = self.read_i32::<false>(0, 0, 24).unwrap();
        TokenField_addr24(i32::try_from(inner_value).unwrap())
    }
    fn TokenFieldoffset_12(&self) -> TokenField_offset_12 {
        let inner_value = self.read_u16::<false>(0, 0, 12).unwrap();
        TokenField_offset_12(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed(&self) -> TokenField_immed {
        let inner_value = self.read_u8::<false>(0, 0, 8).unwrap();
        TokenField_immed(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsrsMode(&self) -> TokenField_srsMode {
        let inner_value = self.read_u8::<false>(0, 0, 5).unwrap();
        TokenField_srsMode(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmedL(&self) -> TokenField_immedL {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_immedL(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed4(&self) -> TokenField_immed4 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_immed4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFielddbOption(&self) -> TokenField_dbOption {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_dbOption(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldibOption(&self) -> TokenField_ibOption {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_ibOption(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRm(&self) -> TokenField_Rm {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Rm(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRmHi(&self) -> TokenField_RmHi {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_RmHi(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRm2(&self) -> TokenField_Rm2 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Rm2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldx(&self) -> TokenField_x {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_x(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldr(&self) -> TokenField_r {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_r(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldy(&self) -> TokenField_y {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_y(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldD22(&self) -> TokenField_D22 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_D22(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldN7(&self) -> TokenField_N7 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_N7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldL7(&self) -> TokenField_L7 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_L7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldQ6(&self) -> TokenField_Q6 {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_Q6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldM5(&self) -> TokenField_M5 {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_M5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldQn0(&self) -> TokenField_Qn0 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_Qn0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldQd0(&self) -> TokenField_Qd0 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Qd0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldQm0(&self) -> TokenField_Qm0 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Qm0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldQn1(&self) -> TokenField_Qn1 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_Qn1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldQd1(&self) -> TokenField_Qd1 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Qd1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldQm1(&self) -> TokenField_Qm1 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Qm1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDn0(&self) -> TokenField_Dn0 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_Dn0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd0(&self) -> TokenField_Dd0 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_1(&self) -> TokenField_Dd_1 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_2(&self) -> TokenField_Dd_2 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_3(&self) -> TokenField_Dd_3 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_4(&self) -> TokenField_Dd_4 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_5(&self) -> TokenField_Dd_5 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_6(&self) -> TokenField_Dd_6 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_7(&self) -> TokenField_Dd_7 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_8(&self) -> TokenField_Dd_8 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_9(&self) -> TokenField_Dd_9 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_9(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_10(&self) -> TokenField_Dd_10 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_10(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_11(&self) -> TokenField_Dd_11 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_11(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_12(&self) -> TokenField_Dd_12 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_12(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_13(&self) -> TokenField_Dd_13 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_13(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_14(&self) -> TokenField_Dd_14 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_14(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_15(&self) -> TokenField_Dd_15 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_15(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_16(&self) -> TokenField_Dd_16 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_16(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDm0(&self) -> TokenField_Dm0 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Dm0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDn1(&self) -> TokenField_Dn1 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_Dn1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd1(&self) -> TokenField_Dd1 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDm1(&self) -> TokenField_Dm1 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Dm1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDm_3(&self) -> TokenField_Dm_3 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_Dm_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDm_4(&self) -> TokenField_Dm_4 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Dm_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSn0(&self) -> TokenField_Sn0 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_Sn0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSd0(&self) -> TokenField_Sd0 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Sd0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSm0(&self) -> TokenField_Sm0 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Sm0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSm0next(&self) -> TokenField_Sm0next {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Sm0next(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSn1(&self) -> TokenField_Sn1 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_Sn1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSd1(&self) -> TokenField_Sd1 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Sd1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSm1(&self) -> TokenField_Sm1 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Sm1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSm1next(&self) -> TokenField_Sm1next {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Sm1next(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSm0_3(&self) -> TokenField_Sm0_3 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_Sm0_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSm1_3(&self) -> TokenField_Sm1_3 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_Sm1_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldcmode(&self) -> TokenField_cmode {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_cmode(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit31(&self) -> TokenField_bit31 {
        let inner_value = self.read_u8::<false>(3, 7, 1).unwrap();
        TokenField_bit31(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit30(&self) -> TokenField_bit30 {
        let inner_value = self.read_u8::<false>(3, 6, 1).unwrap();
        TokenField_bit30(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit29(&self) -> TokenField_bit29 {
        let inner_value = self.read_u8::<false>(3, 5, 1).unwrap();
        TokenField_bit29(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit28(&self) -> TokenField_bit28 {
        let inner_value = self.read_u8::<false>(3, 4, 1).unwrap();
        TokenField_bit28(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2831(&self) -> TokenField_c2831 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_c2831(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2627(&self) -> TokenField_c2627 {
        let inner_value = self.read_u8::<false>(3, 2, 2).unwrap();
        TokenField_c2627(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2531(&self) -> TokenField_c2531 {
        let inner_value = self.read_u8::<false>(3, 1, 7).unwrap();
        TokenField_c2531(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2527(&self) -> TokenField_c2527 {
        let inner_value = self.read_u8::<false>(3, 1, 3).unwrap();
        TokenField_c2527(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2525(&self) -> TokenField_c2525 {
        let inner_value = self.read_u8::<false>(3, 1, 1).unwrap();
        TokenField_c2525(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2427(&self) -> TokenField_c2427 {
        let inner_value = self.read_u8::<false>(3, 0, 4).unwrap();
        TokenField_c2427(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2424(&self) -> TokenField_c2424 {
        let inner_value = self.read_u8::<false>(3, 0, 1).unwrap();
        TokenField_c2424(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2331(&self) -> TokenField_c2331 {
        let inner_value = self.read_u16::<false>(2, 7, 9).unwrap();
        TokenField_c2331(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2327(&self) -> TokenField_c2327 {
        let inner_value = self.read_u16::<false>(2, 7, 5).unwrap();
        TokenField_c2327(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2324(&self) -> TokenField_c2324 {
        let inner_value = self.read_u16::<false>(2, 7, 2).unwrap();
        TokenField_c2324(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2323(&self) -> TokenField_c2323 {
        let inner_value = self.read_u8::<false>(2, 7, 1).unwrap();
        TokenField_c2323(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2222(&self) -> TokenField_c2222 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_c2222(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2131(&self) -> TokenField_c2131 {
        let inner_value = self.read_u16::<false>(2, 5, 11).unwrap();
        TokenField_c2131(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2127(&self) -> TokenField_c2127 {
        let inner_value = self.read_u16::<false>(2, 5, 7).unwrap();
        TokenField_c2127(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2124(&self) -> TokenField_c2124 {
        let inner_value = self.read_u16::<false>(2, 5, 4).unwrap();
        TokenField_c2124(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2123(&self) -> TokenField_c2123 {
        let inner_value = self.read_u8::<false>(2, 5, 3).unwrap();
        TokenField_c2123(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2122(&self) -> TokenField_c2122 {
        let inner_value = self.read_u8::<false>(2, 5, 2).unwrap();
        TokenField_c2122(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2121(&self) -> TokenField_c2121 {
        let inner_value = self.read_u8::<false>(2, 5, 1).unwrap();
        TokenField_c2121(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2027(&self) -> TokenField_c2027 {
        let inner_value = self.read_u16::<false>(2, 4, 8).unwrap();
        TokenField_c2027(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2024(&self) -> TokenField_c2024 {
        let inner_value = self.read_u16::<false>(2, 4, 5).unwrap();
        TokenField_c2024(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2022(&self) -> TokenField_c2022 {
        let inner_value = self.read_u8::<false>(2, 4, 3).unwrap();
        TokenField_c2022(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2021(&self) -> TokenField_c2021 {
        let inner_value = self.read_u8::<false>(2, 4, 2).unwrap();
        TokenField_c2021(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2020(&self) -> TokenField_c2020 {
        let inner_value = self.read_u8::<false>(2, 4, 1).unwrap();
        TokenField_c2020(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1921(&self) -> TokenField_c1921 {
        let inner_value = self.read_u8::<false>(2, 3, 3).unwrap();
        TokenField_c1921(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1919(&self) -> TokenField_c1919 {
        let inner_value = self.read_u8::<false>(2, 3, 1).unwrap();
        TokenField_c1919(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1821(&self) -> TokenField_c1821 {
        let inner_value = self.read_u8::<false>(2, 2, 4).unwrap();
        TokenField_c1821(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1819(&self) -> TokenField_c1819 {
        let inner_value = self.read_u8::<false>(2, 2, 2).unwrap();
        TokenField_c1819(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1818(&self) -> TokenField_c1818 {
        let inner_value = self.read_u8::<false>(2, 2, 1).unwrap();
        TokenField_c1818(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1721(&self) -> TokenField_c1721 {
        let inner_value = self.read_u8::<false>(2, 1, 5).unwrap();
        TokenField_c1721(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1719(&self) -> TokenField_c1719 {
        let inner_value = self.read_u8::<false>(2, 1, 3).unwrap();
        TokenField_c1719(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1718(&self) -> TokenField_c1718 {
        let inner_value = self.read_u8::<false>(2, 1, 2).unwrap();
        TokenField_c1718(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1717(&self) -> TokenField_c1717 {
        let inner_value = self.read_u8::<false>(2, 1, 1).unwrap();
        TokenField_c1717(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1631(&self) -> TokenField_c1631 {
        let inner_value = self.read_u16::<false>(2, 0, 16).unwrap();
        TokenField_c1631(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1627(&self) -> TokenField_c1627 {
        let inner_value = self.read_u16::<false>(2, 0, 12).unwrap();
        TokenField_c1627(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1621(&self) -> TokenField_c1621 {
        let inner_value = self.read_u8::<false>(2, 0, 6).unwrap();
        TokenField_c1621(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1620(&self) -> TokenField_c1620 {
        let inner_value = self.read_u8::<false>(2, 0, 5).unwrap();
        TokenField_c1620(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1619(&self) -> TokenField_c1619 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_c1619(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1618(&self) -> TokenField_c1618 {
        let inner_value = self.read_u8::<false>(2, 0, 3).unwrap();
        TokenField_c1618(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1617(&self) -> TokenField_c1617 {
        let inner_value = self.read_u8::<false>(2, 0, 2).unwrap();
        TokenField_c1617(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1616(&self) -> TokenField_c1616 {
        let inner_value = self.read_u8::<false>(2, 0, 1).unwrap();
        TokenField_c1616(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1515(&self) -> TokenField_c1515 {
        let inner_value = self.read_u8::<false>(1, 7, 1).unwrap();
        TokenField_c1515(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1415(&self) -> TokenField_c1415 {
        let inner_value = self.read_u8::<false>(1, 6, 2).unwrap();
        TokenField_c1415(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1414(&self) -> TokenField_c1414 {
        let inner_value = self.read_u8::<false>(1, 6, 1).unwrap();
        TokenField_c1414(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1315(&self) -> TokenField_c1315 {
        let inner_value = self.read_u8::<false>(1, 5, 3).unwrap();
        TokenField_c1315(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1313(&self) -> TokenField_c1313 {
        let inner_value = self.read_u8::<false>(1, 5, 1).unwrap();
        TokenField_c1313(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1215(&self) -> TokenField_c1215 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_c1215(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1212(&self) -> TokenField_c1212 {
        let inner_value = self.read_u8::<false>(1, 4, 1).unwrap();
        TokenField_c1212(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1115(&self) -> TokenField_c1115 {
        let inner_value = self.read_u8::<false>(1, 3, 5).unwrap();
        TokenField_c1115(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1111(&self) -> TokenField_c1111 {
        let inner_value = self.read_u8::<false>(1, 3, 1).unwrap();
        TokenField_c1111(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1015(&self) -> TokenField_c1015 {
        let inner_value = self.read_u8::<false>(1, 2, 6).unwrap();
        TokenField_c1015(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1011(&self) -> TokenField_c1011 {
        let inner_value = self.read_u8::<false>(1, 2, 2).unwrap();
        TokenField_c1011(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1010(&self) -> TokenField_c1010 {
        let inner_value = self.read_u8::<false>(1, 2, 1).unwrap();
        TokenField_c1010(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0916(&self) -> TokenField_c0916 {
        let inner_value = self.read_u16::<false>(1, 1, 8).unwrap();
        TokenField_c0916(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0915(&self) -> TokenField_c0915 {
        let inner_value = self.read_u8::<false>(1, 1, 7).unwrap();
        TokenField_c0915(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0911(&self) -> TokenField_c0911 {
        let inner_value = self.read_u8::<false>(1, 1, 3).unwrap();
        TokenField_c0911(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0909(&self) -> TokenField_c0909 {
        let inner_value = self.read_u8::<false>(1, 1, 1).unwrap();
        TokenField_c0909(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0815(&self) -> TokenField_c0815 {
        let inner_value = self.read_u8::<false>(1, 0, 8).unwrap();
        TokenField_c0815(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0811(&self) -> TokenField_c0811 {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_c0811(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0809(&self) -> TokenField_c0809 {
        let inner_value = self.read_u8::<false>(1, 0, 2).unwrap();
        TokenField_c0809(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0808(&self) -> TokenField_c0808 {
        let inner_value = self.read_u8::<false>(1, 0, 1).unwrap();
        TokenField_c0808(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0715(&self) -> TokenField_c0715 {
        let inner_value = self.read_u16::<false>(0, 7, 9).unwrap();
        TokenField_c0715(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0711(&self) -> TokenField_c0711 {
        let inner_value = self.read_u16::<false>(0, 7, 5).unwrap();
        TokenField_c0711(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0709(&self) -> TokenField_c0709 {
        let inner_value = self.read_u16::<false>(0, 7, 3).unwrap();
        TokenField_c0709(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0708(&self) -> TokenField_c0708 {
        let inner_value = self.read_u16::<false>(0, 7, 2).unwrap();
        TokenField_c0708(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0707(&self) -> TokenField_c0707 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_c0707(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0615(&self) -> TokenField_c0615 {
        let inner_value = self.read_u16::<false>(0, 6, 10).unwrap();
        TokenField_c0615(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0611(&self) -> TokenField_c0611 {
        let inner_value = self.read_u16::<false>(0, 6, 6).unwrap();
        TokenField_c0611(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0607(&self) -> TokenField_c0607 {
        let inner_value = self.read_u8::<false>(0, 6, 2).unwrap();
        TokenField_c0607(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0606(&self) -> TokenField_c0606 {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_c0606(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0515(&self) -> TokenField_c0515 {
        let inner_value = self.read_u16::<false>(0, 5, 11).unwrap();
        TokenField_c0515(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0508(&self) -> TokenField_c0508 {
        let inner_value = self.read_u16::<false>(0, 5, 4).unwrap();
        TokenField_c0508(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0507(&self) -> TokenField_c0507 {
        let inner_value = self.read_u8::<false>(0, 5, 3).unwrap();
        TokenField_c0507(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0506(&self) -> TokenField_c0506 {
        let inner_value = self.read_u8::<false>(0, 5, 2).unwrap();
        TokenField_c0506(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0505(&self) -> TokenField_c0505 {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_c0505(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0431(&self) -> TokenField_c0431 {
        let inner_value = self.read_u32::<false>(0, 4, 28).unwrap();
        TokenField_c0431(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0427(&self) -> TokenField_c0427 {
        let inner_value = self.read_u32::<false>(0, 4, 24).unwrap();
        TokenField_c0427(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0415(&self) -> TokenField_c0415 {
        let inner_value = self.read_u16::<false>(0, 4, 12).unwrap();
        TokenField_c0415(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0411(&self) -> TokenField_c0411 {
        let inner_value = self.read_u16::<false>(0, 4, 8).unwrap();
        TokenField_c0411(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0409(&self) -> TokenField_c0409 {
        let inner_value = self.read_u16::<false>(0, 4, 6).unwrap();
        TokenField_c0409(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0408(&self) -> TokenField_c0408 {
        let inner_value = self.read_u16::<false>(0, 4, 5).unwrap();
        TokenField_c0408(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0407(&self) -> TokenField_c0407 {
        let inner_value = self.read_u8::<false>(0, 4, 4).unwrap();
        TokenField_c0407(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0406(&self) -> TokenField_c0406 {
        let inner_value = self.read_u8::<false>(0, 4, 3).unwrap();
        TokenField_c0406(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0405(&self) -> TokenField_c0405 {
        let inner_value = self.read_u8::<false>(0, 4, 2).unwrap();
        TokenField_c0405(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0404(&self) -> TokenField_c0404 {
        let inner_value = self.read_u8::<false>(0, 4, 1).unwrap();
        TokenField_c0404(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0315(&self) -> TokenField_c0315 {
        let inner_value = self.read_u16::<false>(0, 3, 13).unwrap();
        TokenField_c0315(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0303(&self) -> TokenField_c0303 {
        let inner_value = self.read_u8::<false>(0, 3, 1).unwrap();
        TokenField_c0303(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0215(&self) -> TokenField_c0215 {
        let inner_value = self.read_u16::<false>(0, 2, 14).unwrap();
        TokenField_c0215(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0202(&self) -> TokenField_c0202 {
        let inner_value = self.read_u8::<false>(0, 2, 1).unwrap();
        TokenField_c0202(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0115(&self) -> TokenField_c0115 {
        let inner_value = self.read_u16::<false>(0, 1, 15).unwrap();
        TokenField_c0115(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0101(&self) -> TokenField_c0101 {
        let inner_value = self.read_u8::<false>(0, 1, 1).unwrap();
        TokenField_c0101(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0031(&self) -> TokenField_c0031 {
        let inner_value = self.read_u32::<false>(0, 0, 32).unwrap();
        TokenField_c0031(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0027(&self) -> TokenField_c0027 {
        let inner_value = self.read_u32::<false>(0, 0, 28).unwrap();
        TokenField_c0027(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0014(&self) -> TokenField_c0014 {
        let inner_value = self.read_u16::<false>(0, 0, 15).unwrap();
        TokenField_c0014(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0013(&self) -> TokenField_c0013 {
        let inner_value = self.read_u16::<false>(0, 0, 14).unwrap();
        TokenField_c0013(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0012(&self) -> TokenField_c0012 {
        let inner_value = self.read_u16::<false>(0, 0, 13).unwrap();
        TokenField_c0012(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0011(&self) -> TokenField_c0011 {
        let inner_value = self.read_u16::<false>(0, 0, 12).unwrap();
        TokenField_c0011(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0010(&self) -> TokenField_c0010 {
        let inner_value = self.read_u16::<false>(0, 0, 11).unwrap();
        TokenField_c0010(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0009(&self) -> TokenField_c0009 {
        let inner_value = self.read_u16::<false>(0, 0, 10).unwrap();
        TokenField_c0009(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0008(&self) -> TokenField_c0008 {
        let inner_value = self.read_u16::<false>(0, 0, 9).unwrap();
        TokenField_c0008(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0007(&self) -> TokenField_c0007 {
        let inner_value = self.read_u8::<false>(0, 0, 8).unwrap();
        TokenField_c0007(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0006(&self) -> TokenField_c0006 {
        let inner_value = self.read_u8::<false>(0, 0, 7).unwrap();
        TokenField_c0006(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0005(&self) -> TokenField_c0005 {
        let inner_value = self.read_u8::<false>(0, 0, 6).unwrap();
        TokenField_c0005(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0004(&self) -> TokenField_c0004 {
        let inner_value = self.read_u8::<false>(0, 0, 5).unwrap();
        TokenField_c0004(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0003(&self) -> TokenField_c0003 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_c0003(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0002(&self) -> TokenField_c0002 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_c0002(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0001(&self) -> TokenField_c0001 {
        let inner_value = self.read_u8::<false>(0, 0, 2).unwrap();
        TokenField_c0001(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0000(&self) -> TokenField_c0000 {
        let inner_value = self.read_u8::<false>(0, 0, 1).unwrap();
        TokenField_c0000(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_D22(&self) -> TokenField_thv_D22 {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_thv_D22(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_N7(&self) -> TokenField_thv_N7 {
        let inner_value = self.read_u8::<false>(2, 7, 1).unwrap();
        TokenField_thv_N7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_L7(&self) -> TokenField_thv_L7 {
        let inner_value = self.read_u8::<false>(2, 7, 1).unwrap();
        TokenField_thv_L7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Q6(&self) -> TokenField_thv_Q6 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_thv_Q6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_M5(&self) -> TokenField_thv_M5 {
        let inner_value = self.read_u8::<false>(2, 5, 1).unwrap();
        TokenField_thv_M5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Qn0(&self) -> TokenField_thv_Qn0 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_Qn0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Qd0(&self) -> TokenField_thv_Qd0 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Qd0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Qm0(&self) -> TokenField_thv_Qm0 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Qm0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Qn1(&self) -> TokenField_thv_Qn1 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_Qn1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Qd1(&self) -> TokenField_thv_Qd1 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Qd1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Qm1(&self) -> TokenField_thv_Qm1 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Qm1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dn0(&self) -> TokenField_thv_Dn0 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_Dn0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd0(&self) -> TokenField_thv_Dd0 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_1(&self) -> TokenField_thv_Dd_1 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_2(&self) -> TokenField_thv_Dd_2 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_3(&self) -> TokenField_thv_Dd_3 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_4(&self) -> TokenField_thv_Dd_4 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_5(&self) -> TokenField_thv_Dd_5 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_6(&self) -> TokenField_thv_Dd_6 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_7(&self) -> TokenField_thv_Dd_7 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_8(&self) -> TokenField_thv_Dd_8 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_9(&self) -> TokenField_thv_Dd_9 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_9(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_10(&self) -> TokenField_thv_Dd_10 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_10(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_11(&self) -> TokenField_thv_Dd_11 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_11(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_12(&self) -> TokenField_thv_Dd_12 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_12(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_13(&self) -> TokenField_thv_Dd_13 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_13(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_14(&self) -> TokenField_thv_Dd_14 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_14(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_15(&self) -> TokenField_thv_Dd_15 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_15(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_16(&self) -> TokenField_thv_Dd_16 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_16(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dm0(&self) -> TokenField_thv_Dm0 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Dm0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dn1(&self) -> TokenField_thv_Dn1 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_Dn1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd1(&self) -> TokenField_thv_Dd1 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dm1(&self) -> TokenField_thv_Dm1 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Dm1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dm_3(&self) -> TokenField_thv_Dm_3 {
        let inner_value = self.read_u8::<false>(2, 0, 3).unwrap();
        TokenField_thv_Dm_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dm_4(&self) -> TokenField_thv_Dm_4 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Dm_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sn0(&self) -> TokenField_thv_Sn0 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_Sn0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sd0(&self) -> TokenField_thv_Sd0 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Sd0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sm0(&self) -> TokenField_thv_Sm0 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Sm0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sm0next(&self) -> TokenField_thv_Sm0next {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Sm0next(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sn1(&self) -> TokenField_thv_Sn1 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_Sn1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sd1(&self) -> TokenField_thv_Sd1 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Sd1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sm1(&self) -> TokenField_thv_Sm1 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Sm1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sm1next(&self) -> TokenField_thv_Sm1next {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Sm1next(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_cmode(&self) -> TokenField_thv_cmode {
        let inner_value = self.read_u8::<false>(3, 0, 4).unwrap();
        TokenField_thv_cmode(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sm0_3(&self) -> TokenField_thv_Sm0_3 {
        let inner_value = self.read_u8::<false>(2, 0, 3).unwrap();
        TokenField_thv_Sm0_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sm1_3(&self) -> TokenField_thv_Sm1_3 {
        let inner_value = self.read_u8::<false>(2, 0, 3).unwrap();
        TokenField_thv_Sm1_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Rd(&self) -> TokenField_thv_Rd {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Rd(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Rt(&self) -> TokenField_thv_Rt {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Rt(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Rn(&self) -> TokenField_thv_Rn {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_Rn(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Rm(&self) -> TokenField_thv_Rm {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Rm(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Rt2(&self) -> TokenField_thv_Rt2 {
        let inner_value = self.read_u8::<false>(3, 0, 4).unwrap();
        TokenField_thv_Rt2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_immed(&self) -> TokenField_thv_immed {
        let inner_value = self.read_u8::<false>(2, 0, 8).unwrap();
        TokenField_thv_immed(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit31(&self) -> TokenField_thv_bit31 {
        let inner_value = self.read_u8::<false>(1, 7, 1).unwrap();
        TokenField_thv_bit31(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit30(&self) -> TokenField_thv_bit30 {
        let inner_value = self.read_u8::<false>(1, 6, 1).unwrap();
        TokenField_thv_bit30(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit29(&self) -> TokenField_thv_bit29 {
        let inner_value = self.read_u8::<false>(1, 5, 1).unwrap();
        TokenField_thv_bit29(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit28(&self) -> TokenField_thv_bit28 {
        let inner_value = self.read_u8::<false>(1, 4, 1).unwrap();
        TokenField_thv_bit28(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit23(&self) -> TokenField_thv_bit23 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_thv_bit23(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit21(&self) -> TokenField_thv_bit21 {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_thv_bit21(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit20(&self) -> TokenField_thv_bit20 {
        let inner_value = self.read_u8::<false>(0, 4, 1).unwrap();
        TokenField_thv_bit20(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit07(&self) -> TokenField_thv_bit07 {
        let inner_value = self.read_u8::<false>(2, 7, 1).unwrap();
        TokenField_thv_bit07(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit06(&self) -> TokenField_thv_bit06 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_thv_bit06(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit00(&self) -> TokenField_thv_bit00 {
        let inner_value = self.read_u8::<false>(2, 0, 1).unwrap();
        TokenField_thv_bit00(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2931(&self) -> TokenField_thv_c2931 {
        let inner_value = self.read_u8::<false>(1, 5, 3).unwrap();
        TokenField_thv_c2931(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2831(&self) -> TokenField_thv_c2831 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_thv_c2831(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2828(&self) -> TokenField_thv_c2828 {
        let inner_value = self.read_u8::<false>(1, 4, 1).unwrap();
        TokenField_thv_c2828(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2627(&self) -> TokenField_thv_c2627 {
        let inner_value = self.read_u8::<false>(1, 2, 2).unwrap();
        TokenField_thv_c2627(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2531(&self) -> TokenField_thv_c2531 {
        let inner_value = self.read_u8::<false>(1, 1, 7).unwrap();
        TokenField_thv_c2531(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2527(&self) -> TokenField_thv_c2527 {
        let inner_value = self.read_u8::<false>(1, 1, 3).unwrap();
        TokenField_thv_c2527(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2525(&self) -> TokenField_thv_c2525 {
        let inner_value = self.read_u8::<false>(1, 1, 1).unwrap();
        TokenField_thv_c2525(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2427(&self) -> TokenField_thv_c2427 {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_thv_c2427(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2424(&self) -> TokenField_thv_c2424 {
        let inner_value = self.read_u8::<false>(1, 0, 1).unwrap();
        TokenField_thv_c2424(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2331(&self) -> TokenField_thv_c2331 {
        let inner_value = self.read_u16::<false>(0, 7, 9).unwrap();
        TokenField_thv_c2331(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2327(&self) -> TokenField_thv_c2327 {
        let inner_value = self.read_u16::<false>(0, 7, 5).unwrap();
        TokenField_thv_c2327(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2324(&self) -> TokenField_thv_c2324 {
        let inner_value = self.read_u16::<false>(0, 7, 2).unwrap();
        TokenField_thv_c2324(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2323(&self) -> TokenField_thv_c2323 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_thv_c2323(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2222(&self) -> TokenField_thv_c2222 {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_thv_c2222(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2131(&self) -> TokenField_thv_c2131 {
        let inner_value = self.read_u16::<false>(0, 5, 11).unwrap();
        TokenField_thv_c2131(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2127(&self) -> TokenField_thv_c2127 {
        let inner_value = self.read_u16::<false>(0, 5, 7).unwrap();
        TokenField_thv_c2127(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2124(&self) -> TokenField_thv_c2124 {
        let inner_value = self.read_u16::<false>(0, 5, 4).unwrap();
        TokenField_thv_c2124(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2123(&self) -> TokenField_thv_c2123 {
        let inner_value = self.read_u8::<false>(0, 5, 3).unwrap();
        TokenField_thv_c2123(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2122(&self) -> TokenField_thv_c2122 {
        let inner_value = self.read_u8::<false>(0, 5, 2).unwrap();
        TokenField_thv_c2122(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2121(&self) -> TokenField_thv_c2121 {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_thv_c2121(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2031(&self) -> TokenField_thv_c2031 {
        let inner_value = self.read_u16::<false>(0, 4, 12).unwrap();
        TokenField_thv_c2031(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2027(&self) -> TokenField_thv_c2027 {
        let inner_value = self.read_u16::<false>(0, 4, 8).unwrap();
        TokenField_thv_c2027(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2024(&self) -> TokenField_thv_c2024 {
        let inner_value = self.read_u16::<false>(0, 4, 5).unwrap();
        TokenField_thv_c2024(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2022(&self) -> TokenField_thv_c2022 {
        let inner_value = self.read_u8::<false>(0, 4, 3).unwrap();
        TokenField_thv_c2022(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2021(&self) -> TokenField_thv_c2021 {
        let inner_value = self.read_u8::<false>(0, 4, 2).unwrap();
        TokenField_thv_c2021(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2020(&self) -> TokenField_thv_c2020 {
        let inner_value = self.read_u8::<false>(0, 4, 1).unwrap();
        TokenField_thv_c2020(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1921(&self) -> TokenField_thv_c1921 {
        let inner_value = self.read_u8::<false>(0, 3, 3).unwrap();
        TokenField_thv_c1921(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1919(&self) -> TokenField_thv_c1919 {
        let inner_value = self.read_u8::<false>(0, 3, 1).unwrap();
        TokenField_thv_c1919(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1821(&self) -> TokenField_thv_c1821 {
        let inner_value = self.read_u8::<false>(0, 2, 4).unwrap();
        TokenField_thv_c1821(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1819(&self) -> TokenField_thv_c1819 {
        let inner_value = self.read_u8::<false>(0, 2, 2).unwrap();
        TokenField_thv_c1819(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1818(&self) -> TokenField_thv_c1818 {
        let inner_value = self.read_u8::<false>(0, 2, 1).unwrap();
        TokenField_thv_c1818(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1721(&self) -> TokenField_thv_c1721 {
        let inner_value = self.read_u8::<false>(0, 1, 5).unwrap();
        TokenField_thv_c1721(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1719(&self) -> TokenField_thv_c1719 {
        let inner_value = self.read_u8::<false>(0, 1, 3).unwrap();
        TokenField_thv_c1719(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1718(&self) -> TokenField_thv_c1718 {
        let inner_value = self.read_u8::<false>(0, 1, 2).unwrap();
        TokenField_thv_c1718(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1717(&self) -> TokenField_thv_c1717 {
        let inner_value = self.read_u8::<false>(0, 1, 1).unwrap();
        TokenField_thv_c1717(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1631(&self) -> TokenField_thv_c1631 {
        let inner_value = self.read_u16::<false>(0, 0, 16).unwrap();
        TokenField_thv_c1631(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1627(&self) -> TokenField_thv_c1627 {
        let inner_value = self.read_u16::<false>(0, 0, 12).unwrap();
        TokenField_thv_c1627(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1621(&self) -> TokenField_thv_c1621 {
        let inner_value = self.read_u8::<false>(0, 0, 6).unwrap();
        TokenField_thv_c1621(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1620(&self) -> TokenField_thv_c1620 {
        let inner_value = self.read_u8::<false>(0, 0, 5).unwrap();
        TokenField_thv_c1620(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1619(&self) -> TokenField_thv_c1619 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_c1619(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1618(&self) -> TokenField_thv_c1618 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_thv_c1618(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1617(&self) -> TokenField_thv_c1617 {
        let inner_value = self.read_u8::<false>(0, 0, 2).unwrap();
        TokenField_thv_c1617(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1616(&self) -> TokenField_thv_c1616 {
        let inner_value = self.read_u8::<false>(0, 0, 1).unwrap();
        TokenField_thv_c1616(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1515(&self) -> TokenField_thv_c1515 {
        let inner_value = self.read_u8::<false>(3, 7, 1).unwrap();
        TokenField_thv_c1515(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1415(&self) -> TokenField_thv_c1415 {
        let inner_value = self.read_u8::<false>(3, 6, 2).unwrap();
        TokenField_thv_c1415(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1414(&self) -> TokenField_thv_c1414 {
        let inner_value = self.read_u8::<false>(3, 6, 1).unwrap();
        TokenField_thv_c1414(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1313(&self) -> TokenField_thv_c1313 {
        let inner_value = self.read_u8::<false>(3, 5, 1).unwrap();
        TokenField_thv_c1313(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1215(&self) -> TokenField_thv_c1215 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_c1215(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1212(&self) -> TokenField_thv_c1212 {
        let inner_value = self.read_u8::<false>(3, 4, 1).unwrap();
        TokenField_thv_c1212(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1111(&self) -> TokenField_thv_c1111 {
        let inner_value = self.read_u8::<false>(3, 3, 1).unwrap();
        TokenField_thv_c1111(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1011(&self) -> TokenField_thv_c1011 {
        let inner_value = self.read_u8::<false>(3, 2, 2).unwrap();
        TokenField_thv_c1011(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1010(&self) -> TokenField_thv_c1010 {
        let inner_value = self.read_u8::<false>(3, 2, 1).unwrap();
        TokenField_thv_c1010(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0911(&self) -> TokenField_thv_c0911 {
        let inner_value = self.read_u8::<false>(3, 1, 3).unwrap();
        TokenField_thv_c0911(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0909(&self) -> TokenField_thv_c0909 {
        let inner_value = self.read_u8::<false>(3, 1, 1).unwrap();
        TokenField_thv_c0909(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0811(&self) -> TokenField_thv_c0811 {
        let inner_value = self.read_u8::<false>(3, 0, 4).unwrap();
        TokenField_thv_c0811(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0809(&self) -> TokenField_thv_c0809 {
        let inner_value = self.read_u8::<false>(3, 0, 2).unwrap();
        TokenField_thv_c0809(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0808(&self) -> TokenField_thv_c0808 {
        let inner_value = self.read_u8::<false>(3, 0, 1).unwrap();
        TokenField_thv_c0808(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0711(&self) -> TokenField_thv_c0711 {
        let inner_value = self.read_u16::<false>(2, 7, 5).unwrap();
        TokenField_thv_c0711(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0709(&self) -> TokenField_thv_c0709 {
        let inner_value = self.read_u16::<false>(2, 7, 3).unwrap();
        TokenField_thv_c0709(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0708(&self) -> TokenField_thv_c0708 {
        let inner_value = self.read_u16::<false>(2, 7, 2).unwrap();
        TokenField_thv_c0708(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0707(&self) -> TokenField_thv_c0707 {
        let inner_value = self.read_u8::<false>(2, 7, 1).unwrap();
        TokenField_thv_c0707(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0611(&self) -> TokenField_thv_c0611 {
        let inner_value = self.read_u16::<false>(2, 6, 6).unwrap();
        TokenField_thv_c0611(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0607(&self) -> TokenField_thv_c0607 {
        let inner_value = self.read_u8::<false>(2, 6, 2).unwrap();
        TokenField_thv_c0607(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0606(&self) -> TokenField_thv_c0606 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_thv_c0606(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0508(&self) -> TokenField_thv_c0508 {
        let inner_value = self.read_u16::<false>(2, 5, 4).unwrap();
        TokenField_thv_c0508(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0507(&self) -> TokenField_thv_c0507 {
        let inner_value = self.read_u8::<false>(2, 5, 3).unwrap();
        TokenField_thv_c0507(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0506(&self) -> TokenField_thv_c0506 {
        let inner_value = self.read_u8::<false>(2, 5, 2).unwrap();
        TokenField_thv_c0506(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0505(&self) -> TokenField_thv_c0505 {
        let inner_value = self.read_u8::<false>(2, 5, 1).unwrap();
        TokenField_thv_c0505(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0431(&self) -> TokenField_thv_c0431 {
        let inner_value = self.read_u32::<false>(0, 4, 28).unwrap();
        TokenField_thv_c0431(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0427(&self) -> TokenField_thv_c0427 {
        let inner_value = self.read_u32::<false>(0, 4, 24).unwrap();
        TokenField_thv_c0427(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0411(&self) -> TokenField_thv_c0411 {
        let inner_value = self.read_u16::<false>(2, 4, 8).unwrap();
        TokenField_thv_c0411(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0409(&self) -> TokenField_thv_c0409 {
        let inner_value = self.read_u16::<false>(2, 4, 6).unwrap();
        TokenField_thv_c0409(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0407(&self) -> TokenField_thv_c0407 {
        let inner_value = self.read_u8::<false>(2, 4, 4).unwrap();
        TokenField_thv_c0407(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0406(&self) -> TokenField_thv_c0406 {
        let inner_value = self.read_u8::<false>(2, 4, 3).unwrap();
        TokenField_thv_c0406(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0405(&self) -> TokenField_thv_c0405 {
        let inner_value = self.read_u8::<false>(2, 4, 2).unwrap();
        TokenField_thv_c0405(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0404(&self) -> TokenField_thv_c0404 {
        let inner_value = self.read_u8::<false>(2, 4, 1).unwrap();
        TokenField_thv_c0404(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0303(&self) -> TokenField_thv_c0303 {
        let inner_value = self.read_u8::<false>(2, 3, 1).unwrap();
        TokenField_thv_c0303(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0215(&self) -> TokenField_thv_c0215 {
        let inner_value = self.read_u16::<false>(2, 2, 14).unwrap();
        TokenField_thv_c0215(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0202(&self) -> TokenField_thv_c0202 {
        let inner_value = self.read_u8::<false>(2, 2, 1).unwrap();
        TokenField_thv_c0202(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0101(&self) -> TokenField_thv_c0101 {
        let inner_value = self.read_u8::<false>(2, 1, 1).unwrap();
        TokenField_thv_c0101(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0104(&self) -> TokenField_thv_c0104 {
        let inner_value = self.read_u8::<false>(2, 1, 4).unwrap();
        TokenField_thv_c0104(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0031(&self) -> TokenField_thv_c0031 {
        let inner_value = self.read_u32::<false>(0, 0, 32).unwrap();
        TokenField_thv_c0031(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0027(&self) -> TokenField_thv_c0027 {
        let inner_value = self.read_u32::<false>(0, 0, 28).unwrap();
        TokenField_thv_c0027(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0015(&self) -> TokenField_thv_c0015 {
        let inner_value = self.read_u16::<false>(2, 0, 16).unwrap();
        TokenField_thv_c0015(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0011(&self) -> TokenField_thv_c0011 {
        let inner_value = self.read_u16::<false>(2, 0, 12).unwrap();
        TokenField_thv_c0011(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0010(&self) -> TokenField_thv_c0010 {
        let inner_value = self.read_u16::<false>(2, 0, 11).unwrap();
        TokenField_thv_c0010(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0008(&self) -> TokenField_thv_c0008 {
        let inner_value = self.read_u16::<false>(2, 0, 9).unwrap();
        TokenField_thv_c0008(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0007(&self) -> TokenField_thv_c0007 {
        let inner_value = self.read_u8::<false>(2, 0, 8).unwrap();
        TokenField_thv_c0007(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0006(&self) -> TokenField_thv_c0006 {
        let inner_value = self.read_u8::<false>(2, 0, 7).unwrap();
        TokenField_thv_c0006(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0004(&self) -> TokenField_thv_c0004 {
        let inner_value = self.read_u8::<false>(2, 0, 5).unwrap();
        TokenField_thv_c0004(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0003(&self) -> TokenField_thv_c0003 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_c0003(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0001(&self) -> TokenField_thv_c0001 {
        let inner_value = self.read_u8::<false>(2, 0, 2).unwrap();
        TokenField_thv_c0001(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0000(&self) -> TokenField_thv_c0000 {
        let inner_value = self.read_u8::<false>(2, 0, 1).unwrap();
        TokenField_thv_c0000(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_option(&self) -> TokenField_thv_option {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_option(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2op(&self) -> TokenField_part2op {
        let inner_value = self.read_u8::<false>(1, 3, 5).unwrap();
        TokenField_part2op(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2J1(&self) -> TokenField_part2J1 {
        let inner_value = self.read_u8::<false>(1, 5, 1).unwrap();
        TokenField_part2J1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2J2(&self) -> TokenField_part2J2 {
        let inner_value = self.read_u8::<false>(1, 3, 1).unwrap();
        TokenField_part2J2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2cond(&self) -> TokenField_part2cond {
        let inner_value = self.read_u16::<false>(0, 6, 4).unwrap();
        TokenField_part2cond(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2imm6(&self) -> TokenField_part2imm6 {
        let inner_value = self.read_u8::<false>(0, 0, 6).unwrap();
        TokenField_part2imm6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2S(&self) -> TokenField_part2S {
        let inner_value = self.read_u8::<false>(1, 2, 1).unwrap();
        TokenField_part2S(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2imm11(&self) -> TokenField_part2imm11 {
        let inner_value = self.read_u16::<false>(0, 0, 11).unwrap();
        TokenField_part2imm11(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2imm10(&self) -> TokenField_part2imm10 {
        let inner_value = self.read_u16::<false>(0, 0, 10).unwrap();
        TokenField_part2imm10(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2off(&self) -> TokenField_part2off {
        let inner_value = self.read_u16::<false>(0, 0, 11).unwrap();
        TokenField_part2off(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2off_10(&self) -> TokenField_part2off_10 {
        let inner_value = self.read_u16::<false>(0, 1, 10).unwrap();
        TokenField_part2off_10(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2c1415(&self) -> TokenField_part2c1415 {
        let inner_value = self.read_u8::<false>(1, 6, 2).unwrap();
        TokenField_part2c1415(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2c1212(&self) -> TokenField_part2c1212 {
        let inner_value = self.read_u8::<false>(1, 4, 1).unwrap();
        TokenField_part2c1212(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2c0615(&self) -> TokenField_part2c0615 {
        let inner_value = self.read_u16::<false>(0, 6, 10).unwrap();
        TokenField_part2c0615(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2Rt(&self) -> TokenField_part2Rt {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_part2Rt(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2c0011(&self) -> TokenField_part2c0011 {
        let inner_value = self.read_u16::<false>(0, 0, 12).unwrap();
        TokenField_part2c0011(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2c0909(&self) -> TokenField_part2c0909 {
        let inner_value = self.read_u8::<false>(1, 1, 1).unwrap();
        TokenField_part2c0909(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2c0808(&self) -> TokenField_part2c0808 {
        let inner_value = self.read_u8::<false>(1, 0, 1).unwrap();
        TokenField_part2c0808(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2c0707(&self) -> TokenField_part2c0707 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_part2c0707(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2c0505(&self) -> TokenField_part2c0505 {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_part2c0505(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2c0404(&self) -> TokenField_part2c0404 {
        let inner_value = self.read_u8::<false>(0, 4, 1).unwrap();
        TokenField_part2c0404(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldpart2Rd0003(&self) -> TokenField_part2Rd0003 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_part2Rd0003(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldop4(&self) -> TokenField_op4 {
        let inner_value = self.read_u16::<false>(0, 4, 12).unwrap();
        TokenField_op4(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldop6(&self) -> TokenField_op6 {
        let inner_value = self.read_u16::<false>(0, 6, 10).unwrap();
        TokenField_op6(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldop7(&self) -> TokenField_op7 {
        let inner_value = self.read_u16::<false>(0, 7, 9).unwrap();
        TokenField_op7(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldop8(&self) -> TokenField_op8 {
        let inner_value = self.read_u8::<false>(1, 0, 8).unwrap();
        TokenField_op8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldop9(&self) -> TokenField_op9 {
        let inner_value = self.read_u8::<false>(1, 1, 7).unwrap();
        TokenField_op9(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldop11(&self) -> TokenField_op11 {
        let inner_value = self.read_u8::<false>(1, 3, 5).unwrap();
        TokenField_op11(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldop12(&self) -> TokenField_op12 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_op12(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldop0(&self) -> TokenField_op0 {
        let inner_value = self.read_u16::<false>(0, 0, 16).unwrap();
        TokenField_op0(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldsop0407(&self) -> TokenField_sop0407 {
        let inner_value = self.read_u8::<false>(0, 4, 4).unwrap();
        TokenField_sop0407(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsop0507(&self) -> TokenField_sop0507 {
        let inner_value = self.read_u8::<false>(0, 5, 3).unwrap();
        TokenField_sop0507(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsop0508(&self) -> TokenField_sop0508 {
        let inner_value = self.read_u16::<false>(0, 5, 4).unwrap();
        TokenField_sop0508(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsop0003(&self) -> TokenField_sop0003 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_sop0003(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsop0608(&self) -> TokenField_sop0608 {
        let inner_value = self.read_u16::<false>(0, 6, 3).unwrap();
        TokenField_sop0608(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsop0610(&self) -> TokenField_sop0610 {
        let inner_value = self.read_u16::<false>(0, 6, 5).unwrap();
        TokenField_sop0610(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsopit(&self) -> TokenField_sopit {
        let inner_value = self.read_u8::<false>(0, 0, 8).unwrap();
        TokenField_sopit(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRa1215(&self) -> TokenField_Ra1215 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Ra1215(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRd0002(&self) -> TokenField_Rd0002 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_Rd0002(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRd0003(&self) -> TokenField_Rd0003 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Rd0003(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRd0810(&self) -> TokenField_Rd0810 {
        let inner_value = self.read_u8::<false>(1, 0, 3).unwrap();
        TokenField_Rd0810(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRd0811(&self) -> TokenField_Rd0811 {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_Rd0811(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRn0002(&self) -> TokenField_Rn0002 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_Rn0002(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRn0003(&self) -> TokenField_Rn0003 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Rn0003(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRn0305(&self) -> TokenField_Rn0305 {
        let inner_value = self.read_u8::<false>(0, 3, 3).unwrap();
        TokenField_Rn0305(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRn0810(&self) -> TokenField_Rn0810 {
        let inner_value = self.read_u8::<false>(1, 0, 3).unwrap();
        TokenField_Rn0810(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRm0305(&self) -> TokenField_Rm0305 {
        let inner_value = self.read_u8::<false>(0, 3, 3).unwrap();
        TokenField_Rm0305(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRm0306(&self) -> TokenField_Rm0306 {
        let inner_value = self.read_u8::<false>(0, 3, 4).unwrap();
        TokenField_Rm0306(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRm0608(&self) -> TokenField_Rm0608 {
        let inner_value = self.read_u16::<false>(0, 6, 3).unwrap();
        TokenField_Rm0608(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRm0003(&self) -> TokenField_Rm0003 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Rm0003(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRs0305(&self) -> TokenField_Rs0305 {
        let inner_value = self.read_u8::<false>(0, 3, 3).unwrap();
        TokenField_Rs0305(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRt1215(&self) -> TokenField_Rt1215 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Rt1215(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRt0811(&self) -> TokenField_Rt0811 {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_Rt0811(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthI9(&self) -> TokenField_thI9 {
        let inner_value = self.read_u8::<false>(1, 1, 1).unwrap();
        TokenField_thI9(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthP8(&self) -> TokenField_thP8 {
        let inner_value = self.read_u8::<false>(1, 0, 1).unwrap();
        TokenField_thP8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthH8(&self) -> TokenField_thH8 {
        let inner_value = self.read_u8::<false>(1, 0, 1).unwrap();
        TokenField_thH8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthL8(&self) -> TokenField_thL8 {
        let inner_value = self.read_u8::<false>(1, 0, 1).unwrap();
        TokenField_thL8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthU7(&self) -> TokenField_thU7 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_thU7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthB6(&self) -> TokenField_thB6 {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_thB6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthN6(&self) -> TokenField_thN6 {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_thN6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthS6(&self) -> TokenField_thS6 {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_thS6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthW5(&self) -> TokenField_thW5 {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_thW5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthL4(&self) -> TokenField_thL4 {
        let inner_value = self.read_u8::<false>(0, 4, 1).unwrap();
        TokenField_thL4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthCRd(&self) -> TokenField_thCRd {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_thCRd(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthCRn(&self) -> TokenField_thCRn {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thCRn(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthCRm(&self) -> TokenField_thCRm {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thCRm(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldhrn0002(&self) -> TokenField_hrn0002 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_hrn0002(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldhrm0305(&self) -> TokenField_hrm0305 {
        let inner_value = self.read_u8::<false>(0, 3, 3).unwrap();
        TokenField_hrm0305(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrm0306(&self) -> TokenField_rm0306 {
        let inner_value = self.read_u8::<false>(0, 3, 4).unwrap();
        TokenField_rm0306(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldhrd0002(&self) -> TokenField_hrd0002 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_hrd0002(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed3(&self) -> TokenField_immed3 {
        let inner_value = self.read_u16::<false>(0, 6, 3).unwrap();
        TokenField_immed3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed5(&self) -> TokenField_immed5 {
        let inner_value = self.read_u16::<false>(0, 6, 5).unwrap();
        TokenField_immed5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed6(&self) -> TokenField_immed6 {
        let inner_value = self.read_u8::<false>(0, 0, 6).unwrap();
        TokenField_immed6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed7(&self) -> TokenField_immed7 {
        let inner_value = self.read_u8::<false>(0, 0, 7).unwrap();
        TokenField_immed7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed8(&self) -> TokenField_immed8 {
        let inner_value = self.read_u8::<false>(0, 0, 8).unwrap();
        TokenField_immed8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed12_i(&self) -> TokenField_immed12_i {
        let inner_value = self.read_u8::<false>(1, 2, 1).unwrap();
        TokenField_immed12_i(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed12_imm3(&self) -> TokenField_immed12_imm3 {
        let inner_value = self.read_u8::<false>(1, 4, 3).unwrap();
        TokenField_immed12_imm3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed12_imm8(&self) -> TokenField_immed12_imm8 {
        let inner_value = self.read_u8::<false>(0, 0, 8).unwrap();
        TokenField_immed12_imm8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsoffset8(&self) -> TokenField_soffset8 {
        let inner_value = self.read_i8::<false>(0, 0, 8).unwrap();
        TokenField_soffset8(i8::try_from(inner_value).unwrap())
    }
    fn TokenFieldoffset10(&self) -> TokenField_offset10 {
        let inner_value = self.read_u16::<false>(0, 0, 10).unwrap();
        TokenField_offset10(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldoffset10S(&self) -> TokenField_offset10S {
        let inner_value = self.read_u8::<false>(1, 2, 1).unwrap();
        TokenField_offset10S(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldoffset11(&self) -> TokenField_offset11 {
        let inner_value = self.read_u16::<false>(0, 0, 11).unwrap();
        TokenField_offset11(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldsoffset11(&self) -> TokenField_soffset11 {
        let inner_value = self.read_i16::<false>(0, 0, 11).unwrap();
        TokenField_soffset11(i16::try_from(inner_value).unwrap())
    }
    fn TokenFieldoffset12(&self) -> TokenField_offset12 {
        let inner_value = self.read_u16::<false>(0, 0, 12).unwrap();
        TokenField_offset12(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthcond(&self) -> TokenField_thcond {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_thcond(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthcpn(&self) -> TokenField_thcpn {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_thcpn(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthopcode1(&self) -> TokenField_thopcode1 {
        let inner_value = self.read_u8::<false>(0, 4, 4).unwrap();
        TokenField_thopcode1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthopcode2(&self) -> TokenField_thopcode2 {
        let inner_value = self.read_u8::<false>(0, 5, 3).unwrap();
        TokenField_thopcode2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldl07(&self) -> TokenField_l07 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_l07(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldl11(&self) -> TokenField_l11 {
        let inner_value = self.read_u8::<false>(1, 3, 1).unwrap();
        TokenField_l11(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldh1(&self) -> TokenField_h1 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_h1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldh2(&self) -> TokenField_h2 {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_h2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldR(&self) -> TokenField_R {
        let inner_value = self.read_u8::<false>(1, 0, 1).unwrap();
        TokenField_R(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsbz(&self) -> TokenField_sbz {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_sbz(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthwbit(&self) -> TokenField_thwbit {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_thwbit(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldth_psrmask(&self) -> TokenField_th_psrmask {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_th_psrmask(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldaddr_pbit(&self) -> TokenField_addr_pbit {
        let inner_value = self.read_u8::<false>(1, 2, 1).unwrap();
        TokenField_addr_pbit(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldaddr_ubit(&self) -> TokenField_addr_ubit {
        let inner_value = self.read_u8::<false>(1, 1, 1).unwrap();
        TokenField_addr_ubit(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldaddr_wbit(&self) -> TokenField_addr_wbit {
        let inner_value = self.read_u8::<false>(1, 0, 1).unwrap();
        TokenField_addr_wbit(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldaddr_puw(&self) -> TokenField_addr_puw {
        let inner_value = self.read_u8::<false>(1, 0, 3).unwrap();
        TokenField_addr_puw(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldaddr_puw1(&self) -> TokenField_addr_puw1 {
        let inner_value = self.read_u16::<false>(0, 5, 4).unwrap();
        TokenField_addr_puw1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthsrsMode(&self) -> TokenField_thsrsMode {
        let inner_value = self.read_u8::<false>(0, 0, 5).unwrap();
        TokenField_thsrsMode(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldfcond(&self) -> TokenField_fcond {
        let inner_value = self.read_u8::<false>(0, 4, 4).unwrap();
        TokenField_fcond(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthrot(&self) -> TokenField_throt {
        let inner_value = self.read_u8::<false>(0, 4, 3).unwrap();
        TokenField_throt(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimm3_12(&self) -> TokenField_imm3_12 {
        let inner_value = self.read_u8::<false>(1, 4, 3).unwrap();
        TokenField_imm3_12(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimm3_shft(&self) -> TokenField_imm3_shft {
        let inner_value = self.read_u8::<false>(1, 4, 3).unwrap();
        TokenField_imm3_shft(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimm2_shft(&self) -> TokenField_imm2_shft {
        let inner_value = self.read_u8::<false>(0, 6, 2).unwrap();
        TokenField_imm2_shft(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimm5(&self) -> TokenField_imm5 {
        let inner_value = self.read_u8::<false>(0, 3, 5).unwrap();
        TokenField_imm5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsysm(&self) -> TokenField_sysm {
        let inner_value = self.read_u8::<false>(0, 0, 8).unwrap();
        TokenField_sysm(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsysm37(&self) -> TokenField_sysm37 {
        let inner_value = self.read_u8::<false>(0, 3, 5).unwrap();
        TokenField_sysm37(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsysm02(&self) -> TokenField_sysm02 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_sysm02(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0001(&self) -> TokenField_thc0001 {
        let inner_value = self.read_u8::<false>(0, 0, 2).unwrap();
        TokenField_thc0001(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0002(&self) -> TokenField_thc0002 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_thc0002(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0003(&self) -> TokenField_thc0003 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thc0003(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0004(&self) -> TokenField_thc0004 {
        let inner_value = self.read_u8::<false>(0, 0, 5).unwrap();
        TokenField_thc0004(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0005(&self) -> TokenField_thc0005 {
        let inner_value = self.read_u8::<false>(0, 0, 6).unwrap();
        TokenField_thc0005(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0006(&self) -> TokenField_thc0006 {
        let inner_value = self.read_u8::<false>(0, 0, 7).unwrap();
        TokenField_thc0006(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0007(&self) -> TokenField_thc0007 {
        let inner_value = self.read_u8::<false>(0, 0, 8).unwrap();
        TokenField_thc0007(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0011(&self) -> TokenField_thc0011 {
        let inner_value = self.read_u16::<false>(0, 0, 12).unwrap();
        TokenField_thc0011(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0107(&self) -> TokenField_thc0107 {
        let inner_value = self.read_u8::<false>(0, 1, 7).unwrap();
        TokenField_thc0107(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0207(&self) -> TokenField_thc0207 {
        let inner_value = self.read_u8::<false>(0, 2, 6).unwrap();
        TokenField_thc0207(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0307(&self) -> TokenField_thc0307 {
        let inner_value = self.read_u8::<false>(0, 3, 5).unwrap();
        TokenField_thc0307(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0407(&self) -> TokenField_thc0407 {
        let inner_value = self.read_u8::<false>(0, 4, 4).unwrap();
        TokenField_thc0407(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0405(&self) -> TokenField_thc0405 {
        let inner_value = self.read_u8::<false>(0, 4, 2).unwrap();
        TokenField_thc0405(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0409(&self) -> TokenField_thc0409 {
        let inner_value = self.read_u16::<false>(0, 4, 6).unwrap();
        TokenField_thc0409(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0506(&self) -> TokenField_thc0506 {
        let inner_value = self.read_u8::<false>(0, 5, 2).unwrap();
        TokenField_thc0506(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0507(&self) -> TokenField_thc0507 {
        let inner_value = self.read_u8::<false>(0, 5, 3).unwrap();
        TokenField_thc0507(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0607(&self) -> TokenField_thc0607 {
        let inner_value = self.read_u8::<false>(0, 6, 2).unwrap();
        TokenField_thc0607(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0810(&self) -> TokenField_thc0810 {
        let inner_value = self.read_u8::<false>(1, 0, 3).unwrap();
        TokenField_thc0810(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0811(&self) -> TokenField_thc0811 {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_thc0811(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0910(&self) -> TokenField_thc0910 {
        let inner_value = self.read_u8::<false>(1, 1, 2).unwrap();
        TokenField_thc0910(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc1414(&self) -> TokenField_thc1414 {
        let inner_value = self.read_u8::<false>(1, 6, 1).unwrap();
        TokenField_thc1414(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc1313(&self) -> TokenField_thc1313 {
        let inner_value = self.read_u8::<false>(1, 5, 1).unwrap();
        TokenField_thc1313(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc1212(&self) -> TokenField_thc1212 {
        let inner_value = self.read_u8::<false>(1, 4, 1).unwrap();
        TokenField_thc1212(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc1214(&self) -> TokenField_thc1214 {
        let inner_value = self.read_u8::<false>(1, 4, 3).unwrap();
        TokenField_thc1214(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc1111(&self) -> TokenField_thc1111 {
        let inner_value = self.read_u8::<false>(1, 3, 1).unwrap();
        TokenField_thc1111(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc1010(&self) -> TokenField_thc1010 {
        let inner_value = self.read_u8::<false>(1, 2, 1).unwrap();
        TokenField_thc1010(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0909(&self) -> TokenField_thc0909 {
        let inner_value = self.read_u8::<false>(1, 1, 1).unwrap();
        TokenField_thc0909(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0808(&self) -> TokenField_thc0808 {
        let inner_value = self.read_u8::<false>(1, 0, 1).unwrap();
        TokenField_thc0808(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0707(&self) -> TokenField_thc0707 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_thc0707(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0606(&self) -> TokenField_thc0606 {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_thc0606(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0505(&self) -> TokenField_thc0505 {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_thc0505(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0404(&self) -> TokenField_thc0404 {
        let inner_value = self.read_u8::<false>(0, 4, 1).unwrap();
        TokenField_thc0404(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0303(&self) -> TokenField_thc0303 {
        let inner_value = self.read_u8::<false>(0, 3, 1).unwrap();
        TokenField_thc0303(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0202(&self) -> TokenField_thc0202 {
        let inner_value = self.read_u8::<false>(0, 2, 1).unwrap();
        TokenField_thc0202(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0101(&self) -> TokenField_thc0101 {
        let inner_value = self.read_u8::<false>(0, 1, 1).unwrap();
        TokenField_thc0101(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0000(&self) -> TokenField_thc0000 {
        let inner_value = self.read_u8::<false>(0, 0, 1).unwrap();
        TokenField_thc0000(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0115(&self) -> TokenField_thc0115 {
        let inner_value = self.read_u16::<false>(0, 1, 15).unwrap();
        TokenField_thc0115(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0215(&self) -> TokenField_thc0215 {
        let inner_value = self.read_u16::<false>(0, 2, 14).unwrap();
        TokenField_thc0215(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0315(&self) -> TokenField_thc0315 {
        let inner_value = self.read_u16::<false>(0, 3, 13).unwrap();
        TokenField_thc0315(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0415(&self) -> TokenField_thc0415 {
        let inner_value = self.read_u16::<false>(0, 4, 12).unwrap();
        TokenField_thc0415(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0515(&self) -> TokenField_thc0515 {
        let inner_value = self.read_u16::<false>(0, 5, 11).unwrap();
        TokenField_thc0515(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0615(&self) -> TokenField_thc0615 {
        let inner_value = self.read_u16::<false>(0, 6, 10).unwrap();
        TokenField_thc0615(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0715(&self) -> TokenField_thc0715 {
        let inner_value = self.read_u16::<false>(0, 7, 9).unwrap();
        TokenField_thc0715(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0815(&self) -> TokenField_thc0815 {
        let inner_value = self.read_u8::<false>(1, 0, 8).unwrap();
        TokenField_thc0815(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc0915(&self) -> TokenField_thc0915 {
        let inner_value = self.read_u8::<false>(1, 1, 7).unwrap();
        TokenField_thc0915(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc1015(&self) -> TokenField_thc1015 {
        let inner_value = self.read_u8::<false>(1, 2, 6).unwrap();
        TokenField_thc1015(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc1112(&self) -> TokenField_thc1112 {
        let inner_value = self.read_u8::<false>(1, 3, 2).unwrap();
        TokenField_thc1112(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc1115(&self) -> TokenField_thc1115 {
        let inner_value = self.read_u8::<false>(1, 3, 5).unwrap();
        TokenField_thc1115(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc1215(&self) -> TokenField_thc1215 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_thc1215(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc1315(&self) -> TokenField_thc1315 {
        let inner_value = self.read_u8::<false>(1, 5, 3).unwrap();
        TokenField_thc1315(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc1415(&self) -> TokenField_thc1415 {
        let inner_value = self.read_u8::<false>(1, 6, 2).unwrap();
        TokenField_thc1415(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthc1515(&self) -> TokenField_thc1515 {
        let inner_value = self.read_u8::<false>(1, 7, 1).unwrap();
        TokenField_thc1515(u8::try_from(inner_value).unwrap())
    }
}
#[derive(Clone, Copy, Debug)]
pub enum Register {
    r0,
    r1,
    r2,
    r3,
    r4,
    r5,
    r6,
    r7,
    r8,
    r9,
    r10,
    r11,
    r12,
    sp,
    lr,
    pc,
    NG,
    ZR,
    CY,
    OV,
    tmpNG,
    tmpZR,
    tmpCY,
    tmpOV,
    shift_carry,
    TB,
    Q,
    GE1,
    GE2,
    GE3,
    GE4,
    cpsr,
    spsr,
    mult_addr,
    r14_svc,
    r13_svc,
    spsr_svc,
    mult_dat8,
    mult_dat16,
    fpsr,
    ISAModeSwitch,
    fp0,
    fp1,
    fp2,
    fp3,
    fp4,
    fp5,
    fp6,
    fp7,
    cr0,
    cr1,
    cr2,
    cr3,
    cr4,
    cr5,
    cr6,
    cr7,
    cr8,
    cr9,
    cr10,
    cr11,
    cr12,
    cr13,
    cr14,
    cr15,
    contextreg,
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::r0 => write!(f, "r0"),
            Self::r1 => write!(f, "r1"),
            Self::r2 => write!(f, "r2"),
            Self::r3 => write!(f, "r3"),
            Self::r4 => write!(f, "r4"),
            Self::r5 => write!(f, "r5"),
            Self::r6 => write!(f, "r6"),
            Self::r7 => write!(f, "r7"),
            Self::r8 => write!(f, "r8"),
            Self::r9 => write!(f, "r9"),
            Self::r10 => write!(f, "r10"),
            Self::r11 => write!(f, "r11"),
            Self::r12 => write!(f, "r12"),
            Self::sp => write!(f, "sp"),
            Self::lr => write!(f, "lr"),
            Self::pc => write!(f, "pc"),
            Self::NG => write!(f, "NG"),
            Self::ZR => write!(f, "ZR"),
            Self::CY => write!(f, "CY"),
            Self::OV => write!(f, "OV"),
            Self::tmpNG => write!(f, "tmpNG"),
            Self::tmpZR => write!(f, "tmpZR"),
            Self::tmpCY => write!(f, "tmpCY"),
            Self::tmpOV => write!(f, "tmpOV"),
            Self::shift_carry => write!(f, "shift_carry"),
            Self::TB => write!(f, "TB"),
            Self::Q => write!(f, "Q"),
            Self::GE1 => write!(f, "GE1"),
            Self::GE2 => write!(f, "GE2"),
            Self::GE3 => write!(f, "GE3"),
            Self::GE4 => write!(f, "GE4"),
            Self::cpsr => write!(f, "cpsr"),
            Self::spsr => write!(f, "spsr"),
            Self::mult_addr => write!(f, "mult_addr"),
            Self::r14_svc => write!(f, "r14_svc"),
            Self::r13_svc => write!(f, "r13_svc"),
            Self::spsr_svc => write!(f, "spsr_svc"),
            Self::mult_dat8 => write!(f, "mult_dat8"),
            Self::mult_dat16 => write!(f, "mult_dat16"),
            Self::fpsr => write!(f, "fpsr"),
            Self::ISAModeSwitch => write!(f, "ISAModeSwitch"),
            Self::fp0 => write!(f, "fp0"),
            Self::fp1 => write!(f, "fp1"),
            Self::fp2 => write!(f, "fp2"),
            Self::fp3 => write!(f, "fp3"),
            Self::fp4 => write!(f, "fp4"),
            Self::fp5 => write!(f, "fp5"),
            Self::fp6 => write!(f, "fp6"),
            Self::fp7 => write!(f, "fp7"),
            Self::cr0 => write!(f, "cr0"),
            Self::cr1 => write!(f, "cr1"),
            Self::cr2 => write!(f, "cr2"),
            Self::cr3 => write!(f, "cr3"),
            Self::cr4 => write!(f, "cr4"),
            Self::cr5 => write!(f, "cr5"),
            Self::cr6 => write!(f, "cr6"),
            Self::cr7 => write!(f, "cr7"),
            Self::cr8 => write!(f, "cr8"),
            Self::cr9 => write!(f, "cr9"),
            Self::cr10 => write!(f, "cr10"),
            Self::cr11 => write!(f, "cr11"),
            Self::cr12 => write!(f, "cr12"),
            Self::cr13 => write!(f, "cr13"),
            Self::cr14 => write!(f, "cr14"),
            Self::cr15 => write!(f, "cr15"),
            Self::contextreg => write!(f, "contextreg"),
        }
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, i128),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(hex, value) => match (*hex, value.is_negative()) {
                (true, true) => write!(f, "-0x{:x}", value.abs()),
                (true, false) => write!(f, "0x{:x}", value),
                (false, _) => value.fmt(f),
            },
        }
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2269:1, end:2269:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar0 {
    Addr24: TableAddr24,
}
impl bl_instructionVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("bl"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldL24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldimmed24().disassembly() != 16777215i128 {
            return None;
        }
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3494:1, end:3494:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar1 {}
impl mov_instructionVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_LRset(
            Some(inst_next),
            context.register().read_LRset_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mov"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc0031().disassembly() != 3785416719i128 {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_LRset_disassembly(tmp)
            .unwrap();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3563:1, end:3563:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar2 {
    rm: Tablerm,
}
impl mov_instructionVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_LRset(
            Some(inst_next),
            context.register().read_LRset_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("mov"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS20().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRm2().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 14i128 {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_LRset_disassembly(tmp)
            .unwrap();
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3011:1, end:3011:2))"]
#[derive(Clone, Debug)]
struct nop_instructionVar3 {
    ItCond: TableItCond,
}
impl nop_instructionVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("nop")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(".w")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop0().disassembly() != 62383i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop0().disassembly() != 32768i128 {
            return None;
        }
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1572:1, end:1572:2))"]
#[derive(Clone, Debug)]
struct hlt_instructionVar4 {
    immed12_4: Tableimmed12_4,
}
impl hlt_instructionVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("hlt"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.immed12_4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 16i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 7i128 {
            return None;
        }
        let immed12_4 = if let Some((len, table)) = Tableimmed12_4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed12_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1577:1, end:1577:2))"]
#[derive(Clone, Debug)]
struct bkpt_instructionVar5 {
    immed12_4: Tableimmed12_4,
}
impl bkpt_instructionVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("bkpt"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.immed12_4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 18i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 7i128 {
            return None;
        }
        let immed12_4 = if let Some((len, table)) = Tableimmed12_4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed12_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1582:1, end:1582:2))"]
#[derive(Clone, Debug)]
struct hvc_instructionVar6 {
    immed12_4: Tableimmed12_4,
}
impl hvc_instructionVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("hvc"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.immed12_4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 20i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 7i128 {
            return None;
        }
        let immed12_4 = if let Some((len, table)) = Tableimmed12_4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed12_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1635:1, end:1635:2))"]
#[derive(Clone, Debug)]
struct udf_instructionVar7 {
    immed12_4: Tableimmed12_4,
}
impl udf_instructionVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("udf"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.immed12_4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 127i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 15i128 {
            return None;
        }
        let immed12_4 = if let Some((len, table)) = Tableimmed12_4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed12_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2276:1, end:2276:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar8 {
    COND: TableCOND,
    Addr24: TableAddr24,
}
impl bl_instructionVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldL24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldimmed24().disassembly() != 16777215i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2369:1, end:2369:2))"]
#[derive(Clone, Debug)]
struct bx_instructionVar9 {
    COND: TableCOND,
    rm: Tablerm,
}
impl bx_instructionVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bx")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_REToverride_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_LRset_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 18i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRm().disassembly() != 14i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3569:1, end:3569:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar10 {
    COND: TableCOND,
}
impl mov_instructionVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS20().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRm().disassembly() != 14i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2345:1, end:2345:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar11 {
    COND: TableCOND,
    rm: Tablerm,
}
impl blx_instructionVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blx")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 18i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 3i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2355:1, end:2355:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar12 {
    COND: TableCOND,
    rm: Tablerm,
}
impl blx_instructionVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blx")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_CALLoverride_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 18i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 3i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2377:1, end:2377:2))"]
#[derive(Clone, Debug)]
struct bx_instructionVar13 {
    COND: TableCOND,
    rm: Tablerm,
}
impl bx_instructionVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bx")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_REToverride_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_LRset_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 18i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm = token_parser.TokenFieldRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2386:1, end:2386:2))"]
#[derive(Clone, Debug)]
struct bx_instructionVar14 {
    COND: TableCOND,
    rm: Tablerm,
}
impl bx_instructionVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bx")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_REToverride_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_LRset_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 18i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm = token_parser.TokenFieldRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2394:1, end:2394:2))"]
#[derive(Clone, Debug)]
struct bx_instructionVar15 {
    COND: TableCOND,
    rm: Tablerm,
}
impl bx_instructionVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bx")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_REToverride_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 18i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2936:1, end:2936:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar16 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2945:1, end:2945:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar17 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2954:1, end:2954:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar18 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2963:1, end:2963:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar19 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2972:1, end:2972:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar20 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2981:1, end:2981:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar21 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2990:1, end:2990:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar22 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2999:1, end:2999:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar23 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3008:1, end:3008:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar24 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3017:1, end:3017:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar25 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3026:1, end:3026:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar26 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3035:1, end:3035:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar27 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3044:1, end:3044:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar28 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3053:1, end:3053:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar29 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3062:1, end:3062:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar30 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3071:1, end:3071:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar31 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3080:1, end:3080:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar32 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3089:1, end:3089:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar33 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3098:1, end:3098:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar34 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3107:1, end:3107:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar35 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3116:1, end:3116:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar36 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3125:1, end:3125:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar37 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3134:1, end:3134:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar38 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3143:1, end:3143:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar39 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3152:1, end:3152:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar40 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3161:1, end:3161:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar41 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3170:1, end:3170:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar42 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3179:1, end:3179:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar43 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3188:1, end:3188:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar44 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3197:1, end:3197:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar45 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3206:1, end:3206:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar46 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3215:1, end:3215:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar47 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3224:1, end:3224:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar48 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3233:1, end:3233:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar49 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3242:1, end:3242:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar50 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3251:1, end:3251:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar51 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3260:1, end:3260:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar52 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3269:1, end:3269:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar53 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3278:1, end:3278:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar54 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3287:1, end:3287:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar55 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3296:1, end:3296:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar56 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3607:1, end:3607:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar57 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3617:1, end:3617:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar58 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3627:1, end:3627:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar59 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3637:1, end:3637:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar60 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3647:1, end:3647:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar61 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3657:1, end:3657:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar62 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3667:1, end:3667:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar63 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3677:1, end:3677:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar64 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar64 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3687:1, end:3687:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar65 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar65 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3697:1, end:3697:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar66 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar66 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3707:1, end:3707:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar67 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar67 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3717:1, end:3717:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar68 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar68 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3727:1, end:3727:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar69 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar69 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3737:1, end:3737:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar70 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar70 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3747:1, end:3747:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar71 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar71 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3757:1, end:3757:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar72 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar72 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3767:1, end:3767:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar73 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar73 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3777:1, end:3777:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar74 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar74 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3787:1, end:3787:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar75 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar75 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3797:1, end:3797:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar76 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar76 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3807:1, end:3807:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar77 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar77 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3817:1, end:3817:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar78 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar78 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3827:1, end:3827:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar79 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar79 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3837:1, end:3837:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar80 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar80 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3847:1, end:3847:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar81 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar81 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3857:1, end:3857:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar82 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar82 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3867:1, end:3867:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar83 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar83 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3877:1, end:3877:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar84 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar84 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3887:1, end:3887:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar85 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar85 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3897:1, end:3897:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar86 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar86 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3907:1, end:3907:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar87 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar87 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3917:1, end:3917:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar88 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar88 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3927:1, end:3927:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar89 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar89 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3937:1, end:3937:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar90 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar90 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3947:1, end:3947:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar91 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar91 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3957:1, end:3957:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar92 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar92 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3967:1, end:3967:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar93 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar93 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3977:1, end:3977:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar94 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar94 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3987:1, end:3987:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar95 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar95 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3997:1, end:3997:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar96 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar96 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4007:1, end:4007:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar97 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar97 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4139:1, end:4139:2))"]
#[derive(Clone, Debug)]
struct mrs_instructionVar98 {
    Rd: TokenField_Rd,
    COND: TableCOND,
}
impl mrs_instructionVar98 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrs")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::cpsr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 16i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldoffset_12().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4146:1, end:4146:2))"]
#[derive(Clone, Debug)]
struct mrs_instructionVar99 {
    Rd: TokenField_Rd,
    COND: TableCOND,
}
impl mrs_instructionVar99 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrs")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::spsr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 20i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldoffset_12().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2483:1, end:2483:2))"]
#[derive(Clone, Debug)]
struct clz_instructionVar100 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    rm: Tablerm,
}
impl clz_instructionVar100 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("clz")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 22i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rm, Rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4160:1, end:4160:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar101 {
    COND: TableCOND,
    cpsrmask: Tablecpsrmask,
    rm: Tablerm,
}
impl msr_instructionVar101 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("msr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cpsrmask.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 18i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpsrmask = if let Some((len, table)) = Tablecpsrmask::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, cpsrmask, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4182:1, end:4182:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar102 {
    COND: TableCOND,
    spsrmask: Tablespsrmask,
    rm: Tablerm,
}
impl msr_instructionVar102 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("msr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.spsrmask.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 22i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let spsrmask = if let Some((len, table)) = Tablespsrmask::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, spsrmask, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4363:1, end:4363:2))"]
#[derive(Clone, Debug)]
struct qadd_instructionVar103 {
    Rd: TokenField_Rd,
    Rm: TokenField_Rm,
    Rn: TokenField_Rn,
    COND: TableCOND,
}
impl qadd_instructionVar103 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qadd")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rm.display(),
            DisplayElement::Literal(","),
            self.Rn.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 16i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 5i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn = token_parser.TokenFieldRn();
        let Rd = token_parser.TokenFieldRd();
        let Rm = token_parser.TokenFieldRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rn, Rd, Rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4431:1, end:4431:2))"]
#[derive(Clone, Debug)]
struct qdadd_instructionVar104 {
    Rd: TokenField_Rd,
    Rm: TokenField_Rm,
    Rn: TokenField_Rn,
    COND: TableCOND,
}
impl qdadd_instructionVar104 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qdadd")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rm.display(),
            DisplayElement::Literal(","),
            self.Rn.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 20i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 5i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn = token_parser.TokenFieldRn();
        let Rd = token_parser.TokenFieldRd();
        let Rm = token_parser.TokenFieldRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rn, Rd, Rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4443:1, end:4443:2))"]
#[derive(Clone, Debug)]
struct qdsub_instructionVar105 {
    Rd: TokenField_Rd,
    Rm: TokenField_Rm,
    Rn: TokenField_Rn,
    COND: TableCOND,
}
impl qdsub_instructionVar105 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qdsub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rm.display(),
            DisplayElement::Literal(","),
            self.Rn.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 22i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 5i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn = token_parser.TokenFieldRn();
        let Rd = token_parser.TokenFieldRd();
        let Rm = token_parser.TokenFieldRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rn, Rd, Rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4478:1, end:4478:2))"]
#[derive(Clone, Debug)]
struct qsub_instructionVar106 {
    Rd: TokenField_Rd,
    Rm: TokenField_Rm,
    Rn: TokenField_Rn,
    COND: TableCOND,
}
impl qsub_instructionVar106 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qsub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rm.display(),
            DisplayElement::Literal(","),
            self.Rn.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 18i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 5i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn = token_parser.TokenFieldRn();
        let Rd = token_parser.TokenFieldRd();
        let Rm = token_parser.TokenFieldRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rn, Rd, Rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5687:1, end:5687:2))"]
#[derive(Clone, Debug)]
struct swp_instructionVar107 {
    Rd: TokenField_Rd,
    Rm: TokenField_Rm,
    Rn: TokenField_Rn,
    COND: TableCOND,
}
impl swp_instructionVar107 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("swp")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rm.display(),
            DisplayElement::Literal(","),
            self.Rn.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 16i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn = token_parser.TokenFieldRn();
        let Rd = token_parser.TokenFieldRd();
        let Rm = token_parser.TokenFieldRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rn, Rd, Rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5695:1, end:5695:2))"]
#[derive(Clone, Debug)]
struct swpb_instructionVar108 {
    Rd: TokenField_Rd,
    Rm: TokenField_Rm,
    Rn: TokenField_Rn,
    COND: TableCOND,
}
impl swpb_instructionVar108 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("swpb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rm.display(),
            DisplayElement::Literal(","),
            self.Rn.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 20i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn = token_parser.TokenFieldRn();
        let Rd = token_parser.TokenFieldRd();
        let Rm = token_parser.TokenFieldRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rn, Rd, Rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1598:1, end:1598:2))"]
#[derive(Clone, Debug)]
struct smc_instructionVar109 {
    immed4: TokenField_immed4,
    COND: TableCOND,
}
impl smc_instructionVar109 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("smc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(" "), self.immed4.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 22i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 7i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed4 = token_parser.TokenFieldimmed4();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, immed4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1682:1, end:1682:2))"]
#[derive(Clone, Debug)]
struct pld_instructionVar110 {
    addrmode2: Tableaddrmode2,
}
impl pld_instructionVar110 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("pld"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2424().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2022().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        let mut sub_pattern_c104 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c104 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c104(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c104(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1676:1, end:1676:2))"]
#[derive(Clone, Debug)]
struct pld_instructionVar111 {
    addrmode2: Tableaddrmode2,
}
impl pld_instructionVar111 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("pld"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2424().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2022().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        let mut sub_pattern_c92 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c92 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c92(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c92(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1875:1, end:1875:2))"]
#[derive(Clone, Debug)]
struct stc2_instructionVar112 {
    cpn: TokenField_cpn,
    CRd: TokenField_CRd,
    addrmode5: Tableaddrmode5,
}
impl stc2_instructionVar112 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("stc2"),
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldN22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let addrmode5 = if let Some((len, table)) = Tableaddrmode5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpn = token_parser.TokenFieldcpn();
        let CRd = token_parser.TokenFieldCRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1881:1, end:1881:2))"]
#[derive(Clone, Debug)]
struct stc2l_instructionVar113 {
    cpn: TokenField_cpn,
    CRd: TokenField_CRd,
    addrmode5: Tableaddrmode5,
}
impl stc2l_instructionVar113 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("stc2l"),
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldN22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let addrmode5 = if let Some((len, table)) = Tableaddrmode5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpn = token_parser.TokenFieldcpn();
        let CRd = token_parser.TokenFieldCRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5308:1, end:5308:2))"]
#[derive(Clone, Debug)]
struct smulw_instructionVar114 {
    smRd: TokenField_smRd,
    smRn: TokenField_smRn,
    smRm: TokenField_smRm,
    COND: TableCOND,
    YBIT: TableYBIT,
}
impl smulw_instructionVar114 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smulw")];
        display.extend_from_slice(&extend);
        self.YBIT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.smRd.display(),
            DisplayElement::Literal(","),
            self.smRn.display(),
            DisplayElement::Literal(","),
            self.smRm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 18i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldx().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let YBIT = if let Some((len, table)) =
            TableYBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let smRd = token_parser.TokenFieldsmRd();
        let smRn = token_parser.TokenFieldsmRn();
        let smRm = token_parser.TokenFieldsmRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                YBIT,
                smRd,
                smRn,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5285:1, end:5285:2))"]
#[derive(Clone, Debug)]
struct smul_instructionVar115 {
    smRd: TokenField_smRd,
    smRn: TokenField_smRn,
    smRm: TokenField_smRm,
    COND: TableCOND,
    XBIT: TableXBIT,
    YBIT: TableYBIT,
}
impl smul_instructionVar115 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smul")];
        display.extend_from_slice(&extend);
        self.XBIT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.YBIT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.smRd.display(),
            DisplayElement::Literal(","),
            self.smRn.display(),
            DisplayElement::Literal(","),
            self.smRm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 22i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let XBIT = if let Some((len, table)) =
            TableXBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let YBIT = if let Some((len, table)) =
            TableYBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let smRd = token_parser.TokenFieldsmRd();
        let smRm = token_parser.TokenFieldsmRm();
        let smRn = token_parser.TokenFieldsmRn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                XBIT,
                YBIT,
                smRd,
                smRm,
                smRn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4152:1, end:4152:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar116 {
    COND: TableCOND,
    cpsrmask: Tablecpsrmask,
    shift1: Tableshift1,
}
impl msr_instructionVar116 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("msr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cpsrmask.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 50i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpsrmask = if let Some((len, table)) = Tablecpsrmask::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                cpsrmask,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4174:1, end:4174:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar117 {
    COND: TableCOND,
    spsrmask: Tablespsrmask,
    shift1: Tableshift1,
}
impl msr_instructionVar117 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("msr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.spsrmask.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 54i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let spsrmask = if let Some((len, table)) = Tablespsrmask::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                spsrmask,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2492:1, end:2492:2))"]
#[derive(Clone, Debug)]
struct cmn_instructionVar118 {
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl cmn_instructionVar118 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 23i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2503:1, end:2503:2))"]
#[derive(Clone, Debug)]
struct cmn_instructionVar119 {
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
}
impl cmn_instructionVar119 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 23i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2514:1, end:2514:2))"]
#[derive(Clone, Debug)]
struct cmn_instructionVar120 {
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
}
impl cmn_instructionVar120 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 23i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2525:1, end:2525:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar121 {
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl cmp_instructionVar121 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 21i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2536:1, end:2536:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar122 {
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
}
impl cmp_instructionVar122 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 21i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2547:1, end:2547:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar123 {
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
}
impl cmp_instructionVar123 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 21i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5624:1, end:5624:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar124 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl sub_instructionVar124 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldRn().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldimmed().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldrotate().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3512:1, end:3512:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar125 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
}
impl mov_instructionVar125 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3525:1, end:3525:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar126 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
}
impl mov_instructionVar126 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3537:1, end:3537:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar127 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
}
impl mov_instructionVar127 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_LRset_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3550:1, end:3550:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar128 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
}
impl mov_instructionVar128 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4068:1, end:4068:2))"]
#[derive(Clone, Debug)]
struct srsdb_instructionVar129 {
    ItCond: TableItCond,
    thSRSMode: TablethSRSMode,
}
impl srsdb_instructionVar129 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("srsdb")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal("!,"),
        ];
        display.extend_from_slice(&extend);
        self.thSRSMode.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 928i128 {
            return None;
        }
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0004().disassembly() != 13i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop8().disassembly() != 192i128 {
            return None;
        }
        if token_parser.TokenFieldsop0507().disassembly() != 0i128 {
            return None;
        }
        let thSRSMode = if let Some((len, table)) = TablethSRSMode::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, thSRSMode }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4079:1, end:4079:2))"]
#[derive(Clone, Debug)]
struct srsdb_instructionVar130 {
    ItCond: TableItCond,
    thSRSMode: TablethSRSMode,
}
impl srsdb_instructionVar130 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("srsdb")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thSRSMode.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 928i128 {
            return None;
        }
        if token_parser.TokenFieldthc0505().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldthc0004().disassembly() != 13i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop8().disassembly() != 192i128 {
            return None;
        }
        if token_parser.TokenFieldsop0507().disassembly() != 0i128 {
            return None;
        }
        let thSRSMode = if let Some((len, table)) = TablethSRSMode::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, thSRSMode }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4089:1, end:4089:2))"]
#[derive(Clone, Debug)]
struct srsib_instructionVar131 {
    ItCond: TableItCond,
    thSRSMode: TablethSRSMode,
}
impl srsib_instructionVar131 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("srsib")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal("!,"),
        ];
        display.extend_from_slice(&extend);
        self.thSRSMode.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 934i128 {
            return None;
        }
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0004().disassembly() != 13i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop8().disassembly() != 192i128 {
            return None;
        }
        if token_parser.TokenFieldsop0507().disassembly() != 0i128 {
            return None;
        }
        let thSRSMode = if let Some((len, table)) = TablethSRSMode::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, thSRSMode }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4100:1, end:4100:2))"]
#[derive(Clone, Debug)]
struct srsia_instructionVar132 {
    ItCond: TableItCond,
    thSRSMode: TablethSRSMode,
}
impl srsia_instructionVar132 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("srsia")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thSRSMode.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 934i128 {
            return None;
        }
        if token_parser.TokenFieldthc0505().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldthc0004().disassembly() != 13i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop8().disassembly() != 192i128 {
            return None;
        }
        if token_parser.TokenFieldsop0507().disassembly() != 0i128 {
            return None;
        }
        let thSRSMode = if let Some((len, table)) = TablethSRSMode::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, thSRSMode }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4189:1, end:4189:2))"]
#[derive(Clone, Debug)]
struct mul_instructionVar133 {
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
    rn: Tablern,
    rs: Tablers,
    rm: Tablerm,
}
impl mul_instructionVar133 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mul")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                rn,
                rs,
                rm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4229:1, end:4229:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar134 {
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
    shift1: Tableshift1,
}
impl mvn_instructionVar134 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4240:1, end:4240:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar135 {
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
    shift2: Tableshift2,
}
impl mvn_instructionVar135 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4251:1, end:4251:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar136 {
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
    shift3: Tableshift3,
}
impl mvn_instructionVar136 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5758:1, end:5758:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar137 {
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl teq_instructionVar137 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 19i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5769:1, end:5769:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar138 {
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
}
impl teq_instructionVar138 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 19i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5780:1, end:5780:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar139 {
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
}
impl teq_instructionVar139 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 19i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5791:1, end:5791:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar140 {
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl teq_instructionVar140 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("p"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 19i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5802:1, end:5802:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar141 {
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
}
impl teq_instructionVar141 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("p"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 19i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5813:1, end:5813:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar142 {
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
}
impl teq_instructionVar142 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("p"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 19i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5825:1, end:5825:2))"]
#[derive(Clone, Debug)]
struct tst_instructionVar143 {
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl tst_instructionVar143 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("tst")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 17i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5836:1, end:5836:2))"]
#[derive(Clone, Debug)]
struct tst_instructionVar144 {
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
}
impl tst_instructionVar144 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("tst")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 17i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5847:1, end:5847:2))"]
#[derive(Clone, Debug)]
struct tst_instructionVar145 {
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
}
impl tst_instructionVar145 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("tst")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 17i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1945:1, end:1945:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar146 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl adc_instructionVar146 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1958:1, end:1958:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar147 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl adc_instructionVar147 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1971:1, end:1971:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar148 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl adc_instructionVar148 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2048:1, end:2048:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar149 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl add_instructionVar149 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2061:1, end:2061:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar150 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl add_instructionVar150 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2074:1, end:2074:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar151 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl add_instructionVar151 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2120:1, end:2120:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar152 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl and_instructionVar152 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2133:1, end:2133:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar153 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl and_instructionVar153 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2146:1, end:2146:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar154 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl and_instructionVar154 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2229:1, end:2229:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar155 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl bic_instructionVar155 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2242:1, end:2242:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar156 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl bic_instructionVar156 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2255:1, end:2255:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar157 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl bic_instructionVar157 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2644:1, end:2644:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar158 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl eor_instructionVar158 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2657:1, end:2657:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar159 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl eor_instructionVar159 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2670:1, end:2670:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar160 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl eor_instructionVar160 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3305:1, end:3305:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar161 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar161 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3315:1, end:3315:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar162 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar162 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3325:1, end:3325:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar163 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar163 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3335:1, end:3335:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar164 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar164 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3345:1, end:3345:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar165 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar165 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3355:1, end:3355:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar166 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar166 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3365:1, end:3365:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar167 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar167 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3375:1, end:3375:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar168 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar168 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4017:1, end:4017:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar169 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar169 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4028:1, end:4028:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar170 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar170 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4039:1, end:4039:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar171 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar171 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4050:1, end:4050:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar172 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar172 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4061:1, end:4061:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar173 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar173 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4072:1, end:4072:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar174 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar174 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4083:1, end:4083:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar175 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar175 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4094:1, end:4094:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar176 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar176 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3385:1, end:3385:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar177 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar177 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CRm = token_parser.TokenFieldCRm();
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4105:1, end:4105:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar178 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar178 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CRm = token_parser.TokenFieldCRm();
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5134:1, end:5134:2))"]
#[derive(Clone, Debug)]
struct smlaw_instructionVar179 {
    smRd: TokenField_smRd,
    smRn: TokenField_smRn,
    smRm: TokenField_smRm,
    smRa: TokenField_smRa,
    COND: TableCOND,
    YBIT: TableYBIT,
}
impl smlaw_instructionVar179 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlaw")];
        display.extend_from_slice(&extend);
        self.YBIT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.smRd.display(),
            DisplayElement::Literal(","),
            self.smRn.display(),
            DisplayElement::Literal(","),
            self.smRm.display(),
            DisplayElement::Literal(","),
            self.smRa.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 18i128 {
            return None;
        }
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldx().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let YBIT = if let Some((len, table)) =
            TableYBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let smRd = token_parser.TokenFieldsmRd();
        let smRn = token_parser.TokenFieldsmRn();
        let smRm = token_parser.TokenFieldsmRm();
        let smRa = token_parser.TokenFieldsmRa();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                YBIT,
                smRd,
                smRn,
                smRm,
                smRa,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5027:1, end:5027:2))"]
#[derive(Clone, Debug)]
struct smla_instructionVar180 {
    smRd: TokenField_smRd,
    smRn: TokenField_smRn,
    smRm: TokenField_smRm,
    smRa: TokenField_smRa,
    COND: TableCOND,
    XBIT: TableXBIT,
    YBIT: TableYBIT,
}
impl smla_instructionVar180 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smla")];
        display.extend_from_slice(&extend);
        self.XBIT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.YBIT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.smRd.display(),
            DisplayElement::Literal(","),
            self.smRn.display(),
            DisplayElement::Literal(","),
            self.smRm.display(),
            DisplayElement::Literal(","),
            self.smRa.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 16i128 {
            return None;
        }
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let XBIT = if let Some((len, table)) =
            TableXBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let YBIT = if let Some((len, table)) =
            TableYBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let smRd = token_parser.TokenFieldsmRd();
        let smRn = token_parser.TokenFieldsmRn();
        let smRm = token_parser.TokenFieldsmRm();
        let smRa = token_parser.TokenFieldsmRa();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                XBIT,
                YBIT,
                smRd,
                smRn,
                smRm,
                smRa,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5088:1, end:5088:2))"]
#[derive(Clone, Debug)]
struct smlal_instructionVar181 {
    RdLo: TokenField_RdLo,
    RdHi: TokenField_RdHi,
    smRn: TokenField_smRn,
    smRm: TokenField_smRm,
    COND: TableCOND,
    XBIT: TableXBIT,
    YBIT: TableYBIT,
}
impl smlal_instructionVar181 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlal")];
        display.extend_from_slice(&extend);
        self.XBIT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.YBIT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.RdLo.display(),
            DisplayElement::Literal(","),
            self.RdHi.display(),
            DisplayElement::Literal(","),
            self.smRn.display(),
            DisplayElement::Literal(","),
            self.smRm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 20i128 {
            return None;
        }
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let XBIT = if let Some((len, table)) =
            TableXBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let YBIT = if let Some((len, table)) =
            TableYBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RdLo = token_parser.TokenFieldRdLo();
        let RdHi = token_parser.TokenFieldRdHi();
        let smRm = token_parser.TokenFieldsmRm();
        let smRn = token_parser.TokenFieldsmRn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                XBIT,
                YBIT,
                RdLo,
                RdHi,
                smRm,
                smRn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3438:1, end:3438:2))"]
#[derive(Clone, Debug)]
struct mcrr_instructionVar182 {
    cpn: TokenField_cpn,
    opcode3: TokenField_opcode3,
    Rd: TokenField_Rd,
    Rn: TokenField_Rn,
    CRm: TokenField_CRm,
    COND: TableCOND,
}
impl mcrr_instructionVar182 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("mcrr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 10usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.opcode3.display(),
            DisplayElement::Literal(","),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rn.display(),
            DisplayElement::Literal(","),
            self.CRm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 196i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpn = token_parser.TokenFieldcpn();
        let opcode3 = token_parser.TokenFieldopcode3();
        let Rd = token_parser.TokenFieldRd();
        let Rn = token_parser.TokenFieldRn();
        let CRm = token_parser.TokenFieldCRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                cpn,
                opcode3,
                Rd,
                Rn,
                CRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3446:1, end:3446:2))"]
#[derive(Clone, Debug)]
struct mrrc_instructionVar183 {
    cpn: TokenField_cpn,
    opcode3: TokenField_opcode3,
    Rd: TokenField_Rd,
    Rn: TokenField_Rn,
    CRm: TokenField_CRm,
    COND: TableCOND,
}
impl mrrc_instructionVar183 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("mrrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 10usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.opcode3.display(),
            DisplayElement::Literal(","),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rn.display(),
            DisplayElement::Literal(","),
            self.CRm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 197i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpn = token_parser.TokenFieldcpn();
        let opcode3 = token_parser.TokenFieldopcode3();
        let Rd = token_parser.TokenFieldRd();
        let Rn = token_parser.TokenFieldRn();
        let CRm = token_parser.TokenFieldCRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                cpn,
                opcode3,
                Rd,
                Rn,
                CRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3457:1, end:3457:2))"]
#[derive(Clone, Debug)]
struct mla_instructionVar184 {
    Rn: TokenField_Rn,
    Rm: TokenField_Rm,
    Rs: TokenField_Rs,
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
}
impl mla_instructionVar184 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mla")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Rn.display(),
            DisplayElement::Literal(","),
            self.Rm.display(),
            DisplayElement::Literal(","),
            self.Rs.display(),
            DisplayElement::Literal(","),
            self.Rd.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn = token_parser.TokenFieldRn();
        let Rd = token_parser.TokenFieldRd();
        let Rs = token_parser.TokenFieldRs();
        let Rm = token_parser.TokenFieldRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                Rn,
                Rd,
                Rs,
                Rm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3474:1, end:3474:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar185 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
}
impl mov_instructionVar185 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3484:1, end:3484:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar186 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
}
impl mov_instructionVar186 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3502:1, end:3502:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar187 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
}
impl mov_instructionVar187 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4199:1, end:4199:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar188 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
}
impl mvn_instructionVar188 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4209:1, end:4209:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar189 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
}
impl mvn_instructionVar189 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4219:1, end:4219:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar190 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
}
impl mvn_instructionVar190 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4302:1, end:4302:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar191 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl orr_instructionVar191 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4315:1, end:4315:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar192 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl orr_instructionVar192 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4328:1, end:4328:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar193 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl orr_instructionVar193 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4644:1, end:4644:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar194 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl rsb_instructionVar194 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4657:1, end:4657:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar195 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl rsb_instructionVar195 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4670:1, end:4670:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar196 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl rsb_instructionVar196 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4716:1, end:4716:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar197 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl rsc_instructionVar197 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4729:1, end:4729:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar198 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl rsc_instructionVar198 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4742:1, end:4742:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar199 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl rsc_instructionVar199 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4848:1, end:4848:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar200 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl sbc_instructionVar200 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4861:1, end:4861:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar201 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl sbc_instructionVar201 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4874:1, end:4874:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar202 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl sbc_instructionVar202 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5073:1, end:5073:2))"]
#[derive(Clone, Debug)]
struct smlal_instructionVar203 {
    RdLo: TokenField_RdLo,
    RdHi: TokenField_RdHi,
    smRn: TokenField_smRn,
    smRm: TokenField_smRm,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
}
impl smlal_instructionVar203 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlal")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.RdLo.display(),
            DisplayElement::Literal(","),
            self.RdHi.display(),
            DisplayElement::Literal(","),
            self.smRn.display(),
            DisplayElement::Literal(","),
            self.smRm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RdLo = token_parser.TokenFieldRdLo();
        let RdHi = token_parser.TokenFieldRdHi();
        let smRn = token_parser.TokenFieldsmRn();
        let smRm = token_parser.TokenFieldsmRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                RdLo,
                RdHi,
                smRn,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5294:1, end:5294:2))"]
#[derive(Clone, Debug)]
struct smull_instructionVar204 {
    RdLo: TokenField_RdLo,
    RdHi: TokenField_RdHi,
    smRn: TokenField_smRn,
    smRm: TokenField_smRm,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
}
impl smull_instructionVar204 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smull")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.RdLo.display(),
            DisplayElement::Literal(","),
            self.RdHi.display(),
            DisplayElement::Literal(","),
            self.smRn.display(),
            DisplayElement::Literal(","),
            self.smRm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RdHi = token_parser.TokenFieldRdHi();
        let RdLo = token_parser.TokenFieldRdLo();
        let smRn = token_parser.TokenFieldsmRn();
        let smRm = token_parser.TokenFieldsmRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                RdHi,
                RdLo,
                smRn,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5609:1, end:5609:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar205 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl sub_instructionVar205 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5638:1, end:5638:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar206 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl sub_instructionVar206 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5653:1, end:5653:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar207 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl sub_instructionVar207 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:6080:1, end:6080:2))"]
#[derive(Clone, Debug)]
struct umlal_instructionVar208 {
    Rd: TokenField_Rd,
    Rn: TokenField_Rn,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
    rs: Tablers,
    rm: Tablerm,
}
impl umlal_instructionVar208 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("umlal")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rn.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn = token_parser.TokenFieldRn();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                rs,
                rm,
                Rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:6095:1, end:6095:2))"]
#[derive(Clone, Debug)]
struct umull_instructionVar209 {
    Rd: TokenField_Rd,
    Rn: TokenField_Rn,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
    rs: Tablers,
    rm: Tablerm,
}
impl umull_instructionVar209 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("umull")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rn.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn = token_parser.TokenFieldRn();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                rs,
                rm,
                Rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1912:1, end:1912:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar210 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl adc_instructionVar210 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1923:1, end:1923:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar211 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl adc_instructionVar211 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1934:1, end:1934:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar212 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl adc_instructionVar212 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2006:1, end:2006:2))"]
#[derive(Clone, Debug)]
struct adr_instructionVar213 {
    COND: TableCOND,
    ArmPCRelImmed12: TableArmPCRelImmed12,
}
impl adr_instructionVar213 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ArmPCRelImmed12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c74 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldc2024().disassembly() == 8i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldc2024().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c74(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ArmPCRelImmed12 = if let Some((len, table)) =
            TableArmPCRelImmed12::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                ArmPCRelImmed12,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2000:1, end:2000:2))"]
#[derive(Clone, Debug)]
struct adr_instructionVar214 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    ArmPCRelImmed12: TableArmPCRelImmed12,
}
impl adr_instructionVar214 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ArmPCRelImmed12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRn().disassembly() != 15i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c73 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldc2024().disassembly() == 8i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldc2024().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c73(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ArmPCRelImmed12 = if let Some((len, table)) =
            TableArmPCRelImmed12::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                ArmPCRelImmed12,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2015:1, end:2015:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar215 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl add_instructionVar215 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2026:1, end:2026:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar216 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl add_instructionVar216 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2037:1, end:2037:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar217 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl add_instructionVar217 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2087:1, end:2087:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar218 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl and_instructionVar218 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2098:1, end:2098:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar219 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl and_instructionVar219 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2109:1, end:2109:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar220 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl and_instructionVar220 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2923:1, end:2923:2))"]
#[derive(Clone, Debug)]
struct mcr2_instructionVar221 {
    cpn: TokenField_cpn,
    opc1: TokenField_opc1,
    Rd: TokenField_Rd,
    CRn: TokenField_CRn,
    CRm: TokenField_CRm,
    opc2: TokenField_opc2,
}
impl mcr2_instructionVar221 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 13usize] = [
            DisplayElement::Literal("mcr2"),
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.opc1.display(),
            DisplayElement::Literal(","),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.CRn.display(),
            DisplayElement::Literal(","),
            self.CRm.display(),
            DisplayElement::Literal(","),
            self.opc2.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        let opc1 = token_parser.TokenFieldopc1();
        let CRn = token_parser.TokenFieldCRn();
        let Rd = token_parser.TokenFieldRd();
        let cpn = token_parser.TokenFieldcpn();
        let opc2 = token_parser.TokenFieldopc2();
        let CRm = token_parser.TokenFieldCRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opc1,
                CRn,
                Rd,
                cpn,
                opc2,
                CRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3595:1, end:3595:2))"]
#[derive(Clone, Debug)]
struct mrc2_instructionVar222 {
    cpn: TokenField_cpn,
    opc1: TokenField_opc1,
    Rd: TokenField_Rd,
    CRn: TokenField_CRn,
    CRm: TokenField_CRm,
    opc2: TokenField_opc2,
}
impl mrc2_instructionVar222 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 13usize] = [
            DisplayElement::Literal("mrc2"),
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.opc1.display(),
            DisplayElement::Literal(","),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.CRn.display(),
            DisplayElement::Literal(","),
            self.CRm.display(),
            DisplayElement::Literal(","),
            self.opc2.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        let opc1 = token_parser.TokenFieldopc1();
        let CRn = token_parser.TokenFieldCRn();
        let Rd = token_parser.TokenFieldRd();
        let cpn = token_parser.TokenFieldcpn();
        let opc2 = token_parser.TokenFieldopc2();
        let CRm = token_parser.TokenFieldCRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opc1,
                CRn,
                Rd,
                cpn,
                opc2,
                CRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2454:1, end:2454:2))"]
#[derive(Clone, Debug)]
struct cdp2_instructionVar223 {
    cpn: TokenField_cpn,
    opcode1: TokenField_opcode1,
    CRd: TokenField_CRd,
    CRn: TokenField_CRn,
    CRm: TokenField_CRm,
    opcode2: TokenField_opcode2,
}
impl cdp2_instructionVar223 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 13usize] = [
            DisplayElement::Literal("cdp2"),
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.opcode1.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
            self.CRn.display(),
            DisplayElement::Literal(","),
            self.CRm.display(),
            DisplayElement::Literal(","),
            self.opcode2.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let opcode1 = token_parser.TokenFieldopcode1();
        let CRn = token_parser.TokenFieldCRn();
        let CRd = token_parser.TokenFieldCRd();
        let cpn = token_parser.TokenFieldcpn();
        let opcode2 = token_parser.TokenFieldopcode2();
        let CRm = token_parser.TokenFieldCRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opcode1,
                CRn,
                CRd,
                cpn,
                opcode2,
                CRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2161:1, end:2161:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar224 {
    Addr24: TableAddr24,
}
impl b_instructionVar224 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("b"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldL24().disassembly() != 0i128 {
            return None;
        }
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2284:1, end:2284:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar225 {
    Addr24: TableAddr24,
}
impl bl_instructionVar225 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("bl"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldL24().disassembly() != 1i128 {
            return None;
        }
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2310:1, end:2310:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar226 {
    HAddr24: TableHAddr24,
}
impl blx_instructionVar226 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("blx"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.HAddr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_CALLoverride_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldH24().disassembly() != 0i128 {
            return None;
        }
        let HAddr24 = if let Some((len, table)) = TableHAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { HAddr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2318:1, end:2318:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar227 {
    HAddr24: TableHAddr24,
}
impl blx_instructionVar227 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("blx"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.HAddr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_CALLoverride_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldH24().disassembly() != 0i128 {
            return None;
        }
        let HAddr24 = if let Some((len, table)) = TableHAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { HAddr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2326:1, end:2326:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar228 {
    HAddr24: TableHAddr24,
}
impl blx_instructionVar228 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("blx"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.HAddr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_CALLoverride_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldH24().disassembly() != 1i128 {
            return None;
        }
        let HAddr24 = if let Some((len, table)) = TableHAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { HAddr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2334:1, end:2334:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar229 {
    HAddr24: TableHAddr24,
}
impl blx_instructionVar229 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("blx"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.HAddr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_CALLoverride_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldH24().disassembly() != 1i128 {
            return None;
        }
        let HAddr24 = if let Some((len, table)) = TableHAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { HAddr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3395:1, end:3395:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar230 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar230 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CRm = token_parser.TokenFieldCRm();
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        let opc1 = token_parser.TokenFieldopc1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4116:1, end:4116:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar231 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar231 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CRm = token_parser.TokenFieldCRm();
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        let opc1 = token_parser.TokenFieldopc1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3407:1, end:3407:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar232 {
    cpn: TokenField_cpn,
    opc1: TokenField_opc1,
    Rd: TokenField_Rd,
    CRn: TokenField_CRn,
    CRm: TokenField_CRm,
    opc2: TokenField_opc2,
    COND: TableCOND,
}
impl mcr_instructionVar232 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 12usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.opc1.display(),
            DisplayElement::Literal(","),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.CRn.display(),
            DisplayElement::Literal(","),
            self.CRm.display(),
            DisplayElement::Literal(","),
            self.opc2.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc1 = token_parser.TokenFieldopc1();
        let CRn = token_parser.TokenFieldCRn();
        let Rd = token_parser.TokenFieldRd();
        let cpn = token_parser.TokenFieldcpn();
        let opc2 = token_parser.TokenFieldopc2();
        let CRm = token_parser.TokenFieldCRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                opc1,
                CRn,
                Rd,
                cpn,
                opc2,
                CRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4129:1, end:4129:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar233 {
    cpn: TokenField_cpn,
    opc1: TokenField_opc1,
    Rd: TokenField_Rd,
    CRn: TokenField_CRn,
    CRm: TokenField_CRm,
    opc2: TokenField_opc2,
    COND: TableCOND,
}
impl mrc_instructionVar233 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 12usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.opc1.display(),
            DisplayElement::Literal(","),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.CRn.display(),
            DisplayElement::Literal(","),
            self.CRm.display(),
            DisplayElement::Literal(","),
            self.opc2.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc1 = token_parser.TokenFieldopc1();
        let CRn = token_parser.TokenFieldCRn();
        let Rd = token_parser.TokenFieldRd();
        let cpn = token_parser.TokenFieldcpn();
        let opc2 = token_parser.TokenFieldopc2();
        let CRm = token_parser.TokenFieldCRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                opc1,
                CRn,
                Rd,
                cpn,
                opc2,
                CRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2464:1, end:2464:2))"]
#[derive(Clone, Debug)]
struct cdp_instructionVar234 {
    cpn: TokenField_cpn,
    opcode1: TokenField_opcode1,
    CRd: TokenField_CRd,
    CRn: TokenField_CRn,
    CRm: TokenField_CRm,
    opcode2: TokenField_opcode2,
    COND: TableCOND,
}
impl cdp_instructionVar234 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cdp")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 12usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.opcode1.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
            self.CRn.display(),
            DisplayElement::Literal(","),
            self.CRm.display(),
            DisplayElement::Literal(","),
            self.opcode2.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opcode1 = token_parser.TokenFieldopcode1();
        let CRn = token_parser.TokenFieldCRn();
        let CRd = token_parser.TokenFieldCRd();
        let cpn = token_parser.TokenFieldcpn();
        let opcode2 = token_parser.TokenFieldopcode2();
        let CRm = token_parser.TokenFieldCRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                opcode1,
                CRn,
                CRd,
                cpn,
                opcode2,
                CRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2166:1, end:2166:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar235 {
    cc: Tablecc,
    Addr24: TableAddr24,
}
impl b_instructionVar235 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.cc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldL24().disassembly() != 0i128 {
            return None;
        }
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cc, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2196:1, end:2196:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar236 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl bic_instructionVar236 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2207:1, end:2207:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar237 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl bic_instructionVar237 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2218:1, end:2218:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar238 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl bic_instructionVar238 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2290:1, end:2290:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar239 {
    COND: TableCOND,
    Addr24: TableAddr24,
}
impl bl_instructionVar239 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_CALLoverride_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldL24().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2298:1, end:2298:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar240 {
    COND: TableCOND,
    Addr24: TableAddr24,
}
impl bl_instructionVar240 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_CALLoverride_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldL24().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2611:1, end:2611:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar241 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl eor_instructionVar241 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2622:1, end:2622:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar242 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl eor_instructionVar242 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2633:1, end:2633:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar243 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl eor_instructionVar243 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2695:1, end:2695:2))"]
#[derive(Clone, Debug)]
struct ldc2_instructionVar244 {
    cpn: TokenField_cpn,
    CRd: TokenField_CRd,
    addrmode5: Tableaddrmode5,
}
impl ldc2_instructionVar244 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("ldc2"),
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldN22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let addrmode5 = if let Some((len, table)) = Tableaddrmode5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpn = token_parser.TokenFieldcpn();
        let CRd = token_parser.TokenFieldCRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2701:1, end:2701:2))"]
#[derive(Clone, Debug)]
struct ldc2l_instructionVar245 {
    cpn: TokenField_cpn,
    CRd: TokenField_CRd,
    addrmode5: Tableaddrmode5,
}
impl ldc2l_instructionVar245 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("ldc2l"),
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldN22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let addrmode5 = if let Some((len, table)) = Tableaddrmode5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpn = token_parser.TokenFieldcpn();
        let CRd = token_parser.TokenFieldCRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2710:1, end:2710:2))"]
#[derive(Clone, Debug)]
struct ldc_instructionVar246 {
    cpn: TokenField_cpn,
    CRd: TokenField_CRd,
    COND: TableCOND,
    addrmode5: Tableaddrmode5,
}
impl ldc_instructionVar246 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldN22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) = Tableaddrmode5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpn = token_parser.TokenFieldcpn();
        let CRd = token_parser.TokenFieldCRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2718:1, end:2718:2))"]
#[derive(Clone, Debug)]
struct ldcl_instructionVar247 {
    cpn: TokenField_cpn,
    CRd: TokenField_CRd,
    COND: TableCOND,
    addrmode5: Tableaddrmode5,
}
impl ldcl_instructionVar247 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldcl")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldN22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) = Tableaddrmode5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpn = token_parser.TokenFieldcpn();
        let CRd = token_parser.TokenFieldCRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2726:1, end:2726:2))"]
#[derive(Clone, Debug)]
struct ldm_instructionVar248 {
    COND: TableCOND,
    mdir: Tablemdir,
    reglist: Tablereglist,
}
impl ldm_instructionVar248 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldm")];
        display.extend_from_slice(&extend);
        self.mdir.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reglist.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1515().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mdir = if let Some((len, table)) =
            Tablemdir::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let reglist = if let Some((len, table)) = Tablereglist::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                mdir,
                reglist,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2732:1, end:2732:2))"]
#[derive(Clone, Debug)]
struct ldm_instructionVar249 {
    COND: TableCOND,
    mdir: Tablemdir,
    reglist: Tablereglist,
}
impl ldm_instructionVar249 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldm")];
        display.extend_from_slice(&extend);
        self.mdir.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reglist.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1515().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mdir = if let Some((len, table)) =
            Tablemdir::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let reglist = if let Some((len, table)) = Tablereglist::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                mdir,
                reglist,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2771:1, end:2771:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar250 {
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar250 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_LRset(
            Some(inst_next),
            context.register().read_LRset_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_LRset_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let tmp = 0i128;
        context_instance
            .register_mut()
            .write_LRset_disassembly(tmp)
            .unwrap();
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c124 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c124 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c124(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c124(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2793:1, end:2793:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar251 {
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar251 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c114 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c114 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c114(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c114(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2759:1, end:2759:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar252 {
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar252 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_LRset(
            Some(inst_next),
            context.register().read_LRset_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_LRset_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        let tmp = 0i128;
        context_instance
            .register_mut()
            .write_LRset_disassembly(tmp)
            .unwrap();
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c116 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c116 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c116(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c116(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2784:1, end:2784:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar253 {
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar253 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c106 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c106(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c106(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2809:1, end:2809:2))"]
#[derive(Clone, Debug)]
struct ldrbt_instructionVar254 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldrbt_instructionVar254 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrbt")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c107 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c107 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c107(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c107(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2913:1, end:2913:2))"]
#[derive(Clone, Debug)]
struct ldrt_instructionVar255 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldrt_instructionVar255 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrt")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c106 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c106(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c106(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5423:1, end:5423:2))"]
#[derive(Clone, Debug)]
struct stc_instructionVar256 {
    cpn: TokenField_cpn,
    CRd: TokenField_CRd,
    COND: TableCOND,
    addrmode5: Tableaddrmode5,
}
impl stc_instructionVar256 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("stc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldN22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) = Tableaddrmode5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpn = token_parser.TokenFieldcpn();
        let CRd = token_parser.TokenFieldCRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5431:1, end:5431:2))"]
#[derive(Clone, Debug)]
struct stcl_instructionVar257 {
    cpn: TokenField_cpn,
    CRd: TokenField_CRd,
    COND: TableCOND,
    addrmode5: Tableaddrmode5,
}
impl stcl_instructionVar257 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("stcl")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldN22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) = Tableaddrmode5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpn = token_parser.TokenFieldcpn();
        let CRd = token_parser.TokenFieldCRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5469:1, end:5469:2))"]
#[derive(Clone, Debug)]
struct strbt_instructionVar258 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl strbt_instructionVar258 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strbt")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c107 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c107 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c107(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c107(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5569:1, end:5569:2))"]
#[derive(Clone, Debug)]
struct strt_instructionVar259 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl strt_instructionVar259 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strt")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c106 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c106(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c106(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2751:1, end:2751:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar260 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar260 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c90 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2802:1, end:2802:2))"]
#[derive(Clone, Debug)]
struct ldrb_instructionVar261 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldrb_instructionVar261 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c90 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2818:1, end:2818:2))"]
#[derive(Clone, Debug)]
struct ldrd_instructionVar262 {
    Rd: TokenField_Rd,
    Rd2: TokenField_Rd2,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl ldrd_instructionVar262 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrd")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rd2.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1212().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) = Tableaddrmode3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        let Rd2 = token_parser.TokenFieldRd2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
                Rd2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2861:1, end:2861:2))"]
#[derive(Clone, Debug)]
struct ldrh_instructionVar263 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl ldrh_instructionVar263 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrh")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 11i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) = Tableaddrmode3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2878:1, end:2878:2))"]
#[derive(Clone, Debug)]
struct ldrsb_instructionVar264 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl ldrsb_instructionVar264 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrsb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 13i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) = Tableaddrmode3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2895:1, end:2895:2))"]
#[derive(Clone, Debug)]
struct ldrsh_instructionVar265 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl ldrsh_instructionVar265 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrsh")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 15i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) = Tableaddrmode3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4269:1, end:4269:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar266 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl orr_instructionVar266 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4280:1, end:4280:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar267 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl orr_instructionVar267 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4291:1, end:4291:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar268 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl orr_instructionVar268 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4611:1, end:4611:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar269 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl rsb_instructionVar269 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4622:1, end:4622:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar270 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl rsb_instructionVar270 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4633:1, end:4633:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar271 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl rsb_instructionVar271 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4683:1, end:4683:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar272 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl rsc_instructionVar272 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4694:1, end:4694:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar273 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl rsc_instructionVar273 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4705:1, end:4705:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar274 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl rsc_instructionVar274 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4815:1, end:4815:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar275 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl sbc_instructionVar275 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4826:1, end:4826:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar276 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl sbc_instructionVar276 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4837:1, end:4837:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar277 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl sbc_instructionVar277 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5477:1, end:5477:2))"]
#[derive(Clone, Debug)]
struct strh_instructionVar278 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl strh_instructionVar278 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strh")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 11i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) = Tableaddrmode3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5487:1, end:5487:2))"]
#[derive(Clone, Debug)]
struct strd_instructionVar279 {
    Rd: TokenField_Rd,
    Rd2: TokenField_Rd2,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl strd_instructionVar279 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strd")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rd2.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) = Tableaddrmode3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        let Rd2 = token_parser.TokenFieldRd2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
                Rd2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5439:1, end:5439:2))"]
#[derive(Clone, Debug)]
struct stm_instructionVar280 {
    COND: TableCOND,
    mdir: Tablemdir,
    reglist: Tablereglist,
}
impl stm_instructionVar280 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("stm")];
        display.extend_from_slice(&extend);
        self.mdir.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reglist.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mdir = if let Some((len, table)) =
            Tablemdir::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let reglist = if let Some((len, table)) = Tablereglist::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                mdir,
                reglist,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5454:1, end:5454:2))"]
#[derive(Clone, Debug)]
struct str_instructionVar281 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl str_instructionVar281 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("str")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c90 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5461:1, end:5461:2))"]
#[derive(Clone, Debug)]
struct strb_instructionVar282 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl strb_instructionVar282 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c90 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5576:1, end:5576:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar283 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl sub_instructionVar283 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5587:1, end:5587:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar284 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl sub_instructionVar284 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5598:1, end:5598:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar285 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl sub_instructionVar285 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5668:1, end:5668:2))"]
#[derive(Clone, Debug)]
struct swi_instructionVar286 {
    immed24: TokenField_immed24,
    COND: TableCOND,
}
impl swi_instructionVar286 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("swi")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(" "), self.immed24.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 15i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed24 = token_parser.TokenFieldimmed24();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, immed24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3243:1, end:3243:2))"]
#[derive(Clone, Debug)]
struct qadd_instructionVar287 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
}
impl qadd_instructionVar287 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qadd")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4008i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop12().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldthc0407().disassembly() != 8i128 {
            return None;
        }
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3311:1, end:3311:2))"]
#[derive(Clone, Debug)]
struct qdadd_instructionVar288 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
}
impl qdadd_instructionVar288 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qdadd")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4008i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop12().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldthc0407().disassembly() != 9i128 {
            return None;
        }
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3323:1, end:3323:2))"]
#[derive(Clone, Debug)]
struct qdsub_instructionVar289 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
}
impl qdsub_instructionVar289 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qdsub")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4008i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop12().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldthc0407().disassembly() != 11i128 {
            return None;
        }
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3358:1, end:3358:2))"]
#[derive(Clone, Debug)]
struct qsub_instructionVar290 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
}
impl qsub_instructionVar290 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qsub")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4008i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop12().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldthc0407().disassembly() != 10i128 {
            return None;
        }
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3974:1, end:3974:2))"]
#[derive(Clone, Debug)]
struct smmul_instructionVar291 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
}
impl smmul_instructionVar291 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smmul")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4021i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldthc0407().disassembly() != 0i128 {
            return None;
        }
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3981:1, end:3981:2))"]
#[derive(Clone, Debug)]
struct smmulr_instructionVar292 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
}
impl smmulr_instructionVar292 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smmulr")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4021i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldthc0407().disassembly() != 1i128 {
            return None;
        }
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4001:1, end:4001:2))"]
#[derive(Clone, Debug)]
struct smulbb_instructionVar293 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
}
impl smulbb_instructionVar293 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smulbb")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4017i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop12().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldsop0407().disassembly() != 0i128 {
            return None;
        }
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4011:1, end:4011:2))"]
#[derive(Clone, Debug)]
struct smulbt_instructionVar294 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
}
impl smulbt_instructionVar294 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smulbt")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4017i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop12().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldsop0407().disassembly() != 1i128 {
            return None;
        }
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4021:1, end:4021:2))"]
#[derive(Clone, Debug)]
struct smultb_instructionVar295 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
}
impl smultb_instructionVar295 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smultb")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4017i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop12().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldsop0407().disassembly() != 2i128 {
            return None;
        }
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4031:1, end:4031:2))"]
#[derive(Clone, Debug)]
struct smultt_instructionVar296 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
}
impl smultt_instructionVar296 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smultt")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4017i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop12().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldsop0407().disassembly() != 3i128 {
            return None;
        }
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3989:1, end:3989:2))"]
#[derive(Clone, Debug)]
struct smuad_instructionVar297 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
    thdXbot: TablethdXbot,
    thdXtop: TablethdXtop,
}
impl smuad_instructionVar297 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smuad")];
        display.extend_from_slice(&extend);
        self.thdXbot.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4018i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldthc0507().disassembly() != 0i128 {
            return None;
        }
        let thdXbot = if let Some((len, table)) = TablethdXbot::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let thdXtop = if let Some((len, table)) = TablethdXtop::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thdXbot,
                thdXtop,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4049:1, end:4049:2))"]
#[derive(Clone, Debug)]
struct smusd_instructionVar298 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
    thdXbot: TablethdXbot,
    thdXtop: TablethdXtop,
}
impl smusd_instructionVar298 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smusd")];
        display.extend_from_slice(&extend);
        self.thdXbot.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4020i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldthc0507().disassembly() != 0i128 {
            return None;
        }
        let thdXbot = if let Some((len, table)) = TablethdXbot::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let thdXtop = if let Some((len, table)) = TablethdXtop::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thdXbot,
                thdXtop,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4061:1, end:4061:2))"]
#[derive(Clone, Debug)]
struct smulw_instructionVar299 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
    thYBIT: TablethYBIT,
}
impl smulw_instructionVar299 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smulw")];
        display.extend_from_slice(&extend);
        self.thYBIT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4019i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldthc0507().disassembly() != 0i128 {
            return None;
        }
        let thYBIT = if let Some((len, table)) = TablethYBIT::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thYBIT,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1404:1, end:1404:2))"]
#[derive(Clone, Debug)]
struct hvc_instructionVar300 {
    thc0003: TokenField_thc0003,
    thc0011: TokenField_thc0011,
}
impl hvc_instructionVar300 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_tmp: i128 = 0;
        calc_tmp = u32::try_from((12i128 | self.thc0011.disassembly()))
            .ok()
            .map(|shl| self.thc0003.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("hvc"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            DisplayElement::Number(true, calc_tmp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_tmp: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 3966i128 {
            return None;
        }
        let thc0003 = token_parser.TokenFieldthc0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop12().disassembly() != 8i128 {
            return None;
        }
        calc_tmp = u32::try_from(
            (12i128 | token_parser.TokenFieldthc0011().disassembly()),
        )
        .ok()
        .map(|shl| {
            token_parser
                .TokenFieldthc0003()
                .disassembly()
                .checked_shl(shl)
        })
        .flatten()
        .unwrap_or(0);
        let thc0011 = token_parser.TokenFieldthc0011();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thc0003, thc0011 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1410:1, end:1410:2))"]
#[derive(Clone, Debug)]
struct smc_instructionVar301 {
    thc0003: TokenField_thc0003,
    ItCond: TableItCond,
}
impl smc_instructionVar301 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("smc")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.thc0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 3967i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let thc0003 = token_parser.TokenFieldthc0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop12().disassembly() != 8i128 {
            return None;
        }
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, thc0003 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1426:1, end:1426:2))"]
#[derive(Clone, Debug)]
struct udf_instructionVar302 {
    thc0003: TokenField_thc0003,
    thc0011: TokenField_thc0011,
    ItCond: TableItCond,
}
impl udf_instructionVar302 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_tmp: i128 = 0;
        calc_tmp = u32::try_from((12i128 | self.thc0011.disassembly()))
            .ok()
            .map(|shl| self.thc0003.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("udf")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            DisplayElement::Number(true, calc_tmp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_tmp: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 3967i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let thc0003 = token_parser.TokenFieldthc0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop12().disassembly() != 10i128 {
            return None;
        }
        calc_tmp = u32::try_from(
            (12i128 | token_parser.TokenFieldthc0011().disassembly()),
        )
        .ok()
        .map(|shl| {
            token_parser
                .TokenFieldthc0003()
                .disassembly()
                .checked_shl(shl)
        })
        .flatten()
        .unwrap_or(0);
        let thc0011 = token_parser.TokenFieldthc0011();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thc0003,
                thc0011,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3150:1, end:3150:2))"]
#[derive(Clone, Debug)]
struct pop_instructionVar303 {
    ItCond: TableItCond,
    thldrlist_inc: Tablethldrlist_inc,
}
impl pop_instructionVar303 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("pop")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.thldrlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop0().disassembly() != 59581i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1515().disassembly() != 1i128 {
            return None;
        }
        let thldrlist_inc = if let Some((len, table)) =
            Tablethldrlist_inc::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thldrlist_inc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2591:1, end:2591:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar304 {
    ItCond: TableItCond,
    Hrm0305: TableHrm0305,
    Hrd0002: TableHrd0002,
}
impl mov_instructionVar304 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrd0002.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Hrm0305.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 70i128 {
            return None;
        }
        if token_parser.TokenFieldrm0306().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldhrd0002().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldh1().disassembly() != 1i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) = TableHrm0305::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrd0002 = if let Some((len, table)) = TableHrd0002::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrm0305,
                Hrd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3007:1, end:3007:2))"]
#[derive(Clone, Debug)]
struct nop_instructionVar305 {
    ItCond: TableItCond,
}
impl nop_instructionVar305 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("nop")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop0().disassembly() != 48896i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3015:1, end:3015:2))"]
#[derive(Clone, Debug)]
struct nop_instructionVar306 {}
impl nop_instructionVar306 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("nop")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop0().disassembly() != 18112i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3141:1, end:3141:2))"]
#[derive(Clone, Debug)]
struct pop_instructionVar307 {
    ItCond: TableItCond,
    thldrlist_inc: Tablethldrlist_inc,
}
impl pop_instructionVar307 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("pop")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.thldrlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop0().disassembly() != 59581i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let thldrlist_inc = if let Some((len, table)) =
            Tablethldrlist_inc::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thldrlist_inc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3232:1, end:3232:2))"]
#[derive(Clone, Debug)]
struct push_instructionVar308 {
    ItCond: TableItCond,
    thstrlist_dec: Tablethstrlist_dec,
}
impl push_instructionVar308 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("push")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.thstrlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop0().disassembly() != 59693i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let thstrlist_dec = if let Some((len, table)) =
            Tablethstrlist_dec::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thstrlist_dec,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1520:1, end:1520:2))"]
#[derive(Clone, Debug)]
struct bx_instructionVar309 {
    ItCond: TableItCond,
    Hrm0305: TableHrm0305,
    bxns: Tablebxns,
}
impl bx_instructionVar309 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bx")];
        display.extend_from_slice(&extend);
        self.bxns.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrm0305.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop7().disassembly() != 142i128 {
            return None;
        }
        if token_parser.TokenFieldhrm0305().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldh2().disassembly() != 1i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) = TableHrm0305::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let bxns = if let Some((len, table)) =
            Tablebxns::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrm0305,
                bxns,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3882:1, end:3882:2))"]
#[derive(Clone, Debug)]
struct smlal_instructionVar310 {
    Rt1215: TokenField_Rt1215,
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
}
impl smlal_instructionVar310 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlal")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Rt1215.display(),
            DisplayElement::Literal(","),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4028i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsop0407().disassembly() != 0i128 {
            return None;
        }
        let Rt1215 = token_parser.TokenFieldRt1215();
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Rt1215,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3939:1, end:3939:2))"]
#[derive(Clone, Debug)]
struct smmla_instructionVar311 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    Ra1215: TokenField_Ra1215,
    ItCond: TableItCond,
}
impl smmla_instructionVar311 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smmla")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
            DisplayElement::Literal(","),
            self.Ra1215.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4021i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0407().disassembly() != 0i128 {
            return None;
        }
        let Ra1215 = token_parser.TokenFieldRa1215();
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Ra1215,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3948:1, end:3948:2))"]
#[derive(Clone, Debug)]
struct smmlar_instructionVar312 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    Ra1215: TokenField_Ra1215,
    ItCond: TableItCond,
}
impl smmlar_instructionVar312 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smmlar")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
            DisplayElement::Literal(","),
            self.Ra1215.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4021i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0407().disassembly() != 1i128 {
            return None;
        }
        let Ra1215 = token_parser.TokenFieldRa1215();
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Ra1215,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3957:1, end:3957:2))"]
#[derive(Clone, Debug)]
struct smmls_instructionVar313 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    Ra1215: TokenField_Ra1215,
    ItCond: TableItCond,
}
impl smmls_instructionVar313 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smmls")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
            DisplayElement::Literal(","),
            self.Ra1215.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4022i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0407().disassembly() != 0i128 {
            return None;
        }
        let Ra1215 = token_parser.TokenFieldRa1215();
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Ra1215,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3965:1, end:3965:2))"]
#[derive(Clone, Debug)]
struct smmlsr_instructionVar314 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    Ra1215: TokenField_Ra1215,
    ItCond: TableItCond,
}
impl smmlsr_instructionVar314 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smmlsr")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
            DisplayElement::Literal(","),
            self.Ra1215.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4022i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0407().disassembly() != 1i128 {
            return None;
        }
        let Ra1215 = token_parser.TokenFieldRa1215();
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Ra1215,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4041:1, end:4041:2))"]
#[derive(Clone, Debug)]
struct smull_instructionVar315 {
    Ra1215: TokenField_Ra1215,
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
}
impl smull_instructionVar315 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smull")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Ra1215.display(),
            DisplayElement::Literal(","),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4024i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsop0407().disassembly() != 0i128 {
            return None;
        }
        let Ra1215 = token_parser.TokenFieldRa1215();
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Ra1215,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3854:1, end:3854:2))"]
#[derive(Clone, Debug)]
struct smlad_instructionVar316 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    Ra1215: TokenField_Ra1215,
    ItCond: TableItCond,
    thdXbot: TablethdXbot,
    thdXtop: TablethdXtop,
}
impl smlad_instructionVar316 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlad")];
        display.extend_from_slice(&extend);
        self.thdXbot.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
            DisplayElement::Literal(","),
            self.Ra1215.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4018i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0507().disassembly() != 0i128 {
            return None;
        }
        let thdXbot = if let Some((len, table)) = TablethdXbot::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let thdXtop = if let Some((len, table)) = TablethdXtop::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Ra1215 = token_parser.TokenFieldRa1215();
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thdXbot,
                thdXtop,
                Rn0003,
                Ra1215,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3867:1, end:3867:2))"]
#[derive(Clone, Debug)]
struct smlald_instructionVar317 {
    Rt1215: TokenField_Rt1215,
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
    thdXbot: TablethdXbot,
    thdXtop: TablethdXtop,
}
impl smlald_instructionVar317 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlald")];
        display.extend_from_slice(&extend);
        self.thdXbot.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Rt1215.display(),
            DisplayElement::Literal(","),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4028i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0507().disassembly() != 6i128 {
            return None;
        }
        let thdXbot = if let Some((len, table)) = TablethdXbot::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let thdXtop = if let Some((len, table)) = TablethdXtop::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rt1215 = token_parser.TokenFieldRt1215();
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thdXbot,
                thdXtop,
                Rn0003,
                Rt1215,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3901:1, end:3901:2))"]
#[derive(Clone, Debug)]
struct smlaw_instructionVar318 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    Ra1215: TokenField_Ra1215,
    ItCond: TableItCond,
    thYBIT: TablethYBIT,
}
impl smlaw_instructionVar318 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlaw")];
        display.extend_from_slice(&extend);
        self.thYBIT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
            DisplayElement::Literal(","),
            self.Ra1215.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4019i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0507().disassembly() != 0i128 {
            return None;
        }
        let thYBIT = if let Some((len, table)) = TablethYBIT::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Ra1215 = token_parser.TokenFieldRa1215();
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thYBIT,
                Rn0003,
                Ra1215,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3911:1, end:3911:2))"]
#[derive(Clone, Debug)]
struct smlsd_instructionVar319 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    Ra1215: TokenField_Ra1215,
    ItCond: TableItCond,
    thdXbot: TablethdXbot,
    thdXtop: TablethdXtop,
}
impl smlsd_instructionVar319 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlsd")];
        display.extend_from_slice(&extend);
        self.thdXbot.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
            DisplayElement::Literal(","),
            self.Ra1215.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4020i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0507().disassembly() != 0i128 {
            return None;
        }
        let thdXbot = if let Some((len, table)) = TablethdXbot::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let thdXtop = if let Some((len, table)) = TablethdXtop::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Ra1215 = token_parser.TokenFieldRa1215();
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thdXbot,
                thdXtop,
                Rn0003,
                Ra1215,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3924:1, end:3924:2))"]
#[derive(Clone, Debug)]
struct smlsld_instructionVar320 {
    Rt1215: TokenField_Rt1215,
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
    thdXbot: TablethdXbot,
    thdXtop: TablethdXtop,
}
impl smlsld_instructionVar320 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlsld")];
        display.extend_from_slice(&extend);
        self.thdXbot.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Rt1215.display(),
            DisplayElement::Literal(","),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4029i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0507().disassembly() != 6i128 {
            return None;
        }
        let thdXbot = if let Some((len, table)) = TablethdXbot::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let thdXtop = if let Some((len, table)) = TablethdXtop::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rt1215 = token_parser.TokenFieldRt1215();
        let Rd0811 = token_parser.TokenFieldRd0811();
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thdXbot,
                thdXtop,
                Rn0003,
                Rt1215,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3840:1, end:3840:2))"]
#[derive(Clone, Debug)]
struct smla_instructionVar321 {
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    Rt1215: TokenField_Rt1215,
    ItCond: TableItCond,
    thYBIT: TablethYBIT,
    thXBIT: TablethXBIT,
}
impl smla_instructionVar321 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smla")];
        display.extend_from_slice(&extend);
        self.thXBIT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.thYBIT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
            DisplayElement::Literal(","),
            self.Rt1215.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c81 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldop4().disassembly() != 4017i128 {
                return None;
            }
            let Rn0003 = token_parser.TokenFieldRn0003();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldthc0607().disassembly() != 0i128 {
                return None;
            }
            let thYBIT = if let Some((len, table)) =
                TablethYBIT::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as u32);
                table
            } else {
                return None;
            };
            let Rt1215 = token_parser.TokenFieldRt1215();
            let Rd0811 = token_parser.TokenFieldRd0811();
            let Rm0003 = token_parser.TokenFieldRm0003();
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((thYBIT), (Rn0003, Rt1215, Rd0811, Rm0003), pattern_len))
        };
        let ((mut thYBIT), (Rn0003, Rt1215, Rd0811, Rm0003), sub_len) =
            sub_pattern_c81(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let thXBIT = if let Some((len, table)) = TablethXBIT::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thYBIT,
                thXBIT,
                Rn0003,
                Rt1215,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3891:1, end:3891:2))"]
#[derive(Clone, Debug)]
struct smlal_instructionVar322 {
    Rt1215: TokenField_Rt1215,
    Rd0811: TokenField_Rd0811,
    Rn0003: TokenField_Rn0003,
    Rm0003: TokenField_Rm0003,
    ItCond: TableItCond,
    thYBIT: TablethYBIT,
    thXBIT: TablethXBIT,
}
impl smlal_instructionVar322 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlal")];
        display.extend_from_slice(&extend);
        self.thXBIT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.thYBIT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Rt1215.display(),
            DisplayElement::Literal(","),
            self.Rd0811.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.Rm0003.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c82 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldop4().disassembly() != 4028i128 {
                return None;
            }
            let Rn0003 = token_parser.TokenFieldRn0003();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldthc0607().disassembly() != 2i128 {
                return None;
            }
            let thYBIT = if let Some((len, table)) =
                TablethYBIT::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as u32);
                table
            } else {
                return None;
            };
            let Rt1215 = token_parser.TokenFieldRt1215();
            let Rd0811 = token_parser.TokenFieldRd0811();
            let Rm0003 = token_parser.TokenFieldRm0003();
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((thYBIT), (Rn0003, Rt1215, Rd0811, Rm0003), pattern_len))
        };
        let ((mut thYBIT), (Rn0003, Rt1215, Rd0811, Rm0003), sub_len) =
            sub_pattern_c82(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let thXBIT = if let Some((len, table)) = TablethXBIT::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thYBIT,
                thXBIT,
                Rn0003,
                Rt1215,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2544:1, end:2544:2))"]
#[derive(Clone, Debug)]
struct mcrr_instructionVar323 {
    thcpn: TokenField_thcpn,
    thopcode1: TokenField_thopcode1,
    Rt1215: TokenField_Rt1215,
    Rn0003: TokenField_Rn0003,
    thCRm: TokenField_thCRm,
    ItCond: TableItCond,
}
impl mcrr_instructionVar323 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("mcrr")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 10usize] = [
            DisplayElement::Literal(" "),
            self.thcpn.display(),
            DisplayElement::Literal(","),
            self.thopcode1.display(),
            DisplayElement::Literal(","),
            self.Rt1215.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.thCRm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 3780i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let Rt1215 = token_parser.TokenFieldRt1215();
        let thcpn = token_parser.TokenFieldthcpn();
        let thopcode1 = token_parser.TokenFieldthopcode1();
        let thCRm = token_parser.TokenFieldthCRm();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Rt1215,
                thcpn,
                thopcode1,
                thCRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2552:1, end:2552:2))"]
#[derive(Clone, Debug)]
struct mcrr_instructionVar324 {
    thcpn: TokenField_thcpn,
    thopcode1: TokenField_thopcode1,
    Rt1215: TokenField_Rt1215,
    Rn0003: TokenField_Rn0003,
    thCRm: TokenField_thCRm,
    ItCond: TableItCond,
}
impl mcrr_instructionVar324 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("mcrr")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 10usize] = [
            DisplayElement::Literal(" "),
            self.thcpn.display(),
            DisplayElement::Literal(","),
            self.thopcode1.display(),
            DisplayElement::Literal(","),
            self.Rt1215.display(),
            DisplayElement::Literal(","),
            self.Rn0003.display(),
            DisplayElement::Literal(","),
            self.thCRm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop4().disassembly() != 4036i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let Rt1215 = token_parser.TokenFieldRt1215();
        let thcpn = token_parser.TokenFieldthcpn();
        let thopcode1 = token_parser.TokenFieldthopcode1();
        let thCRm = token_parser.TokenFieldthCRm();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0003,
                Rt1215,
                thcpn,
                thopcode1,
                thCRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1030:1, end:1030:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar325 {
    Rd0002: TokenField_Rd0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
}
impl adc_instructionVar325 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 261i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_CZNO,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2599:1, end:2599:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar326 {
    ItCond: TableItCond,
    Hrm0305: TableHrm0305,
    Hrd0002: TableHrd0002,
}
impl mov_instructionVar326 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_LRset(
            Some(inst_next),
            context.register().read_LRset_disassembly().unwrap(),
        );
        global_set.set_TMode(
            Some(inst_next),
            context.register().read_TMode_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrd0002.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Hrm0305.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 70i128 {
            return None;
        }
        if token_parser.TokenFieldhrm0305().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldhrd0002().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldh1().disassembly() != 1i128 {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_LRset_disassembly(tmp)
            .unwrap();
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_TMode_disassembly(tmp)
            .unwrap();
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) = TableHrm0305::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrd0002 = if let Some((len, table)) = TableHrd0002::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrm0305,
                Hrd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1158:1, end:1158:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar327 {
    ItCond: TableItCond,
    Hrd0002: TableHrd0002,
    Hrm0305: TableHrm0305,
}
impl add_instructionVar327 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrd0002.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Hrm0305.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 68i128 {
            return None;
        }
        if token_parser.TokenFieldhrd0002().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldh1().disassembly() != 1i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrd0002 = if let Some((len, table)) = TableHrd0002::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) = TableHrm0305::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrd0002,
                Hrm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1214:1, end:1214:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar328 {
    Rd0002: TokenField_Rd0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
    CheckInIT_ZN: TableCheckInIT_ZN,
}
impl and_instructionVar328 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        self.CheckInIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 256i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) = TableCheckInIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        let Rm0305 = token_parser.TokenFieldRm0305();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1249:1, end:1249:2))"]
#[derive(Clone, Debug)]
struct asr_instructionVar329 {
    Rd0002: TokenField_Rd0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
    Immed5: TableImmed5,
    CheckInIT_CZN: TableCheckInIT_CZN,
}
impl asr_instructionVar329 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("asr")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
            DisplayElement::Literal(",#0x20"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldimmed5().disassembly() != 0i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Immed5 = if let Some((len, table)) = TableImmed5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Immed5,
                CheckInIT_CZN,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1267:1, end:1267:2))"]
#[derive(Clone, Debug)]
struct asr_instructionVar330 {
    Rd0002: TokenField_Rd0002,
    Rs0305: TokenField_Rs0305,
    ItCond: TableItCond,
    CheckInIT_CZN: TableCheckInIT_CZN,
}
impl asr_instructionVar330 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("asr")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rs0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 260i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        let Rs0305 = token_parser.TokenFieldRs0305();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_CZN,
                Rd0002,
                Rs0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1357:1, end:1357:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar331 {
    Rd0002: TokenField_Rd0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
    CheckInIT_ZN: TableCheckInIT_ZN,
}
impl bic_instructionVar331 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        self.CheckInIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 270i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) = TableCheckInIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        let Rm0305 = token_parser.TokenFieldRm0305();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1392:1, end:1392:2))"]
#[derive(Clone, Debug)]
struct hlt_instructionVar332 {
    immed6: TokenField_immed6,
}
impl hlt_instructionVar332 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("hlt"),
            DisplayElement::Literal(" "),
            self.immed6.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 746i128 {
            return None;
        }
        let immed6 = token_parser.TokenFieldimmed6();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1635:1, end:1635:2))"]
#[derive(Clone, Debug)]
struct cmn_instructionVar333 {
    Rn0002: TokenField_Rn0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
}
impl cmn_instructionVar333 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmn")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rn0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 267i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rn0002 = token_parser.TokenFieldRn0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rm0305,
                Rn0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1675:1, end:1675:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar334 {
    Rn0002: TokenField_Rn0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
}
impl cmp_instructionVar334 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rn0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 266i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rn0002 = token_parser.TokenFieldRn0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rm0305,
                Rn0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1829:1, end:1829:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar335 {
    Rd0002: TokenField_Rd0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
    CheckInIT_ZN: TableCheckInIT_ZN,
}
impl eor_instructionVar335 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        self.CheckInIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 257i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) = TableCheckInIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2438:1, end:2438:2))"]
#[derive(Clone, Debug)]
struct lsl_instructionVar336 {
    Rd0002: TokenField_Rd0002,
    Rs0305: TokenField_Rs0305,
    ItCond: TableItCond,
    CheckInIT_CZN: TableCheckInIT_CZN,
}
impl lsl_instructionVar336 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lsl")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rs0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 258i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rs0305 = token_parser.TokenFieldRs0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_CZN,
                Rs0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2454:1, end:2454:2))"]
#[derive(Clone, Debug)]
struct lsr_instructionVar337 {
    Rd0002: TokenField_Rd0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
    Immed5: TableImmed5,
    CheckInIT_CZN: TableCheckInIT_CZN,
}
impl lsr_instructionVar337 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lsr")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
            DisplayElement::Literal(",#0x20"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldimmed5().disassembly() != 0i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Immed5 = if let Some((len, table)) = TableImmed5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Immed5,
                CheckInIT_CZN,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2473:1, end:2473:2))"]
#[derive(Clone, Debug)]
struct lsr_instructionVar338 {
    Rd0002: TokenField_Rd0002,
    Rs0305: TokenField_Rs0305,
    ItCond: TableItCond,
    CheckInIT_CZN: TableCheckInIT_CZN,
}
impl lsr_instructionVar338 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lsr")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rs0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 259i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        let Rs0305 = token_parser.TokenFieldRs0305();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_CZN,
                Rd0002,
                Rs0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2569:1, end:2569:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar339 {
    Rd0002: TokenField_Rd0002,
    Rn0305: TokenField_Rn0305,
    ItCond: TableItCond,
    CheckInIT_ZN: TableCheckInIT_ZN,
}
impl mov_instructionVar339 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.CheckInIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rn0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 0i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) = TableCheckInIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0305 = token_parser.TokenFieldRn0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Rn0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2583:1, end:2583:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar340 {
    ItCond: TableItCond,
    Hrm0305: TableHrm0305,
    Hrd0002: TableHrd0002,
}
impl mov_instructionVar340 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrd0002.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Hrm0305.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 70i128 {
            return None;
        }
        if token_parser.TokenFieldhrd0002().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldh1().disassembly() != 1i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) = TableHrm0305::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrd0002 = if let Some((len, table)) = TableHrd0002::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrm0305,
                Hrd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2969:1, end:2969:2))"]
#[derive(Clone, Debug)]
struct mul_instructionVar341 {
    Rd0002: TokenField_Rd0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
    CheckInIT_ZN: TableCheckInIT_ZN,
}
impl mul_instructionVar341 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mul")];
        display.extend_from_slice(&extend);
        self.CheckInIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 269i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) = TableCheckInIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2999:1, end:2999:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar342 {
    Rd0002: TokenField_Rd0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
    CheckInIT_ZN: TableCheckInIT_ZN,
}
impl mvn_instructionVar342 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        self.CheckInIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 271i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) = TableCheckInIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3019:1, end:3019:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar343 {
    Rd0002: TokenField_Rd0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
    CheckInIT_ZN: TableCheckInIT_ZN,
}
impl orr_instructionVar343 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        self.CheckInIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 268i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) = TableCheckInIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3425:1, end:3425:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar344 {
    Rd0002: TokenField_Rd0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
}
impl rsb_instructionVar344 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 265i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_CZNO,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3612:1, end:3612:2))"]
#[derive(Clone, Debug)]
struct ror_instructionVar345 {
    Rd0002: TokenField_Rd0002,
    Rs0305: TokenField_Rs0305,
    ItCond: TableItCond,
    CheckInIT_CZN: TableCheckInIT_CZN,
}
impl ror_instructionVar345 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ror")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rs0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 263i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rs0305 = token_parser.TokenFieldRs0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_CZN,
                Rs0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3712:1, end:3712:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar346 {
    Rd0002: TokenField_Rd0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
}
impl sbc_instructionVar346 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 262i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_CZNO,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4812:1, end:4812:2))"]
#[derive(Clone, Debug)]
struct tst_instructionVar347 {
    Rn0002: TokenField_Rn0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
}
impl tst_instructionVar347 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("tst")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rn0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop6().disassembly() != 264i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rn0002 = token_parser.TokenFieldRn0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rm0305,
                Rn0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1172:1, end:1172:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar348 {
    ItCond: TableItCond,
    Immed7_4: TableImmed7_4,
}
impl add_instructionVar348 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed7_4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop7().disassembly() != 352i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Immed7_4 = if let Some((len, table)) = TableImmed7_4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, Immed7_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1509:1, end:1509:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar349 {
    ItCond: TableItCond,
    Hrm0305: TableHrm0305,
    bxns: Tablebxns,
}
impl blx_instructionVar349 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blx")];
        display.extend_from_slice(&extend);
        self.bxns.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrm0305.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop7().disassembly() != 143i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) = TableHrm0305::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let bxns = if let Some((len, table)) =
            Tablebxns::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrm0305,
                bxns,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1527:1, end:1527:2))"]
#[derive(Clone, Debug)]
struct bx_instructionVar350 {
    ItCond: TableItCond,
    Hrm0305: TableHrm0305,
    bxns: Tablebxns,
}
impl bx_instructionVar350 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bx")];
        display.extend_from_slice(&extend);
        self.bxns.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrm0305.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop7().disassembly() != 142i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) = TableHrm0305::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let bxns = if let Some((len, table)) =
            Tablebxns::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrm0305,
                bxns,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1534:1, end:1534:2))"]
#[derive(Clone, Debug)]
struct bx_instructionVar351 {
    ItCond: TableItCond,
    Hrm0305: TableHrm0305,
    bxns: Tablebxns,
}
impl bx_instructionVar351 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_LRset(
            Some(inst_next),
            context.register().read_LRset_disassembly().unwrap(),
        );
        global_set.set_TMode(
            Some(inst_next),
            context.register().read_TMode_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bx")];
        display.extend_from_slice(&extend);
        self.bxns.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrm0305.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_LRset_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop7().disassembly() != 142i128 {
            return None;
        }
        let tmp = 0i128;
        context_instance
            .register_mut()
            .write_LRset_disassembly(tmp)
            .unwrap();
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_TMode_disassembly(tmp)
            .unwrap();
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) = TableHrm0305::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let bxns = if let Some((len, table)) =
            Tablebxns::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrm0305,
                bxns,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2526:1, end:2526:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar352 {
    thcpn: TokenField_thcpn,
    thc0507: TokenField_thc0507,
    Rt1215: TokenField_Rt1215,
    thCRn: TokenField_thCRn,
    thCRm: TokenField_thCRm,
    thopcode2: TokenField_thopcode2,
    ItCond: TableItCond,
}
impl mcr_instructionVar352 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 12usize] = [
            DisplayElement::Literal(" "),
            self.thcpn.display(),
            DisplayElement::Literal(","),
            self.thc0507.display(),
            DisplayElement::Literal(","),
            self.Rt1215.display(),
            DisplayElement::Literal(","),
            self.thCRn.display(),
            DisplayElement::Literal(","),
            self.thCRm.display(),
            DisplayElement::Literal(","),
            self.thopcode2.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 238i128 {
            return None;
        }
        if token_parser.TokenFieldthc0404().disassembly() != 0i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let thc0507 = token_parser.TokenFieldthc0507();
        let thCRn = token_parser.TokenFieldthCRn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        let Rt1215 = token_parser.TokenFieldRt1215();
        let thcpn = token_parser.TokenFieldthcpn();
        let thopcode2 = token_parser.TokenFieldthopcode2();
        let thCRm = token_parser.TokenFieldthCRm();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thc0507,
                thCRn,
                Rt1215,
                thcpn,
                thopcode2,
                thCRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2535:1, end:2535:2))"]
#[derive(Clone, Debug)]
struct mcr2_instructionVar353 {
    thcpn: TokenField_thcpn,
    thc0507: TokenField_thc0507,
    Rt1215: TokenField_Rt1215,
    thCRn: TokenField_thCRn,
    thCRm: TokenField_thCRm,
    thopcode2: TokenField_thopcode2,
    ItCond: TableItCond,
}
impl mcr2_instructionVar353 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("mcr2")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 12usize] = [
            DisplayElement::Literal(" "),
            self.thcpn.display(),
            DisplayElement::Literal(","),
            self.thc0507.display(),
            DisplayElement::Literal(","),
            self.Rt1215.display(),
            DisplayElement::Literal(","),
            self.thCRn.display(),
            DisplayElement::Literal(","),
            self.thCRm.display(),
            DisplayElement::Literal(","),
            self.thopcode2.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 254i128 {
            return None;
        }
        if token_parser.TokenFieldthc0404().disassembly() != 0i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let thc0507 = token_parser.TokenFieldthc0507();
        let thCRn = token_parser.TokenFieldthCRn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        let Rt1215 = token_parser.TokenFieldRt1215();
        let thcpn = token_parser.TokenFieldthcpn();
        let thopcode2 = token_parser.TokenFieldthopcode2();
        let thCRm = token_parser.TokenFieldthCRm();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thc0507,
                thCRn,
                Rt1215,
                thcpn,
                thopcode2,
                thCRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4546:1, end:4546:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar354 {
    ItCond: TableItCond,
    Immed7_4: TableImmed7_4,
}
impl sub_instructionVar354 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed7_4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop7().disassembly() != 353i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Immed7_4 = if let Some((len, table)) = TableImmed7_4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, Immed7_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1152:1, end:1152:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar355 {
    ItCond: TableItCond,
    Hrd0002: TableHrd0002,
    Hrm0305: TableHrm0305,
}
impl add_instructionVar355 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrd0002.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Hrm0305.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 68i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrd0002 = if let Some((len, table)) = TableHrd0002::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) = TableHrm0305::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrd0002,
                Hrm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1397:1, end:1397:2))"]
#[derive(Clone, Debug)]
struct bkpt_instructionVar356 {
    immed8: TokenField_immed8,
    ItCond: TableItCond,
}
impl bkpt_instructionVar356 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("bkpt"),
            DisplayElement::Literal(" "),
            self.immed8.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 190i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed8 = token_parser.TokenFieldimmed8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, immed8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1417:1, end:1417:2))"]
#[derive(Clone, Debug)]
struct udf_instructionVar357 {
    thc0007: TokenField_thc0007,
    ItCond: TableItCond,
}
impl udf_instructionVar357 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("udf")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.thc0007.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 222i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let thc0007 = token_parser.TokenFieldthc0007();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, thc0007 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1684:1, end:1684:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar358 {
    ItCond: TableItCond,
    Hrm0305: TableHrm0305,
    Hrn0002: TableHrn0002,
}
impl cmp_instructionVar358 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrn0002.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Hrm0305.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 69i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) = TableHrm0305::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrn0002 = if let Some((len, table)) = TableHrn0002::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrm0305,
                Hrn0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2577:1, end:2577:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar359 {
    ItCond: TableItCond,
    Hrm0305: TableHrm0305,
    Hrd0002: TableHrd0002,
}
impl mov_instructionVar359 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrd0002.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Hrm0305.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 70i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) = TableHrm0305::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Hrd0002 = if let Some((len, table)) = TableHrd0002::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrm0305,
                Hrd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3121:1, end:3121:2))"]
#[derive(Clone, Debug)]
struct pop_instructionVar360 {
    ItCond: TableItCond,
    ldbrace: Tableldbrace,
}
impl pop_instructionVar360 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("pop")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ldbrace.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 94i128 {
            return None;
        }
        if token_parser.TokenFieldR().disassembly() != 0i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldbrace = if let Some((len, table)) = Tableldbrace::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, ldbrace }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3130:1, end:3130:2))"]
#[derive(Clone, Debug)]
struct pop_instructionVar361 {
    ItCond: TableItCond,
    pclbrace: Tablepclbrace,
}
impl pop_instructionVar361 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("pop")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.pclbrace.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 94i128 {
            return None;
        }
        if token_parser.TokenFieldR().disassembly() != 1i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let pclbrace = if let Some((len, table)) = Tablepclbrace::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, pclbrace }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3214:1, end:3214:2))"]
#[derive(Clone, Debug)]
struct push_instructionVar362 {
    ItCond: TableItCond,
    psbrace: Tablepsbrace,
}
impl push_instructionVar362 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("push")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.psbrace.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 90i128 {
            return None;
        }
        if token_parser.TokenFieldR().disassembly() != 0i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let psbrace = if let Some((len, table)) = Tablepsbrace::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, psbrace }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3223:1, end:3223:2))"]
#[derive(Clone, Debug)]
struct push_instructionVar363 {
    ItCond: TableItCond,
    pcpbrace: Tablepcpbrace,
}
impl push_instructionVar363 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("push")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.pcpbrace.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 90i128 {
            return None;
        }
        if token_parser.TokenFieldR().disassembly() != 1i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let pcpbrace = if let Some((len, table)) = Tablepcpbrace::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, pcpbrace }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4627:1, end:4627:2))"]
#[derive(Clone, Debug)]
struct svc_instructionVar364 {
    immed8: TokenField_immed8,
    ItCond: TableItCond,
}
impl svc_instructionVar364 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("svc")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(" "), self.immed8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 223i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed8 = token_parser.TokenFieldimmed8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, immed8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1063:1, end:1063:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar365 {
    Rd0002: TokenField_Rd0002,
    Rn0305: TokenField_Rn0305,
    ItCond: TableItCond,
    Immed3: TableImmed3,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
}
impl add_instructionVar365 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rn0305.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 14i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Immed3 = if let Some((len, table)) = TableImmed3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0305 = token_parser.TokenFieldRn0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Immed3,
                CheckInIT_CZNO,
                Rn0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1143:1, end:1143:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar366 {
    Rd0002: TokenField_Rd0002,
    Rn0305: TokenField_Rn0305,
    Rm0608: TokenField_Rm0608,
    ItCond: TableItCond,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
}
impl add_instructionVar366 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rn0305.display(),
            DisplayElement::Literal(","),
            self.Rm0608.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 12i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0608 = token_parser.TokenFieldRm0608();
        let Rn0305 = token_parser.TokenFieldRn0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_CZNO,
                Rm0608,
                Rn0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1484:1, end:1484:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar367 {
    ItCond: TableItCond,
    ThArmAddr23: TableThArmAddr23,
}
impl blx_instructionVar367 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_TMode(
            None,
            context.register().read_TMode_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blx")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ThArmAddr23.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 0i128;
        context_instance
            .register_mut()
            .write_TMode_disassembly(tmp)
            .unwrap();
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldop11().disassembly() != 30i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldpart2op().disassembly() != 29i128 {
                return None;
            }
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ThArmAddr23 = if let Some((len, table)) = TableThArmAddr23::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_TMode_disassembly(tmp)
            .unwrap();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                ThArmAddr23,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1493:1, end:1493:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar368 {
    ItCond: TableItCond,
    ThArmAddr23: TableThArmAddr23,
}
impl blx_instructionVar368 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_TMode(
            None,
            context.register().read_TMode_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blx")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ThArmAddr23.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_CALLoverride_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 0i128;
        context_instance
            .register_mut()
            .write_TMode_disassembly(tmp)
            .unwrap();
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c68 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldop11().disassembly() != 30i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldpart2op().disassembly() != 29i128 {
                return None;
            }
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c68(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ThArmAddr23 = if let Some((len, table)) = TableThArmAddr23::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_TMode_disassembly(tmp)
            .unwrap();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                ThArmAddr23,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1436:1, end:1436:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar369 {
    ItCond: TableItCond,
    ThAddr24: TableThAddr24,
}
impl bl_instructionVar369 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ThAddr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldop11().disassembly() != 30i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldpart2c1415().disassembly() != 3i128 {
                return None;
            }
            if token_parser.TokenFieldpart2c1212().disassembly() != 1i128 {
                return None;
            }
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ThAddr24 = if let Some((len, table)) = TableThAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, ThAddr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1461:1, end:1461:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar370 {
    offset11: TokenField_offset11,
    ItCond: TableItCond,
}
impl blx_instructionVar370 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off: i128 = 0;
        calc_off = u32::try_from(1i128)
            .ok()
            .map(|shl| self.offset11.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blx")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            DisplayElement::Number(true, calc_off),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 29i128 {
            return None;
        }
        if token_parser.TokenFieldthc0000().disassembly() != 0i128 {
            return None;
        }
        calc_off = u32::try_from(1i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldoffset11()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0);
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset11 = token_parser.TokenFieldoffset11();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, offset11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1471:1, end:1471:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar371 {
    ItCond: TableItCond,
    ThAddr24: TableThAddr24,
}
impl bl_instructionVar371 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ThAddr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_CALLoverride_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c64 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldop11().disassembly() != 30i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldpart2c1415().disassembly() != 3i128 {
                return None;
            }
            if token_parser.TokenFieldpart2c1212().disassembly() != 1i128 {
                return None;
            }
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c64(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ThAddr24 = if let Some((len, table)) = TableThAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, ThAddr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1501:1, end:1501:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar372 {
    ItCond: TableItCond,
    ThArmAddr23: TableThArmAddr23,
}
impl blx_instructionVar372 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_TMode(
            None,
            context.register().read_TMode_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blx")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ThArmAddr23.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 0i128;
        context_instance
            .register_mut()
            .write_TMode_disassembly(tmp)
            .unwrap();
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldop11().disassembly() != 30i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldpart2c1415().disassembly() != 3i128 {
                return None;
            }
            if token_parser.TokenFieldpart2c1212().disassembly() != 0i128 {
                return None;
            }
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ThArmAddr23 = if let Some((len, table)) = TableThArmAddr23::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_TMode_disassembly(tmp)
            .unwrap();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                ThArmAddr23,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1557:1, end:1557:2))"]
#[derive(Clone, Debug)]
struct cbnz_instructionVar373 {
    Rn0002: TokenField_Rn0002,
    ItCond: TableItCond,
    Addr5: TableAddr5,
}
impl cbnz_instructionVar373 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cbnz")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rn0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Addr5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop12().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldthc1111().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc1010().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldthc0808().disassembly() != 1i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Addr5 = if let Some((len, table)) =
            TableAddr5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0002 = token_parser.TokenFieldRn0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Addr5,
                Rn0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1564:1, end:1564:2))"]
#[derive(Clone, Debug)]
struct cbz_instructionVar374 {
    Rn0002: TokenField_Rn0002,
    ItCond: TableItCond,
    Addr5: TableAddr5,
}
impl cbz_instructionVar374 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cbz")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rn0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Addr5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop12().disassembly() != 11i128 {
            return None;
        }
        if token_parser.TokenFieldthc1111().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldthc1010().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldthc0808().disassembly() != 1i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Addr5 = if let Some((len, table)) =
            TableAddr5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0002 = token_parser.TokenFieldRn0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Addr5,
                Rn0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2008:1, end:2008:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar375 {
    Rd0002: TokenField_Rd0002,
    ItCond: TableItCond,
    RnRmIndirect: TableRnRmIndirect,
}
impl ldr_instructionVar375 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 44i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) = TableRnRmIndirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2037:1, end:2037:2))"]
#[derive(Clone, Debug)]
struct ldrb_instructionVar376 {
    Rd0002: TokenField_Rd0002,
    ItCond: TableItCond,
    RnRmIndirect: TableRnRmIndirect,
}
impl ldrb_instructionVar376 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrb")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 46i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) = TableRnRmIndirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2051:1, end:2051:2))"]
#[derive(Clone, Debug)]
struct ldrh_instructionVar377 {
    Rd0002: TokenField_Rd0002,
    ItCond: TableItCond,
    RnRmIndirect: TableRnRmIndirect,
}
impl ldrh_instructionVar377 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrh")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 45i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) = TableRnRmIndirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2058:1, end:2058:2))"]
#[derive(Clone, Debug)]
struct ldrsb_instructionVar378 {
    Rd0002: TokenField_Rd0002,
    ItCond: TableItCond,
    RnRmIndirect: TableRnRmIndirect,
}
impl ldrsb_instructionVar378 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrsb")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 43i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) = TableRnRmIndirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2065:1, end:2065:2))"]
#[derive(Clone, Debug)]
struct ldrsh_instructionVar379 {
    Rd0002: TokenField_Rd0002,
    ItCond: TableItCond,
    RnRmIndirect: TableRnRmIndirect,
}
impl ldrsh_instructionVar379 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrsh")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 47i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) = TableRnRmIndirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4322:1, end:4322:2))"]
#[derive(Clone, Debug)]
struct str_instructionVar380 {
    Rd0002: TokenField_Rd0002,
    ItCond: TableItCond,
    RnRmIndirect: TableRnRmIndirect,
}
impl str_instructionVar380 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("str")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 40i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) = TableRnRmIndirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4342:1, end:4342:2))"]
#[derive(Clone, Debug)]
struct strb_instructionVar381 {
    Rd0002: TokenField_Rd0002,
    ItCond: TableItCond,
    RnRmIndirect: TableRnRmIndirect,
}
impl strb_instructionVar381 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strb")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 42i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) = TableRnRmIndirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4356:1, end:4356:2))"]
#[derive(Clone, Debug)]
struct strh_instructionVar382 {
    Rd0002: TokenField_Rd0002,
    ItCond: TableItCond,
    RnRmIndirect: TableRnRmIndirect,
}
impl strh_instructionVar382 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strh")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 41i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) = TableRnRmIndirect::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4519:1, end:4519:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar383 {
    Rd0002: TokenField_Rd0002,
    Rn0305: TokenField_Rn0305,
    ItCond: TableItCond,
    Immed3: TableImmed3,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
}
impl sub_instructionVar383 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rn0305.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 15i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Immed3 = if let Some((len, table)) = TableImmed3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0305 = token_parser.TokenFieldRn0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Immed3,
                CheckInIT_CZNO,
                Rn0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4537:1, end:4537:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar384 {
    Rd0002: TokenField_Rd0002,
    Rn0305: TokenField_Rn0305,
    Rm0608: TokenField_Rm0608,
    ItCond: TableItCond,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
}
impl sub_instructionVar384 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rn0305.display(),
            DisplayElement::Literal(","),
            self.Rm0608.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop9().disassembly() != 13i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0608 = token_parser.TokenFieldRm0608();
        let Rn0305 = token_parser.TokenFieldRn0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_CZNO,
                Rm0608,
                Rn0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1072:1, end:1072:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar385 {
    Rd0810: TokenField_Rd0810,
    ItCond: TableItCond,
    Immed8: TableImmed8,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
}
impl add_instructionVar385 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0810.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 6i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Immed8 = if let Some((len, table)) = TableImmed8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0810 = token_parser.TokenFieldRd0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Immed8,
                CheckInIT_CZNO,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1166:1, end:1166:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar386 {
    Rd0810: TokenField_Rd0810,
    ItCond: TableItCond,
    Sprel8: TableSprel8,
}
impl add_instructionVar386 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0810.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Sprel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 21i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Sprel8 = if let Some((len, table)) = TableSprel8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0810 = token_parser.TokenFieldRd0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Sprel8,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1178:1, end:1178:2))"]
#[derive(Clone, Debug)]
struct adr_instructionVar387 {
    Rd0810: TokenField_Rd0810,
    ItCond: TableItCond,
    Pcrel8: TablePcrel8,
}
impl adr_instructionVar387 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adr")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0810.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Pcrel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 20i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Pcrel8 = if let Some((len, table)) = TablePcrel8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0810 = token_parser.TokenFieldRd0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Pcrel8,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1258:1, end:1258:2))"]
#[derive(Clone, Debug)]
struct asr_instructionVar388 {
    Rd0002: TokenField_Rd0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
    Immed5: TableImmed5,
    CheckInIT_CZN: TableCheckInIT_CZN,
}
impl asr_instructionVar388 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("asr")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 2i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Immed5 = if let Some((len, table)) = TableImmed5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Immed5,
                CheckInIT_CZN,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1317:1, end:1317:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar389 {
    ItCond: TableItCond,
    Addr11: TableAddr11,
}
impl b_instructionVar389 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 28i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Addr11 = if let Some((len, table)) = TableAddr11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, Addr11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1446:1, end:1446:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar390 {
    soffset11: TokenField_soffset11,
    ItCond: TableItCond,
}
impl bl_instructionVar390 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off: i128 = 0;
        calc_off = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                u32::try_from(12i128)
                    .ok()
                    .map(|shl| self.soffset11.disassembly().checked_shl(shl))
                    .flatten()
                    .unwrap_or(0),
            );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            DisplayElement::Number(true, calc_off),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 30i128 {
            return None;
        }
        calc_off = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                u32::try_from(12i128)
                    .ok()
                    .map(|shl| {
                        token_parser
                            .TokenFieldsoffset11()
                            .disassembly()
                            .checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0),
            );
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let soffset11 = token_parser.TokenFieldsoffset11();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, soffset11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1452:1, end:1452:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar391 {
    offset11: TokenField_offset11,
    ItCond: TableItCond,
}
impl bl_instructionVar391 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off: i128 = 0;
        calc_off = u32::try_from(1i128)
            .ok()
            .map(|shl| self.offset11.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            DisplayElement::Number(true, calc_off),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 31i128 {
            return None;
        }
        calc_off = u32::try_from(1i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldoffset11()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0);
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset11 = token_parser.TokenFieldoffset11();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, offset11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1644:1, end:1644:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar392 {
    Rn0810: TokenField_Rn0810,
    ItCond: TableItCond,
    Immed8: TableImmed8,
}
impl cmp_instructionVar392 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rn0810.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 5i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Immed8 = if let Some((len, table)) = TableImmed8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Immed8,
                Rn0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1920:1, end:1920:2))"]
#[derive(Clone, Debug)]
struct ldmia_instructionVar393 {
    ItCond: TableItCond,
    Rn_exclaim: TableRn_exclaim,
    ldbrace: Tableldbrace,
    Rn_exclaim_WB: TableRn_exclaim_WB,
}
impl ldmia_instructionVar393 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldmia")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rn_exclaim.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldbrace.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 25i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn_exclaim = if let Some((len, table)) = TableRn_exclaim::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldbrace = if let Some((len, table)) = Tableldbrace::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn_exclaim_WB = if let Some((len, table)) =
            TableRn_exclaim_WB::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn_exclaim,
                ldbrace,
                Rn_exclaim_WB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2001:1, end:2001:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar394 {
    Rd0002: TokenField_Rd0002,
    ItCond: TableItCond,
    RnIndirect4: TableRnIndirect4,
}
impl ldr_instructionVar394 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnIndirect4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 13i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RnIndirect4 = if let Some((len, table)) = TableRnIndirect4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnIndirect4,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2015:1, end:2015:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar395 {
    Rd0810: TokenField_Rd0810,
    ItCond: TableItCond,
    Pcrel8Indirect: TablePcrel8Indirect,
}
impl ldr_instructionVar395 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0810.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Pcrel8Indirect.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 9i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Pcrel8Indirect = if let Some((len, table)) =
            TablePcrel8Indirect::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0810 = token_parser.TokenFieldRd0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Pcrel8Indirect,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2023:1, end:2023:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar396 {
    Rd0810: TokenField_Rd0810,
    ItCond: TableItCond,
    Sprel8Indirect: TableSprel8Indirect,
}
impl ldr_instructionVar396 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0810.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Sprel8Indirect.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 19i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Sprel8Indirect = if let Some((len, table)) =
            TableSprel8Indirect::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0810 = token_parser.TokenFieldRd0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Sprel8Indirect,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2030:1, end:2030:2))"]
#[derive(Clone, Debug)]
struct ldrb_instructionVar397 {
    Rd0002: TokenField_Rd0002,
    ItCond: TableItCond,
    RnIndirect1: TableRnIndirect1,
}
impl ldrb_instructionVar397 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrb")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnIndirect1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 15i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RnIndirect1 = if let Some((len, table)) = TableRnIndirect1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnIndirect1,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2044:1, end:2044:2))"]
#[derive(Clone, Debug)]
struct ldrh_instructionVar398 {
    Rd0002: TokenField_Rd0002,
    ItCond: TableItCond,
    RnIndirect2: TableRnIndirect2,
}
impl ldrh_instructionVar398 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrh")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnIndirect2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 17i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RnIndirect2 = if let Some((len, table)) = TableRnIndirect2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnIndirect2,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2429:1, end:2429:2))"]
#[derive(Clone, Debug)]
struct lsl_instructionVar399 {
    Rd0002: TokenField_Rd0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
    Immed5: TableImmed5,
    CheckInIT_CZN: TableCheckInIT_CZN,
}
impl lsl_instructionVar399 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lsl")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 0i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Immed5 = if let Some((len, table)) = TableImmed5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Immed5,
                CheckInIT_CZN,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2463:1, end:2463:2))"]
#[derive(Clone, Debug)]
struct lsr_instructionVar400 {
    Rd0002: TokenField_Rd0002,
    Rm0305: TokenField_Rm0305,
    ItCond: TableItCond,
    Immed5: TableImmed5,
    CheckInIT_CZN: TableCheckInIT_CZN,
}
impl lsr_instructionVar400 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lsr")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
            self.Rm0305.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 1i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Immed5 = if let Some((len, table)) = TableImmed5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rm0305 = token_parser.TokenFieldRm0305();
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Immed5,
                CheckInIT_CZN,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2561:1, end:2561:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar401 {
    Rd0810: TokenField_Rd0810,
    ItCond: TableItCond,
    Immed8: TableImmed8,
    CheckInIT_ZN: TableCheckInIT_ZN,
}
impl mov_instructionVar401 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.CheckInIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0810.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 4i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Immed8 = if let Some((len, table)) = TableImmed8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) = TableCheckInIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0810 = token_parser.TokenFieldRd0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Immed8,
                CheckInIT_ZN,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4308:1, end:4308:2))"]
#[derive(Clone, Debug)]
struct stmia_instructionVar402 {
    ItCond: TableItCond,
    Rn_exclaim: TableRn_exclaim,
    stbrace: Tablestbrace,
    Rn_exclaim_WB: TableRn_exclaim_WB,
}
impl stmia_instructionVar402 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("stmia")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rn_exclaim.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stbrace.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 24i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn_exclaim = if let Some((len, table)) = TableRn_exclaim::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stbrace = if let Some((len, table)) = Tablestbrace::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn_exclaim_WB = if let Some((len, table)) =
            TableRn_exclaim_WB::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn_exclaim,
                stbrace,
                Rn_exclaim_WB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4316:1, end:4316:2))"]
#[derive(Clone, Debug)]
struct str_instructionVar403 {
    Rd0002: TokenField_Rd0002,
    ItCond: TableItCond,
    RnIndirect4: TableRnIndirect4,
}
impl str_instructionVar403 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("str")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnIndirect4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 12i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RnIndirect4 = if let Some((len, table)) = TableRnIndirect4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnIndirect4,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4328:1, end:4328:2))"]
#[derive(Clone, Debug)]
struct str_instructionVar404 {
    Rd0810: TokenField_Rd0810,
    ItCond: TableItCond,
    Sprel8Indirect: TableSprel8Indirect,
}
impl str_instructionVar404 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("str")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0810.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Sprel8Indirect.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 18i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Sprel8Indirect = if let Some((len, table)) =
            TableSprel8Indirect::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0810 = token_parser.TokenFieldRd0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Sprel8Indirect,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4335:1, end:4335:2))"]
#[derive(Clone, Debug)]
struct strb_instructionVar405 {
    Rd0002: TokenField_Rd0002,
    ItCond: TableItCond,
    RnIndirect1: TableRnIndirect1,
}
impl strb_instructionVar405 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strb")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnIndirect1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 14i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RnIndirect1 = if let Some((len, table)) = TableRnIndirect1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnIndirect1,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4349:1, end:4349:2))"]
#[derive(Clone, Debug)]
struct strh_instructionVar406 {
    Rd0002: TokenField_Rd0002,
    ItCond: TableItCond,
    RnIndirect2: TableRnIndirect2,
}
impl strh_instructionVar406 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strh")];
        display.extend_from_slice(&extend);
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0002.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnIndirect2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 16i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RnIndirect2 = if let Some((len, table)) = TableRnIndirect2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnIndirect2,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4528:1, end:4528:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar407 {
    Rd0810: TokenField_Rd0810,
    ItCond: TableItCond,
    Immed8: TableImmed8,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
}
impl sub_instructionVar407 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.CheckInIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.ItCond.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd0810.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop11().disassembly() != 7i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Immed8 = if let Some((len, table)) = TableImmed8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd0810 = token_parser.TokenFieldRd0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Immed8,
                CheckInIT_CZNO,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1312:1, end:1312:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar408 {
    ItCond: TableItCond,
    thcc: Tablethcc,
    Addr8: TableAddr8,
}
impl b_instructionVar408 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.thcc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop12().disassembly() != 13i128 {
            return None;
        }
        let ItCond = if let Some((len, table)) = TableItCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let thcc = if let Some((len, table)) =
            Tablethcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c8 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<2usize>>::new(tokens_param)?;
                if token_parser.TokenFieldthc1515().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(2u64).unwrap()));
                }
                let token_parser = <TokenParser<2usize>>::new(tokens_param)?;
                if token_parser.TokenFieldthc1414().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(2u64).unwrap()));
                }
                let token_parser = <TokenParser<2usize>>::new(tokens_param)?;
                if token_parser.TokenFieldthc1313().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(2u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c8(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Addr8 = if let Some((len, table)) =
            TableAddr8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thcc,
                Addr8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1526:1, end:1526:2))"]
#[derive(Clone, Debug)]
struct instructionVar409 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar409 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_ARMcondCk_disassembly(tmp)
            .unwrap();
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_ARMcond_disassembly(tmp)
            .unwrap();
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldbit31().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldbit30().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldbit29().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldbit28().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1527:1, end:1527:2))"]
#[derive(Clone, Debug)]
struct instructionVar410 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar410 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_ARMcondCk_disassembly(tmp)
            .unwrap();
        let tmp = 0i128;
        context_instance
            .register_mut()
            .write_ARMcond_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(bl_instructionVar0),
    Var1(mov_instructionVar1),
    Var2(mov_instructionVar2),
    Var3(nop_instructionVar3),
    Var4(hlt_instructionVar4),
    Var5(bkpt_instructionVar5),
    Var6(hvc_instructionVar6),
    Var7(udf_instructionVar7),
    Var8(bl_instructionVar8),
    Var9(bx_instructionVar9),
    Var10(mov_instructionVar10),
    Var11(blx_instructionVar11),
    Var12(blx_instructionVar12),
    Var13(bx_instructionVar13),
    Var14(bx_instructionVar14),
    Var15(bx_instructionVar15),
    Var16(mcr_instructionVar16),
    Var17(mcr_instructionVar17),
    Var18(mcr_instructionVar18),
    Var19(mcr_instructionVar19),
    Var20(mcr_instructionVar20),
    Var21(mcr_instructionVar21),
    Var22(mcr_instructionVar22),
    Var23(mcr_instructionVar23),
    Var24(mcr_instructionVar24),
    Var25(mcr_instructionVar25),
    Var26(mcr_instructionVar26),
    Var27(mcr_instructionVar27),
    Var28(mcr_instructionVar28),
    Var29(mcr_instructionVar29),
    Var30(mcr_instructionVar30),
    Var31(mcr_instructionVar31),
    Var32(mcr_instructionVar32),
    Var33(mcr_instructionVar33),
    Var34(mcr_instructionVar34),
    Var35(mcr_instructionVar35),
    Var36(mcr_instructionVar36),
    Var37(mcr_instructionVar37),
    Var38(mcr_instructionVar38),
    Var39(mcr_instructionVar39),
    Var40(mcr_instructionVar40),
    Var41(mcr_instructionVar41),
    Var42(mcr_instructionVar42),
    Var43(mcr_instructionVar43),
    Var44(mcr_instructionVar44),
    Var45(mcr_instructionVar45),
    Var46(mcr_instructionVar46),
    Var47(mcr_instructionVar47),
    Var48(mcr_instructionVar48),
    Var49(mcr_instructionVar49),
    Var50(mcr_instructionVar50),
    Var51(mcr_instructionVar51),
    Var52(mcr_instructionVar52),
    Var53(mcr_instructionVar53),
    Var54(mcr_instructionVar54),
    Var55(mcr_instructionVar55),
    Var56(mcr_instructionVar56),
    Var57(mrc_instructionVar57),
    Var58(mrc_instructionVar58),
    Var59(mrc_instructionVar59),
    Var60(mrc_instructionVar60),
    Var61(mrc_instructionVar61),
    Var62(mrc_instructionVar62),
    Var63(mrc_instructionVar63),
    Var64(mrc_instructionVar64),
    Var65(mrc_instructionVar65),
    Var66(mrc_instructionVar66),
    Var67(mrc_instructionVar67),
    Var68(mrc_instructionVar68),
    Var69(mrc_instructionVar69),
    Var70(mrc_instructionVar70),
    Var71(mrc_instructionVar71),
    Var72(mrc_instructionVar72),
    Var73(mrc_instructionVar73),
    Var74(mrc_instructionVar74),
    Var75(mrc_instructionVar75),
    Var76(mrc_instructionVar76),
    Var77(mrc_instructionVar77),
    Var78(mrc_instructionVar78),
    Var79(mrc_instructionVar79),
    Var80(mrc_instructionVar80),
    Var81(mrc_instructionVar81),
    Var82(mrc_instructionVar82),
    Var83(mrc_instructionVar83),
    Var84(mrc_instructionVar84),
    Var85(mrc_instructionVar85),
    Var86(mrc_instructionVar86),
    Var87(mrc_instructionVar87),
    Var88(mrc_instructionVar88),
    Var89(mrc_instructionVar89),
    Var90(mrc_instructionVar90),
    Var91(mrc_instructionVar91),
    Var92(mrc_instructionVar92),
    Var93(mrc_instructionVar93),
    Var94(mrc_instructionVar94),
    Var95(mrc_instructionVar95),
    Var96(mrc_instructionVar96),
    Var97(mrc_instructionVar97),
    Var98(mrs_instructionVar98),
    Var99(mrs_instructionVar99),
    Var100(clz_instructionVar100),
    Var101(msr_instructionVar101),
    Var102(msr_instructionVar102),
    Var103(qadd_instructionVar103),
    Var104(qdadd_instructionVar104),
    Var105(qdsub_instructionVar105),
    Var106(qsub_instructionVar106),
    Var107(swp_instructionVar107),
    Var108(swpb_instructionVar108),
    Var109(smc_instructionVar109),
    Var110(pld_instructionVar110),
    Var111(pld_instructionVar111),
    Var112(stc2_instructionVar112),
    Var113(stc2l_instructionVar113),
    Var114(smulw_instructionVar114),
    Var115(smul_instructionVar115),
    Var116(msr_instructionVar116),
    Var117(msr_instructionVar117),
    Var118(cmn_instructionVar118),
    Var119(cmn_instructionVar119),
    Var120(cmn_instructionVar120),
    Var121(cmp_instructionVar121),
    Var122(cmp_instructionVar122),
    Var123(cmp_instructionVar123),
    Var124(sub_instructionVar124),
    Var125(mov_instructionVar125),
    Var126(mov_instructionVar126),
    Var127(mov_instructionVar127),
    Var128(mov_instructionVar128),
    Var129(srsdb_instructionVar129),
    Var130(srsdb_instructionVar130),
    Var131(srsib_instructionVar131),
    Var132(srsia_instructionVar132),
    Var133(mul_instructionVar133),
    Var134(mvn_instructionVar134),
    Var135(mvn_instructionVar135),
    Var136(mvn_instructionVar136),
    Var137(teq_instructionVar137),
    Var138(teq_instructionVar138),
    Var139(teq_instructionVar139),
    Var140(teq_instructionVar140),
    Var141(teq_instructionVar141),
    Var142(teq_instructionVar142),
    Var143(tst_instructionVar143),
    Var144(tst_instructionVar144),
    Var145(tst_instructionVar145),
    Var146(adc_instructionVar146),
    Var147(adc_instructionVar147),
    Var148(adc_instructionVar148),
    Var149(add_instructionVar149),
    Var150(add_instructionVar150),
    Var151(add_instructionVar151),
    Var152(and_instructionVar152),
    Var153(and_instructionVar153),
    Var154(and_instructionVar154),
    Var155(bic_instructionVar155),
    Var156(bic_instructionVar156),
    Var157(bic_instructionVar157),
    Var158(eor_instructionVar158),
    Var159(eor_instructionVar159),
    Var160(eor_instructionVar160),
    Var161(mcr_instructionVar161),
    Var162(mcr_instructionVar162),
    Var163(mcr_instructionVar163),
    Var164(mcr_instructionVar164),
    Var165(mcr_instructionVar165),
    Var166(mcr_instructionVar166),
    Var167(mcr_instructionVar167),
    Var168(mcr_instructionVar168),
    Var169(mrc_instructionVar169),
    Var170(mrc_instructionVar170),
    Var171(mrc_instructionVar171),
    Var172(mrc_instructionVar172),
    Var173(mrc_instructionVar173),
    Var174(mrc_instructionVar174),
    Var175(mrc_instructionVar175),
    Var176(mrc_instructionVar176),
    Var177(mcr_instructionVar177),
    Var178(mrc_instructionVar178),
    Var179(smlaw_instructionVar179),
    Var180(smla_instructionVar180),
    Var181(smlal_instructionVar181),
    Var182(mcrr_instructionVar182),
    Var183(mrrc_instructionVar183),
    Var184(mla_instructionVar184),
    Var185(mov_instructionVar185),
    Var186(mov_instructionVar186),
    Var187(mov_instructionVar187),
    Var188(mvn_instructionVar188),
    Var189(mvn_instructionVar189),
    Var190(mvn_instructionVar190),
    Var191(orr_instructionVar191),
    Var192(orr_instructionVar192),
    Var193(orr_instructionVar193),
    Var194(rsb_instructionVar194),
    Var195(rsb_instructionVar195),
    Var196(rsb_instructionVar196),
    Var197(rsc_instructionVar197),
    Var198(rsc_instructionVar198),
    Var199(rsc_instructionVar199),
    Var200(sbc_instructionVar200),
    Var201(sbc_instructionVar201),
    Var202(sbc_instructionVar202),
    Var203(smlal_instructionVar203),
    Var204(smull_instructionVar204),
    Var205(sub_instructionVar205),
    Var206(sub_instructionVar206),
    Var207(sub_instructionVar207),
    Var208(umlal_instructionVar208),
    Var209(umull_instructionVar209),
    Var210(adc_instructionVar210),
    Var211(adc_instructionVar211),
    Var212(adc_instructionVar212),
    Var213(adr_instructionVar213),
    Var214(adr_instructionVar214),
    Var215(add_instructionVar215),
    Var216(add_instructionVar216),
    Var217(add_instructionVar217),
    Var218(and_instructionVar218),
    Var219(and_instructionVar219),
    Var220(and_instructionVar220),
    Var221(mcr2_instructionVar221),
    Var222(mrc2_instructionVar222),
    Var223(cdp2_instructionVar223),
    Var224(b_instructionVar224),
    Var225(bl_instructionVar225),
    Var226(blx_instructionVar226),
    Var227(blx_instructionVar227),
    Var228(blx_instructionVar228),
    Var229(blx_instructionVar229),
    Var230(mcr_instructionVar230),
    Var231(mrc_instructionVar231),
    Var232(mcr_instructionVar232),
    Var233(mrc_instructionVar233),
    Var234(cdp_instructionVar234),
    Var235(b_instructionVar235),
    Var236(bic_instructionVar236),
    Var237(bic_instructionVar237),
    Var238(bic_instructionVar238),
    Var239(bl_instructionVar239),
    Var240(bl_instructionVar240),
    Var241(eor_instructionVar241),
    Var242(eor_instructionVar242),
    Var243(eor_instructionVar243),
    Var244(ldc2_instructionVar244),
    Var245(ldc2l_instructionVar245),
    Var246(ldc_instructionVar246),
    Var247(ldcl_instructionVar247),
    Var248(ldm_instructionVar248),
    Var249(ldm_instructionVar249),
    Var250(ldr_instructionVar250),
    Var251(ldr_instructionVar251),
    Var252(ldr_instructionVar252),
    Var253(ldr_instructionVar253),
    Var254(ldrbt_instructionVar254),
    Var255(ldrt_instructionVar255),
    Var256(stc_instructionVar256),
    Var257(stcl_instructionVar257),
    Var258(strbt_instructionVar258),
    Var259(strt_instructionVar259),
    Var260(ldr_instructionVar260),
    Var261(ldrb_instructionVar261),
    Var262(ldrd_instructionVar262),
    Var263(ldrh_instructionVar263),
    Var264(ldrsb_instructionVar264),
    Var265(ldrsh_instructionVar265),
    Var266(orr_instructionVar266),
    Var267(orr_instructionVar267),
    Var268(orr_instructionVar268),
    Var269(rsb_instructionVar269),
    Var270(rsb_instructionVar270),
    Var271(rsb_instructionVar271),
    Var272(rsc_instructionVar272),
    Var273(rsc_instructionVar273),
    Var274(rsc_instructionVar274),
    Var275(sbc_instructionVar275),
    Var276(sbc_instructionVar276),
    Var277(sbc_instructionVar277),
    Var278(strh_instructionVar278),
    Var279(strd_instructionVar279),
    Var280(stm_instructionVar280),
    Var281(str_instructionVar281),
    Var282(strb_instructionVar282),
    Var283(sub_instructionVar283),
    Var284(sub_instructionVar284),
    Var285(sub_instructionVar285),
    Var286(swi_instructionVar286),
    Var287(qadd_instructionVar287),
    Var288(qdadd_instructionVar288),
    Var289(qdsub_instructionVar289),
    Var290(qsub_instructionVar290),
    Var291(smmul_instructionVar291),
    Var292(smmulr_instructionVar292),
    Var293(smulbb_instructionVar293),
    Var294(smulbt_instructionVar294),
    Var295(smultb_instructionVar295),
    Var296(smultt_instructionVar296),
    Var297(smuad_instructionVar297),
    Var298(smusd_instructionVar298),
    Var299(smulw_instructionVar299),
    Var300(hvc_instructionVar300),
    Var301(smc_instructionVar301),
    Var302(udf_instructionVar302),
    Var303(pop_instructionVar303),
    Var304(mov_instructionVar304),
    Var305(nop_instructionVar305),
    Var306(nop_instructionVar306),
    Var307(pop_instructionVar307),
    Var308(push_instructionVar308),
    Var309(bx_instructionVar309),
    Var310(smlal_instructionVar310),
    Var311(smmla_instructionVar311),
    Var312(smmlar_instructionVar312),
    Var313(smmls_instructionVar313),
    Var314(smmlsr_instructionVar314),
    Var315(smull_instructionVar315),
    Var316(smlad_instructionVar316),
    Var317(smlald_instructionVar317),
    Var318(smlaw_instructionVar318),
    Var319(smlsd_instructionVar319),
    Var320(smlsld_instructionVar320),
    Var321(smla_instructionVar321),
    Var322(smlal_instructionVar322),
    Var323(mcrr_instructionVar323),
    Var324(mcrr_instructionVar324),
    Var325(adc_instructionVar325),
    Var326(mov_instructionVar326),
    Var327(add_instructionVar327),
    Var328(and_instructionVar328),
    Var329(asr_instructionVar329),
    Var330(asr_instructionVar330),
    Var331(bic_instructionVar331),
    Var332(hlt_instructionVar332),
    Var333(cmn_instructionVar333),
    Var334(cmp_instructionVar334),
    Var335(eor_instructionVar335),
    Var336(lsl_instructionVar336),
    Var337(lsr_instructionVar337),
    Var338(lsr_instructionVar338),
    Var339(mov_instructionVar339),
    Var340(mov_instructionVar340),
    Var341(mul_instructionVar341),
    Var342(mvn_instructionVar342),
    Var343(orr_instructionVar343),
    Var344(rsb_instructionVar344),
    Var345(ror_instructionVar345),
    Var346(sbc_instructionVar346),
    Var347(tst_instructionVar347),
    Var348(add_instructionVar348),
    Var349(blx_instructionVar349),
    Var350(bx_instructionVar350),
    Var351(bx_instructionVar351),
    Var352(mcr_instructionVar352),
    Var353(mcr2_instructionVar353),
    Var354(sub_instructionVar354),
    Var355(add_instructionVar355),
    Var356(bkpt_instructionVar356),
    Var357(udf_instructionVar357),
    Var358(cmp_instructionVar358),
    Var359(mov_instructionVar359),
    Var360(pop_instructionVar360),
    Var361(pop_instructionVar361),
    Var362(push_instructionVar362),
    Var363(push_instructionVar363),
    Var364(svc_instructionVar364),
    Var365(add_instructionVar365),
    Var366(add_instructionVar366),
    Var367(blx_instructionVar367),
    Var368(blx_instructionVar368),
    Var369(bl_instructionVar369),
    Var370(blx_instructionVar370),
    Var371(bl_instructionVar371),
    Var372(blx_instructionVar372),
    Var373(cbnz_instructionVar373),
    Var374(cbz_instructionVar374),
    Var375(ldr_instructionVar375),
    Var376(ldrb_instructionVar376),
    Var377(ldrh_instructionVar377),
    Var378(ldrsb_instructionVar378),
    Var379(ldrsh_instructionVar379),
    Var380(str_instructionVar380),
    Var381(strb_instructionVar381),
    Var382(strh_instructionVar382),
    Var383(sub_instructionVar383),
    Var384(sub_instructionVar384),
    Var385(add_instructionVar385),
    Var386(add_instructionVar386),
    Var387(adr_instructionVar387),
    Var388(asr_instructionVar388),
    Var389(b_instructionVar389),
    Var390(bl_instructionVar390),
    Var391(bl_instructionVar391),
    Var392(cmp_instructionVar392),
    Var393(ldmia_instructionVar393),
    Var394(ldr_instructionVar394),
    Var395(ldr_instructionVar395),
    Var396(ldr_instructionVar396),
    Var397(ldrb_instructionVar397),
    Var398(ldrh_instructionVar398),
    Var399(lsl_instructionVar399),
    Var400(lsr_instructionVar400),
    Var401(mov_instructionVar401),
    Var402(stmia_instructionVar402),
    Var403(str_instructionVar403),
    Var404(str_instructionVar404),
    Var405(strb_instructionVar405),
    Var406(strh_instructionVar406),
    Var407(sub_instructionVar407),
    Var408(b_instructionVar408),
    Var409(instructionVar409),
    Var410(instructionVar410),
}
impl Tableinstruction {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var64(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var65(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var66(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var67(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var68(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var69(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var70(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var71(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var72(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var73(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var74(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var75(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var76(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var77(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var78(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var79(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var80(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var81(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var82(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var83(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var84(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var85(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var86(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var87(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var88(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var89(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var90(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var91(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var92(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var93(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var94(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var95(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var96(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var97(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var98(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var99(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var100(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var101(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var102(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var103(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var104(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var105(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var106(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var107(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var108(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var109(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var110(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var111(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var112(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var113(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var114(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var115(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var116(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var117(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var118(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var119(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var120(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var121(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var122(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var123(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var124(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var125(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var126(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var127(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var128(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var129(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var130(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var131(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var132(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var133(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var134(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var135(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var136(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var137(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var138(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var139(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var140(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var141(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var142(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var143(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var144(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var145(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var146(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var147(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var148(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var149(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var150(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var151(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var152(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var153(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var154(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var155(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var156(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var157(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var158(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var159(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var160(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var161(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var162(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var163(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var164(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var165(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var166(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var167(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var168(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var169(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var170(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var171(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var172(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var173(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var174(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var175(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var176(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var177(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var178(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var179(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var180(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var181(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var182(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var183(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var184(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var185(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var186(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var187(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var188(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var189(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var190(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var191(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var192(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var193(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var194(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var195(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var196(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var197(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var198(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var199(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var200(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var201(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var202(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var203(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var204(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var205(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var206(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var207(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var208(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var209(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var210(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var211(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var212(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var213(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var214(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var215(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var216(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var217(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var218(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var219(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var220(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var221(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var222(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var223(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var224(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var225(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var226(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var227(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var228(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var229(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var230(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var231(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var232(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var233(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var234(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var235(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var236(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var237(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var238(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var239(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var240(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var241(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var242(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var243(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var244(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var245(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var246(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var247(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var248(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var249(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var250(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var251(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var252(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var253(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var254(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var255(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var256(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var257(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var258(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var259(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var260(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var261(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var262(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var263(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var264(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var265(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var266(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var267(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var268(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var269(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var270(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var271(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var272(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var273(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var274(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var275(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var276(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var277(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var278(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var279(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var280(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var281(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var282(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var283(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var284(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var285(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var286(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var287(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var288(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var289(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var290(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var291(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var292(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var293(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var294(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var295(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var296(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var297(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var298(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var299(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var300(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var301(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var302(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var303(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var304(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var305(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var306(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var307(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var308(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var309(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var310(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var311(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var312(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var313(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var314(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var315(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var316(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var317(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var318(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var319(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var320(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var321(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var322(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var323(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var324(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var325(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var326(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var327(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var328(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var329(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var330(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var331(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var332(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var333(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var334(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var335(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var336(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var337(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var338(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var339(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var340(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var341(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var342(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var343(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var344(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var345(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var346(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var347(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var348(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var349(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var350(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var351(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var352(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var353(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var354(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var355(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var356(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var357(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var358(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var359(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var360(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var361(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var362(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var363(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var364(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var365(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var366(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var367(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var368(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var369(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var370(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var371(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var372(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var373(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var374(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var375(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var376(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var377(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var378(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var379(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var380(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var381(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var382(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var383(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var384(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var385(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var386(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var387(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var388(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var389(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var390(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var391(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var392(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var393(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var394(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var395(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var396(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var397(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var398(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var399(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var400(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var401(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var402(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var403(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var404(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var405(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var406(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var407(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var408(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var409(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var410(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = bl_instructionVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = nop_instructionVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = hlt_instructionVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = bkpt_instructionVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = hvc_instructionVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = udf_instructionVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) = bl_instructionVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) = bx_instructionVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) = blx_instructionVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) = blx_instructionVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) = bx_instructionVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) = bx_instructionVar14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) = bx_instructionVar15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar16::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar17::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar18::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar19::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar20::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar21::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar22::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar23::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar24::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar25::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar26::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar27::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar28::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar29::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar30::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar31::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar32::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar33::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar34::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar35::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar36::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar37::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar38::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar39::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar40::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar41::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar42::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar43::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar44::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar45::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar46::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar47::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar48::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar49::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar50::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar51::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar52::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar53::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar54::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar55::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar56::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar57::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar58::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar59::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar60::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar61::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar62::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar63::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar64::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var64(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar65::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var65(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar66::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var66(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar67::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var67(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar68::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var68(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar69::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var69(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar70::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var70(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar71::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var71(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar72::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var72(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar73::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var73(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar74::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var74(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar75::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var75(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar76::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var76(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar77::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var77(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar78::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var78(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar79::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var79(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar80::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var80(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar81::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var81(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar82::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var82(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar83::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var83(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar84::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var84(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar85::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var85(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar86::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var86(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar87::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var87(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar88::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var88(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar89::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var89(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar90::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var90(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar91::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var91(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar92::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var92(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar93::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var93(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar94::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var94(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar95::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var95(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar96::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var96(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar97::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var97(parsed)));
        }
        if let Some((inst_len, parsed)) = mrs_instructionVar98::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var98(parsed)));
        }
        if let Some((inst_len, parsed)) = mrs_instructionVar99::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var99(parsed)));
        }
        if let Some((inst_len, parsed)) = clz_instructionVar100::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var100(parsed)));
        }
        if let Some((inst_len, parsed)) = msr_instructionVar101::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var101(parsed)));
        }
        if let Some((inst_len, parsed)) = msr_instructionVar102::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var102(parsed)));
        }
        if let Some((inst_len, parsed)) = qadd_instructionVar103::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var103(parsed)));
        }
        if let Some((inst_len, parsed)) = qdadd_instructionVar104::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var104(parsed)));
        }
        if let Some((inst_len, parsed)) = qdsub_instructionVar105::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var105(parsed)));
        }
        if let Some((inst_len, parsed)) = qsub_instructionVar106::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var106(parsed)));
        }
        if let Some((inst_len, parsed)) = swp_instructionVar107::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var107(parsed)));
        }
        if let Some((inst_len, parsed)) = swpb_instructionVar108::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var108(parsed)));
        }
        if let Some((inst_len, parsed)) = smc_instructionVar109::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var109(parsed)));
        }
        if let Some((inst_len, parsed)) = pld_instructionVar110::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var110(parsed)));
        }
        if let Some((inst_len, parsed)) = pld_instructionVar111::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var111(parsed)));
        }
        if let Some((inst_len, parsed)) = stc2_instructionVar112::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var112(parsed)));
        }
        if let Some((inst_len, parsed)) = stc2l_instructionVar113::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var113(parsed)));
        }
        if let Some((inst_len, parsed)) = smulw_instructionVar114::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var114(parsed)));
        }
        if let Some((inst_len, parsed)) = smul_instructionVar115::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var115(parsed)));
        }
        if let Some((inst_len, parsed)) = msr_instructionVar116::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var116(parsed)));
        }
        if let Some((inst_len, parsed)) = msr_instructionVar117::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var117(parsed)));
        }
        if let Some((inst_len, parsed)) = cmn_instructionVar118::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var118(parsed)));
        }
        if let Some((inst_len, parsed)) = cmn_instructionVar119::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var119(parsed)));
        }
        if let Some((inst_len, parsed)) = cmn_instructionVar120::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var120(parsed)));
        }
        if let Some((inst_len, parsed)) = cmp_instructionVar121::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var121(parsed)));
        }
        if let Some((inst_len, parsed)) = cmp_instructionVar122::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var122(parsed)));
        }
        if let Some((inst_len, parsed)) = cmp_instructionVar123::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var123(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar124::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var124(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar125::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var125(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar126::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var126(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar127::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var127(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar128::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var128(parsed)));
        }
        if let Some((inst_len, parsed)) = srsdb_instructionVar129::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var129(parsed)));
        }
        if let Some((inst_len, parsed)) = srsdb_instructionVar130::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var130(parsed)));
        }
        if let Some((inst_len, parsed)) = srsib_instructionVar131::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var131(parsed)));
        }
        if let Some((inst_len, parsed)) = srsia_instructionVar132::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var132(parsed)));
        }
        if let Some((inst_len, parsed)) = mul_instructionVar133::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var133(parsed)));
        }
        if let Some((inst_len, parsed)) = mvn_instructionVar134::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var134(parsed)));
        }
        if let Some((inst_len, parsed)) = mvn_instructionVar135::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var135(parsed)));
        }
        if let Some((inst_len, parsed)) = mvn_instructionVar136::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var136(parsed)));
        }
        if let Some((inst_len, parsed)) = teq_instructionVar137::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var137(parsed)));
        }
        if let Some((inst_len, parsed)) = teq_instructionVar138::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var138(parsed)));
        }
        if let Some((inst_len, parsed)) = teq_instructionVar139::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var139(parsed)));
        }
        if let Some((inst_len, parsed)) = teq_instructionVar140::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var140(parsed)));
        }
        if let Some((inst_len, parsed)) = teq_instructionVar141::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var141(parsed)));
        }
        if let Some((inst_len, parsed)) = teq_instructionVar142::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var142(parsed)));
        }
        if let Some((inst_len, parsed)) = tst_instructionVar143::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var143(parsed)));
        }
        if let Some((inst_len, parsed)) = tst_instructionVar144::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var144(parsed)));
        }
        if let Some((inst_len, parsed)) = tst_instructionVar145::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var145(parsed)));
        }
        if let Some((inst_len, parsed)) = adc_instructionVar146::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var146(parsed)));
        }
        if let Some((inst_len, parsed)) = adc_instructionVar147::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var147(parsed)));
        }
        if let Some((inst_len, parsed)) = adc_instructionVar148::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var148(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar149::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var149(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar150::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var150(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar151::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var151(parsed)));
        }
        if let Some((inst_len, parsed)) = and_instructionVar152::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var152(parsed)));
        }
        if let Some((inst_len, parsed)) = and_instructionVar153::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var153(parsed)));
        }
        if let Some((inst_len, parsed)) = and_instructionVar154::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var154(parsed)));
        }
        if let Some((inst_len, parsed)) = bic_instructionVar155::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var155(parsed)));
        }
        if let Some((inst_len, parsed)) = bic_instructionVar156::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var156(parsed)));
        }
        if let Some((inst_len, parsed)) = bic_instructionVar157::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var157(parsed)));
        }
        if let Some((inst_len, parsed)) = eor_instructionVar158::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var158(parsed)));
        }
        if let Some((inst_len, parsed)) = eor_instructionVar159::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var159(parsed)));
        }
        if let Some((inst_len, parsed)) = eor_instructionVar160::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var160(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar161::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var161(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar162::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var162(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar163::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var163(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar164::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var164(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar165::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var165(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar166::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var166(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar167::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var167(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar168::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var168(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar169::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var169(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar170::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var170(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar171::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var171(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar172::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var172(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar173::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var173(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar174::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var174(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar175::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var175(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar176::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var176(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar177::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var177(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar178::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var178(parsed)));
        }
        if let Some((inst_len, parsed)) = smlaw_instructionVar179::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var179(parsed)));
        }
        if let Some((inst_len, parsed)) = smla_instructionVar180::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var180(parsed)));
        }
        if let Some((inst_len, parsed)) = smlal_instructionVar181::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var181(parsed)));
        }
        if let Some((inst_len, parsed)) = mcrr_instructionVar182::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var182(parsed)));
        }
        if let Some((inst_len, parsed)) = mrrc_instructionVar183::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var183(parsed)));
        }
        if let Some((inst_len, parsed)) = mla_instructionVar184::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var184(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar185::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var185(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar186::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var186(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar187::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var187(parsed)));
        }
        if let Some((inst_len, parsed)) = mvn_instructionVar188::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var188(parsed)));
        }
        if let Some((inst_len, parsed)) = mvn_instructionVar189::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var189(parsed)));
        }
        if let Some((inst_len, parsed)) = mvn_instructionVar190::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var190(parsed)));
        }
        if let Some((inst_len, parsed)) = orr_instructionVar191::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var191(parsed)));
        }
        if let Some((inst_len, parsed)) = orr_instructionVar192::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var192(parsed)));
        }
        if let Some((inst_len, parsed)) = orr_instructionVar193::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var193(parsed)));
        }
        if let Some((inst_len, parsed)) = rsb_instructionVar194::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var194(parsed)));
        }
        if let Some((inst_len, parsed)) = rsb_instructionVar195::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var195(parsed)));
        }
        if let Some((inst_len, parsed)) = rsb_instructionVar196::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var196(parsed)));
        }
        if let Some((inst_len, parsed)) = rsc_instructionVar197::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var197(parsed)));
        }
        if let Some((inst_len, parsed)) = rsc_instructionVar198::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var198(parsed)));
        }
        if let Some((inst_len, parsed)) = rsc_instructionVar199::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var199(parsed)));
        }
        if let Some((inst_len, parsed)) = sbc_instructionVar200::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var200(parsed)));
        }
        if let Some((inst_len, parsed)) = sbc_instructionVar201::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var201(parsed)));
        }
        if let Some((inst_len, parsed)) = sbc_instructionVar202::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var202(parsed)));
        }
        if let Some((inst_len, parsed)) = smlal_instructionVar203::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var203(parsed)));
        }
        if let Some((inst_len, parsed)) = smull_instructionVar204::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var204(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar205::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var205(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar206::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var206(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar207::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var207(parsed)));
        }
        if let Some((inst_len, parsed)) = umlal_instructionVar208::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var208(parsed)));
        }
        if let Some((inst_len, parsed)) = umull_instructionVar209::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var209(parsed)));
        }
        if let Some((inst_len, parsed)) = adc_instructionVar210::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var210(parsed)));
        }
        if let Some((inst_len, parsed)) = adc_instructionVar211::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var211(parsed)));
        }
        if let Some((inst_len, parsed)) = adc_instructionVar212::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var212(parsed)));
        }
        if let Some((inst_len, parsed)) = adr_instructionVar213::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var213(parsed)));
        }
        if let Some((inst_len, parsed)) = adr_instructionVar214::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var214(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar215::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var215(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar216::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var216(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar217::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var217(parsed)));
        }
        if let Some((inst_len, parsed)) = and_instructionVar218::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var218(parsed)));
        }
        if let Some((inst_len, parsed)) = and_instructionVar219::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var219(parsed)));
        }
        if let Some((inst_len, parsed)) = and_instructionVar220::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var220(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr2_instructionVar221::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var221(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc2_instructionVar222::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var222(parsed)));
        }
        if let Some((inst_len, parsed)) = cdp2_instructionVar223::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var223(parsed)));
        }
        if let Some((inst_len, parsed)) = b_instructionVar224::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var224(parsed)));
        }
        if let Some((inst_len, parsed)) = bl_instructionVar225::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var225(parsed)));
        }
        if let Some((inst_len, parsed)) = blx_instructionVar226::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var226(parsed)));
        }
        if let Some((inst_len, parsed)) = blx_instructionVar227::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var227(parsed)));
        }
        if let Some((inst_len, parsed)) = blx_instructionVar228::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var228(parsed)));
        }
        if let Some((inst_len, parsed)) = blx_instructionVar229::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var229(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar230::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var230(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar231::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var231(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar232::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var232(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar233::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var233(parsed)));
        }
        if let Some((inst_len, parsed)) = cdp_instructionVar234::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var234(parsed)));
        }
        if let Some((inst_len, parsed)) = b_instructionVar235::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var235(parsed)));
        }
        if let Some((inst_len, parsed)) = bic_instructionVar236::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var236(parsed)));
        }
        if let Some((inst_len, parsed)) = bic_instructionVar237::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var237(parsed)));
        }
        if let Some((inst_len, parsed)) = bic_instructionVar238::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var238(parsed)));
        }
        if let Some((inst_len, parsed)) = bl_instructionVar239::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var239(parsed)));
        }
        if let Some((inst_len, parsed)) = bl_instructionVar240::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var240(parsed)));
        }
        if let Some((inst_len, parsed)) = eor_instructionVar241::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var241(parsed)));
        }
        if let Some((inst_len, parsed)) = eor_instructionVar242::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var242(parsed)));
        }
        if let Some((inst_len, parsed)) = eor_instructionVar243::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var243(parsed)));
        }
        if let Some((inst_len, parsed)) = ldc2_instructionVar244::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var244(parsed)));
        }
        if let Some((inst_len, parsed)) = ldc2l_instructionVar245::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var245(parsed)));
        }
        if let Some((inst_len, parsed)) = ldc_instructionVar246::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var246(parsed)));
        }
        if let Some((inst_len, parsed)) = ldcl_instructionVar247::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var247(parsed)));
        }
        if let Some((inst_len, parsed)) = ldm_instructionVar248::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var248(parsed)));
        }
        if let Some((inst_len, parsed)) = ldm_instructionVar249::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var249(parsed)));
        }
        if let Some((inst_len, parsed)) = ldr_instructionVar250::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var250(parsed)));
        }
        if let Some((inst_len, parsed)) = ldr_instructionVar251::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var251(parsed)));
        }
        if let Some((inst_len, parsed)) = ldr_instructionVar252::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var252(parsed)));
        }
        if let Some((inst_len, parsed)) = ldr_instructionVar253::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var253(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrbt_instructionVar254::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var254(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrt_instructionVar255::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var255(parsed)));
        }
        if let Some((inst_len, parsed)) = stc_instructionVar256::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var256(parsed)));
        }
        if let Some((inst_len, parsed)) = stcl_instructionVar257::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var257(parsed)));
        }
        if let Some((inst_len, parsed)) = strbt_instructionVar258::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var258(parsed)));
        }
        if let Some((inst_len, parsed)) = strt_instructionVar259::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var259(parsed)));
        }
        if let Some((inst_len, parsed)) = ldr_instructionVar260::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var260(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrb_instructionVar261::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var261(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrd_instructionVar262::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var262(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrh_instructionVar263::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var263(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrsb_instructionVar264::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var264(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrsh_instructionVar265::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var265(parsed)));
        }
        if let Some((inst_len, parsed)) = orr_instructionVar266::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var266(parsed)));
        }
        if let Some((inst_len, parsed)) = orr_instructionVar267::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var267(parsed)));
        }
        if let Some((inst_len, parsed)) = orr_instructionVar268::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var268(parsed)));
        }
        if let Some((inst_len, parsed)) = rsb_instructionVar269::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var269(parsed)));
        }
        if let Some((inst_len, parsed)) = rsb_instructionVar270::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var270(parsed)));
        }
        if let Some((inst_len, parsed)) = rsb_instructionVar271::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var271(parsed)));
        }
        if let Some((inst_len, parsed)) = rsc_instructionVar272::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var272(parsed)));
        }
        if let Some((inst_len, parsed)) = rsc_instructionVar273::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var273(parsed)));
        }
        if let Some((inst_len, parsed)) = rsc_instructionVar274::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var274(parsed)));
        }
        if let Some((inst_len, parsed)) = sbc_instructionVar275::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var275(parsed)));
        }
        if let Some((inst_len, parsed)) = sbc_instructionVar276::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var276(parsed)));
        }
        if let Some((inst_len, parsed)) = sbc_instructionVar277::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var277(parsed)));
        }
        if let Some((inst_len, parsed)) = strh_instructionVar278::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var278(parsed)));
        }
        if let Some((inst_len, parsed)) = strd_instructionVar279::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var279(parsed)));
        }
        if let Some((inst_len, parsed)) = stm_instructionVar280::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var280(parsed)));
        }
        if let Some((inst_len, parsed)) = str_instructionVar281::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var281(parsed)));
        }
        if let Some((inst_len, parsed)) = strb_instructionVar282::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var282(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar283::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var283(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar284::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var284(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar285::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var285(parsed)));
        }
        if let Some((inst_len, parsed)) = swi_instructionVar286::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var286(parsed)));
        }
        if let Some((inst_len, parsed)) = qadd_instructionVar287::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var287(parsed)));
        }
        if let Some((inst_len, parsed)) = qdadd_instructionVar288::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var288(parsed)));
        }
        if let Some((inst_len, parsed)) = qdsub_instructionVar289::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var289(parsed)));
        }
        if let Some((inst_len, parsed)) = qsub_instructionVar290::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var290(parsed)));
        }
        if let Some((inst_len, parsed)) = smmul_instructionVar291::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var291(parsed)));
        }
        if let Some((inst_len, parsed)) = smmulr_instructionVar292::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var292(parsed)));
        }
        if let Some((inst_len, parsed)) = smulbb_instructionVar293::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var293(parsed)));
        }
        if let Some((inst_len, parsed)) = smulbt_instructionVar294::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var294(parsed)));
        }
        if let Some((inst_len, parsed)) = smultb_instructionVar295::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var295(parsed)));
        }
        if let Some((inst_len, parsed)) = smultt_instructionVar296::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var296(parsed)));
        }
        if let Some((inst_len, parsed)) = smuad_instructionVar297::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var297(parsed)));
        }
        if let Some((inst_len, parsed)) = smusd_instructionVar298::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var298(parsed)));
        }
        if let Some((inst_len, parsed)) = smulw_instructionVar299::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var299(parsed)));
        }
        if let Some((inst_len, parsed)) = hvc_instructionVar300::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var300(parsed)));
        }
        if let Some((inst_len, parsed)) = smc_instructionVar301::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var301(parsed)));
        }
        if let Some((inst_len, parsed)) = udf_instructionVar302::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var302(parsed)));
        }
        if let Some((inst_len, parsed)) = pop_instructionVar303::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var303(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar304::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var304(parsed)));
        }
        if let Some((inst_len, parsed)) = nop_instructionVar305::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var305(parsed)));
        }
        if let Some((inst_len, parsed)) = nop_instructionVar306::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var306(parsed)));
        }
        if let Some((inst_len, parsed)) = pop_instructionVar307::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var307(parsed)));
        }
        if let Some((inst_len, parsed)) = push_instructionVar308::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var308(parsed)));
        }
        if let Some((inst_len, parsed)) = bx_instructionVar309::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var309(parsed)));
        }
        if let Some((inst_len, parsed)) = smlal_instructionVar310::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var310(parsed)));
        }
        if let Some((inst_len, parsed)) = smmla_instructionVar311::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var311(parsed)));
        }
        if let Some((inst_len, parsed)) = smmlar_instructionVar312::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var312(parsed)));
        }
        if let Some((inst_len, parsed)) = smmls_instructionVar313::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var313(parsed)));
        }
        if let Some((inst_len, parsed)) = smmlsr_instructionVar314::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var314(parsed)));
        }
        if let Some((inst_len, parsed)) = smull_instructionVar315::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var315(parsed)));
        }
        if let Some((inst_len, parsed)) = smlad_instructionVar316::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var316(parsed)));
        }
        if let Some((inst_len, parsed)) = smlald_instructionVar317::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var317(parsed)));
        }
        if let Some((inst_len, parsed)) = smlaw_instructionVar318::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var318(parsed)));
        }
        if let Some((inst_len, parsed)) = smlsd_instructionVar319::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var319(parsed)));
        }
        if let Some((inst_len, parsed)) = smlsld_instructionVar320::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var320(parsed)));
        }
        if let Some((inst_len, parsed)) = smla_instructionVar321::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var321(parsed)));
        }
        if let Some((inst_len, parsed)) = smlal_instructionVar322::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var322(parsed)));
        }
        if let Some((inst_len, parsed)) = mcrr_instructionVar323::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var323(parsed)));
        }
        if let Some((inst_len, parsed)) = mcrr_instructionVar324::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var324(parsed)));
        }
        if let Some((inst_len, parsed)) = adc_instructionVar325::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var325(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar326::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var326(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar327::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var327(parsed)));
        }
        if let Some((inst_len, parsed)) = and_instructionVar328::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var328(parsed)));
        }
        if let Some((inst_len, parsed)) = asr_instructionVar329::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var329(parsed)));
        }
        if let Some((inst_len, parsed)) = asr_instructionVar330::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var330(parsed)));
        }
        if let Some((inst_len, parsed)) = bic_instructionVar331::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var331(parsed)));
        }
        if let Some((inst_len, parsed)) = hlt_instructionVar332::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var332(parsed)));
        }
        if let Some((inst_len, parsed)) = cmn_instructionVar333::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var333(parsed)));
        }
        if let Some((inst_len, parsed)) = cmp_instructionVar334::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var334(parsed)));
        }
        if let Some((inst_len, parsed)) = eor_instructionVar335::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var335(parsed)));
        }
        if let Some((inst_len, parsed)) = lsl_instructionVar336::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var336(parsed)));
        }
        if let Some((inst_len, parsed)) = lsr_instructionVar337::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var337(parsed)));
        }
        if let Some((inst_len, parsed)) = lsr_instructionVar338::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var338(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar339::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var339(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar340::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var340(parsed)));
        }
        if let Some((inst_len, parsed)) = mul_instructionVar341::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var341(parsed)));
        }
        if let Some((inst_len, parsed)) = mvn_instructionVar342::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var342(parsed)));
        }
        if let Some((inst_len, parsed)) = orr_instructionVar343::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var343(parsed)));
        }
        if let Some((inst_len, parsed)) = rsb_instructionVar344::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var344(parsed)));
        }
        if let Some((inst_len, parsed)) = ror_instructionVar345::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var345(parsed)));
        }
        if let Some((inst_len, parsed)) = sbc_instructionVar346::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var346(parsed)));
        }
        if let Some((inst_len, parsed)) = tst_instructionVar347::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var347(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar348::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var348(parsed)));
        }
        if let Some((inst_len, parsed)) = blx_instructionVar349::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var349(parsed)));
        }
        if let Some((inst_len, parsed)) = bx_instructionVar350::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var350(parsed)));
        }
        if let Some((inst_len, parsed)) = bx_instructionVar351::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var351(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar352::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var352(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr2_instructionVar353::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var353(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar354::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var354(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar355::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var355(parsed)));
        }
        if let Some((inst_len, parsed)) = bkpt_instructionVar356::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var356(parsed)));
        }
        if let Some((inst_len, parsed)) = udf_instructionVar357::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var357(parsed)));
        }
        if let Some((inst_len, parsed)) = cmp_instructionVar358::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var358(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar359::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var359(parsed)));
        }
        if let Some((inst_len, parsed)) = pop_instructionVar360::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var360(parsed)));
        }
        if let Some((inst_len, parsed)) = pop_instructionVar361::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var361(parsed)));
        }
        if let Some((inst_len, parsed)) = push_instructionVar362::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var362(parsed)));
        }
        if let Some((inst_len, parsed)) = push_instructionVar363::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var363(parsed)));
        }
        if let Some((inst_len, parsed)) = svc_instructionVar364::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var364(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar365::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var365(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar366::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var366(parsed)));
        }
        if let Some((inst_len, parsed)) = blx_instructionVar367::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var367(parsed)));
        }
        if let Some((inst_len, parsed)) = blx_instructionVar368::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var368(parsed)));
        }
        if let Some((inst_len, parsed)) = bl_instructionVar369::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var369(parsed)));
        }
        if let Some((inst_len, parsed)) = blx_instructionVar370::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var370(parsed)));
        }
        if let Some((inst_len, parsed)) = bl_instructionVar371::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var371(parsed)));
        }
        if let Some((inst_len, parsed)) = blx_instructionVar372::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var372(parsed)));
        }
        if let Some((inst_len, parsed)) = cbnz_instructionVar373::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var373(parsed)));
        }
        if let Some((inst_len, parsed)) = cbz_instructionVar374::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var374(parsed)));
        }
        if let Some((inst_len, parsed)) = ldr_instructionVar375::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var375(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrb_instructionVar376::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var376(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrh_instructionVar377::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var377(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrsb_instructionVar378::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var378(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrsh_instructionVar379::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var379(parsed)));
        }
        if let Some((inst_len, parsed)) = str_instructionVar380::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var380(parsed)));
        }
        if let Some((inst_len, parsed)) = strb_instructionVar381::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var381(parsed)));
        }
        if let Some((inst_len, parsed)) = strh_instructionVar382::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var382(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar383::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var383(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar384::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var384(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar385::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var385(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar386::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var386(parsed)));
        }
        if let Some((inst_len, parsed)) = adr_instructionVar387::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var387(parsed)));
        }
        if let Some((inst_len, parsed)) = asr_instructionVar388::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var388(parsed)));
        }
        if let Some((inst_len, parsed)) = b_instructionVar389::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var389(parsed)));
        }
        if let Some((inst_len, parsed)) = bl_instructionVar390::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var390(parsed)));
        }
        if let Some((inst_len, parsed)) = bl_instructionVar391::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var391(parsed)));
        }
        if let Some((inst_len, parsed)) = cmp_instructionVar392::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var392(parsed)));
        }
        if let Some((inst_len, parsed)) = ldmia_instructionVar393::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var393(parsed)));
        }
        if let Some((inst_len, parsed)) = ldr_instructionVar394::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var394(parsed)));
        }
        if let Some((inst_len, parsed)) = ldr_instructionVar395::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var395(parsed)));
        }
        if let Some((inst_len, parsed)) = ldr_instructionVar396::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var396(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrb_instructionVar397::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var397(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrh_instructionVar398::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var398(parsed)));
        }
        if let Some((inst_len, parsed)) = lsl_instructionVar399::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var399(parsed)));
        }
        if let Some((inst_len, parsed)) = lsr_instructionVar400::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var400(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar401::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var401(parsed)));
        }
        if let Some((inst_len, parsed)) = stmia_instructionVar402::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var402(parsed)));
        }
        if let Some((inst_len, parsed)) = str_instructionVar403::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var403(parsed)));
        }
        if let Some((inst_len, parsed)) = str_instructionVar404::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var404(parsed)));
        }
        if let Some((inst_len, parsed)) = strb_instructionVar405::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var405(parsed)));
        }
        if let Some((inst_len, parsed)) = strh_instructionVar406::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var406(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar407::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var407(parsed)));
        }
        if let Some((inst_len, parsed)) = b_instructionVar408::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var408(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar409::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var409(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar410::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var410(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARM.sinc, start:241:1, end:241:7))"]
#[derive(Clone, Debug)]
struct ItCondVar0 {}
impl ItCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableItCond {
    Var0(ItCondVar0),
}
impl TableItCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ItCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARM.sinc, start:242:1, end:242:15))"]
#[derive(Clone, Debug)]
struct CheckInIT_CZNOVar0 {}
impl CheckInIT_CZNOVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCheckInIT_CZNO {
    Var0(CheckInIT_CZNOVar0),
}
impl TableCheckInIT_CZNO {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = CheckInIT_CZNOVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARM.sinc, start:243:1, end:243:14))"]
#[derive(Clone, Debug)]
struct CheckInIT_CZNVar0 {}
impl CheckInIT_CZNVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCheckInIT_CZN {
    Var0(CheckInIT_CZNVar0),
}
impl TableCheckInIT_CZN {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = CheckInIT_CZNVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARM.sinc, start:244:1, end:244:13))"]
#[derive(Clone, Debug)]
struct CheckInIT_ZNVar0 {}
impl CheckInIT_ZNVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCheckInIT_ZN {
    Var0(CheckInIT_ZNVar0),
}
impl TableCheckInIT_ZN {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = CheckInIT_ZNVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:626:1, end:626:3))"]
#[derive(Clone, Debug)]
struct rnVar0 {}
impl rnVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:627:1, end:627:3))"]
#[derive(Clone, Debug)]
struct rnVar1 {
    Rn: TokenField_Rn,
}
impl rnVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rn.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let Rn = token_parser.TokenFieldRn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn }))
    }
}
#[derive(Clone, Debug)]
enum Tablern {
    Var0(rnVar0),
    Var1(rnVar1),
}
impl Tablern {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            rnVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            rnVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:629:1, end:629:3))"]
#[derive(Clone, Debug)]
struct rmVar0 {}
impl rmVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldRm().disassembly() != 15i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:630:1, end:630:3))"]
#[derive(Clone, Debug)]
struct rmVar1 {
    Rm: TokenField_Rm,
}
impl rmVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rm.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let Rm = token_parser.TokenFieldRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rm }))
    }
}
#[derive(Clone, Debug)]
enum Tablerm {
    Var0(rmVar0),
    Var1(rmVar1),
}
impl Tablerm {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            rmVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            rmVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:632:1, end:632:3))"]
#[derive(Clone, Debug)]
struct rsVar0 {}
impl rsVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldRs().disassembly() != 15i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:633:1, end:633:3))"]
#[derive(Clone, Debug)]
struct rsVar1 {
    Rs: TokenField_Rs,
}
impl rsVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rs.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let Rs = token_parser.TokenFieldRs();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rs }))
    }
}
#[derive(Clone, Debug)]
enum Tablers {
    Var0(rsVar0),
    Var1(rsVar1),
}
impl Tablers {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            rsVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            rsVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:635:1, end:635:3))"]
#[derive(Clone, Debug)]
struct ccVar0 {}
impl ccVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:636:1, end:636:3))"]
#[derive(Clone, Debug)]
struct ccVar1 {}
impl ccVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:637:1, end:637:3))"]
#[derive(Clone, Debug)]
struct ccVar2 {}
impl ccVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:638:1, end:638:3))"]
#[derive(Clone, Debug)]
struct ccVar3 {}
impl ccVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cc")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:639:1, end:639:3))"]
#[derive(Clone, Debug)]
struct ccVar4 {}
impl ccVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mi")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:640:1, end:640:3))"]
#[derive(Clone, Debug)]
struct ccVar5 {}
impl ccVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("pl")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:641:1, end:641:3))"]
#[derive(Clone, Debug)]
struct ccVar6 {}
impl ccVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("vs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 6i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:642:1, end:642:3))"]
#[derive(Clone, Debug)]
struct ccVar7 {}
impl ccVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("vc")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 7i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:643:1, end:643:3))"]
#[derive(Clone, Debug)]
struct ccVar8 {}
impl ccVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("hi")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 8i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:644:1, end:644:3))"]
#[derive(Clone, Debug)]
struct ccVar9 {}
impl ccVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ls")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 9i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:645:1, end:645:3))"]
#[derive(Clone, Debug)]
struct ccVar10 {}
impl ccVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 10i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:646:1, end:646:3))"]
#[derive(Clone, Debug)]
struct ccVar11 {}
impl ccVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 11i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:647:1, end:647:3))"]
#[derive(Clone, Debug)]
struct ccVar12 {}
impl ccVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 12i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:648:1, end:648:3))"]
#[derive(Clone, Debug)]
struct ccVar13 {}
impl ccVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 13i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablecc {
    Var0(ccVar0),
    Var1(ccVar1),
    Var2(ccVar2),
    Var3(ccVar3),
    Var4(ccVar4),
    Var5(ccVar5),
    Var6(ccVar6),
    Var7(ccVar7),
    Var8(ccVar8),
    Var9(ccVar9),
    Var10(ccVar10),
    Var11(ccVar11),
    Var12(ccVar12),
    Var13(ccVar13),
}
impl Tablecc {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ccVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:651:1, end:651:5))"]
#[derive(Clone, Debug)]
struct CONDVar0 {}
impl CONDVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 14i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:650:1, end:650:5))"]
#[derive(Clone, Debug)]
struct CONDVar1 {
    cc: Tablecc,
}
impl CONDVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.cc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cc }))
    }
}
#[derive(Clone, Debug)]
enum TableCOND {
    Var0(CONDVar0),
    Var1(CONDVar1),
}
impl TableCOND {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CONDVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CONDVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:659:1, end:659:10))"]
#[derive(Clone, Debug)]
struct SBIT_CZNOVar0 {}
impl SBIT_CZNOVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldS20().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:660:1, end:660:10))"]
#[derive(Clone, Debug)]
struct SBIT_CZNOVar1 {}
impl SBIT_CZNOVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("s")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldS20().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSBIT_CZNO {
    Var0(SBIT_CZNOVar0),
    Var1(SBIT_CZNOVar1),
}
impl TableSBIT_CZNO {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SBIT_CZNOVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SBIT_CZNOVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:661:1, end:661:8))"]
#[derive(Clone, Debug)]
struct SBIT_ZNVar0 {}
impl SBIT_ZNVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldS20().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:662:1, end:662:8))"]
#[derive(Clone, Debug)]
struct SBIT_ZNVar1 {}
impl SBIT_ZNVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("s")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldS20().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSBIT_ZN {
    Var0(SBIT_ZNVar0),
    Var1(SBIT_ZNVar1),
}
impl TableSBIT_ZN {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SBIT_ZNVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SBIT_ZNVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:664:1, end:664:7))"]
#[derive(Clone, Debug)]
struct Addr24Var0 {
    addr24: TokenField_addr24,
}
impl Addr24Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_next)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(4i128.wrapping_mul(self.addr24.disassembly()));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let addr24 = token_parser.TokenFieldaddr24();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr24 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr24 {
    Var0(Addr24Var0),
}
impl TableAddr24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Addr24Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:669:1, end:669:8))"]
#[derive(Clone, Debug)]
struct HAddr24Var0 {
    addr24: TokenField_addr24,
    H24: TokenField_H24,
}
impl HAddr24Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = (i128::try_from(inst_next)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(4i128.wrapping_mul(self.addr24.disassembly()))
            .wrapping_add(2i128.wrapping_mul(self.H24.disassembly()))
            & 4294967295i128);
        global_set.set_TMode(
            Some(u32::try_from(calc_reloc).unwrap()),
            context.register().read_TMode_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let addr24 = token_parser.TokenFieldaddr24();
        let H24 = token_parser.TokenFieldH24();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr24, H24 }))
    }
}
#[derive(Clone, Debug)]
enum TableHAddr24 {
    Var0(HAddr24Var0),
}
impl TableHAddr24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            HAddr24Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:676:1, end:676:5))"]
#[derive(Clone, Debug)]
struct XBITVar0 {}
impl XBITVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldx().disassembly() != 0i128 {
            return None;
        }
        let smRn = token_parser.TokenFieldsmRn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:677:1, end:677:5))"]
#[derive(Clone, Debug)]
struct XBITVar1 {}
impl XBITVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldx().disassembly() != 1i128 {
            return None;
        }
        let smRn = token_parser.TokenFieldsmRn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableXBIT {
    Var0(XBITVar0),
    Var1(XBITVar1),
}
impl TableXBIT {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            XBITVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            XBITVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:679:1, end:679:5))"]
#[derive(Clone, Debug)]
struct YBITVar0 {}
impl YBITVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldy().disassembly() != 0i128 {
            return None;
        }
        let smRm = token_parser.TokenFieldsmRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:680:1, end:680:5))"]
#[derive(Clone, Debug)]
struct YBITVar1 {}
impl YBITVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldy().disassembly() != 1i128 {
            return None;
        }
        let smRm = token_parser.TokenFieldsmRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableYBIT {
    Var0(YBITVar0),
    Var1(YBITVar1),
}
impl TableYBIT {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            YBITVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            YBITVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:690:1, end:690:7))"]
#[derive(Clone, Debug)]
struct shift1Var0 {
    immed: TokenField_immed,
    rotate: TokenField_rotate,
}
impl shift1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_value: i128 = 0;
        calc_value = ((u32::try_from(
            32i128.wrapping_sub(self.rotate.disassembly().wrapping_mul(2i128)),
        )
        .ok()
        .map(|shl| self.immed.disassembly().checked_shl(shl))
        .flatten()
        .unwrap_or(0)
            | u32::try_from(self.rotate.disassembly().wrapping_mul(2i128))
                .ok()
                .map(|shr| self.immed.disassembly().checked_shr(shr))
                .flatten()
                .unwrap_or(0))
            & 4294967295i128);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Number(true, calc_value),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_value: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        calc_value = ((u32::try_from(
            32i128.wrapping_sub(
                token_parser
                    .TokenFieldrotate()
                    .disassembly()
                    .wrapping_mul(2i128),
            ),
        )
        .ok()
        .map(|shl| {
            token_parser
                .TokenFieldimmed()
                .disassembly()
                .checked_shl(shl)
        })
        .flatten()
        .unwrap_or(0)
            | u32::try_from(
                token_parser
                    .TokenFieldrotate()
                    .disassembly()
                    .wrapping_mul(2i128),
            )
            .ok()
            .map(|shr| {
                token_parser
                    .TokenFieldimmed()
                    .disassembly()
                    .checked_shr(shr)
            })
            .flatten()
            .unwrap_or(0))
            & 4294967295i128);
        let immed = token_parser.TokenFieldimmed();
        let rotate = token_parser.TokenFieldrotate();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed, rotate }))
    }
}
#[derive(Clone, Debug)]
enum Tableshift1 {
    Var0(shift1Var0),
}
impl Tableshift1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            shift1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:803:1, end:803:12))"]
#[derive(Clone, Debug)]
struct mcrOperandsVar0 {
    cpn: TokenField_cpn,
    opc1: TokenField_opc1,
    Rd: TokenField_Rd,
    CRn: TokenField_CRn,
    CRm: TokenField_CRm,
    opc2: TokenField_opc2,
}
impl mcrOperandsVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 11usize] = [
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.opc1.display(),
            DisplayElement::Literal(","),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.CRn.display(),
            DisplayElement::Literal(","),
            self.CRm.display(),
            DisplayElement::Literal(","),
            self.opc2.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let CRm = token_parser.TokenFieldCRm();
        let opc2 = token_parser.TokenFieldopc2();
        let cpn = token_parser.TokenFieldcpn();
        let CRn = token_parser.TokenFieldCRn();
        let opc1 = token_parser.TokenFieldopc1();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CRm,
                opc2,
                cpn,
                CRn,
                opc1,
                Rd,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TablemcrOperands {
    Var0(mcrOperandsVar0),
}
impl TablemcrOperands {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = mcrOperandsVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:809:1, end:809:7))"]
#[derive(Clone, Debug)]
struct shift2Var0 {
    rm: Tablerm,
}
impl shift2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:819:1, end:819:7))"]
#[derive(Clone, Debug)]
struct shift2Var1 {
    rm: Tablerm,
}
impl shift2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("lsr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 2i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:829:1, end:829:7))"]
#[derive(Clone, Debug)]
struct shift2Var2 {
    rm: Tablerm,
}
impl shift2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("asr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 4i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:839:1, end:839:7))"]
#[derive(Clone, Debug)]
struct shift2Var3 {
    rm: Tablerm,
}
impl shift2Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("rrx"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0411().disassembly() != 6i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:814:1, end:814:7))"]
#[derive(Clone, Debug)]
struct shift2Var4 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl shift2Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("lsl"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:824:1, end:824:7))"]
#[derive(Clone, Debug)]
struct shift2Var5 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl shift2Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("lsr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 2i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:834:1, end:834:7))"]
#[derive(Clone, Debug)]
struct shift2Var6 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl shift2Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("asr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 4i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:844:1, end:844:7))"]
#[derive(Clone, Debug)]
struct shift2Var7 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl shift2Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("ror"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 6i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[derive(Clone, Debug)]
enum Tableshift2 {
    Var0(shift2Var0),
    Var1(shift2Var1),
    Var2(shift2Var2),
    Var3(shift2Var3),
    Var4(shift2Var4),
    Var5(shift2Var5),
    Var6(shift2Var6),
    Var7(shift2Var7),
}
impl Tableshift2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            shift2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift2Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift2Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift2Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift2Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift2Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:853:1, end:853:7))"]
#[derive(Clone, Debug)]
struct shift3Var0 {
    rs: Tablers,
    rm: Tablerm,
}
impl shift3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("lsl"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 1i128 {
            return None;
        }
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:858:1, end:858:7))"]
#[derive(Clone, Debug)]
struct shift3Var1 {
    rs: Tablers,
    rm: Tablerm,
}
impl shift3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("lsr"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 3i128 {
            return None;
        }
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:863:1, end:863:7))"]
#[derive(Clone, Debug)]
struct shift3Var2 {
    rs: Tablers,
    rm: Tablerm,
}
impl shift3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("asr"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 5i128 {
            return None;
        }
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:868:1, end:868:7))"]
#[derive(Clone, Debug)]
struct shift3Var3 {
    rs: Tablers,
    rm: Tablerm,
}
impl shift3Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("ror"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 7i128 {
            return None;
        }
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs, rm }))
    }
}
#[derive(Clone, Debug)]
enum Tableshift3 {
    Var0(shift3Var0),
    Var1(shift3Var1),
    Var2(shift3Var2),
    Var3(shift3Var3),
}
impl Tableshift3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            shift3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift3Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:940:1, end:940:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar0 {
    rm: Tablerm,
}
impl addr2shiftVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0411().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:943:1, end:943:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar1 {
    rm: Tablerm,
}
impl addr2shiftVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",lsr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldshft().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:945:1, end:945:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar2 {
    rm: Tablerm,
}
impl addr2shiftVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",asr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldshft().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:947:1, end:947:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar3 {
    rm: Tablerm,
}
impl addr2shiftVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",rrx")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldshft().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:941:1, end:941:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar4 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl addr2shiftVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(",lsl"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldshft().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:942:1, end:942:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar5 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl addr2shiftVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(",lsr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldshft().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:944:1, end:944:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar6 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl addr2shiftVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(",asr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldshft().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:946:1, end:946:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar7 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl addr2shiftVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(",ror"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldshft().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddr2shift {
    Var0(addr2shiftVar0),
    Var1(addr2shiftVar1),
    Var2(addr2shiftVar2),
    Var3(addr2shiftVar3),
    Var4(addr2shiftVar4),
    Var5(addr2shiftVar5),
    Var6(addr2shiftVar6),
    Var7(addr2shiftVar7),
}
impl Tableaddr2shift {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = addr2shiftVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = addr2shiftVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = addr2shiftVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = addr2shiftVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = addr2shiftVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = addr2shiftVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = addr2shiftVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = addr2shiftVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:951:1, end:951:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var0 {
    offset_12: TokenField_offset_12,
}
impl addrmode2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(self.offset_12.disassembly());
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Number(true, calc_reloff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(token_parser.TokenFieldoffset_12().disassembly());
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:957:1, end:957:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var1 {
    offset_12: TokenField_offset_12,
}
impl addrmode2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128.wrapping_sub(self.offset_12.disassembly()));
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Number(true, calc_reloff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128.wrapping_sub(
                token_parser.TokenFieldoffset_12().disassembly(),
            ));
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:963:1, end:963:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var2 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            self.offset_12.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:964:1, end:964:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var3 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff: i128 = 0;
        calc_noff = (-self.offset_12.disassembly());
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_noff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        calc_noff = (-token_parser.TokenFieldoffset_12().disassembly());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:965:1, end:965:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var4 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:966:1, end:966:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var5 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",-")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:968:1, end:968:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var6 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            self.offset_12.display(),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:969:1, end:969:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var7 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff: i128 = 0;
        calc_noff = (-self.offset_12.disassembly());
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_noff),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        calc_noff = (-token_parser.TokenFieldoffset_12().disassembly());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:970:1, end:970:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var8 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:971:1, end:971:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var9 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",-")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:973:1, end:973:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var10 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("],#"), self.offset_12.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:974:1, end:974:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var11 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff: i128 = 0;
        calc_noff = (-self.offset_12.disassembly());
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("],#"),
            DisplayElement::Number(true, calc_noff),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        calc_noff = (-token_parser.TokenFieldoffset_12().disassembly());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:975:1, end:975:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var12 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:976:1, end:976:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var13 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],-")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:978:1, end:978:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var14 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("],#"), self.offset_12.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:979:1, end:979:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var15 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff: i128 = 0;
        calc_noff = (-self.offset_12.disassembly());
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("],#"),
            DisplayElement::Number(true, calc_noff),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        calc_noff = (-token_parser.TokenFieldoffset_12().disassembly());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:980:1, end:980:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var16 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:981:1, end:981:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var17 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],-")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrmode2 {
    Var0(addrmode2Var0),
    Var1(addrmode2Var1),
    Var2(addrmode2Var2),
    Var3(addrmode2Var3),
    Var4(addrmode2Var4),
    Var5(addrmode2Var5),
    Var6(addrmode2Var6),
    Var7(addrmode2Var7),
    Var8(addrmode2Var8),
    Var9(addrmode2Var9),
    Var10(addrmode2Var10),
    Var11(addrmode2Var11),
    Var12(addrmode2Var12),
    Var13(addrmode2Var13),
    Var14(addrmode2Var14),
    Var15(addrmode2Var15),
    Var16(addrmode2Var16),
    Var17(addrmode2Var17),
}
impl Tableaddrmode2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            addrmode2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var16::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var17::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:990:1, end:990:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var0 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
}
impl addrmode3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                (u32::try_from(4i128)
                    .ok()
                    .map(|shl| self.immedH.disassembly().checked_shl(shl))
                    .flatten()
                    .unwrap_or(0)
                    | self.immedL.disassembly()),
            );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Number(true, calc_reloff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                (u32::try_from(4i128)
                    .ok()
                    .map(|shl| {
                        token_parser
                            .TokenFieldimmedH()
                            .disassembly()
                            .checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0)
                    | token_parser.TokenFieldimmedL().disassembly()),
            );
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:996:1, end:996:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var1 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
}
impl addrmode3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                (u32::try_from(4i128)
                    .ok()
                    .map(|shl| self.immedH.disassembly().checked_shl(shl))
                    .flatten()
                    .unwrap_or(0)
                    | self.immedL.disassembly()),
            ),
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Number(true, calc_reloff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                (u32::try_from(4i128)
                    .ok()
                    .map(|shl| {
                        token_parser
                            .TokenFieldimmedH()
                            .disassembly()
                            .checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0)
                    | token_parser.TokenFieldimmedL().disassembly()),
            ),
        );
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1014:1, end:1014:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var2 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1019:1, end:1019:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var3 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",-")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1036:1, end:1036:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var4 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1041:1, end:1041:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var5 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",-")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1002:1, end:1002:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var6 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
    rn: Tablern,
}
impl addrmode3Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off8: i128 = 0;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .map(|shl| self.immedH.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.immedL.disassembly());
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_off8),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 2i128 {
            return None;
        }
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldimmedH()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimmedL().disassembly());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1008:1, end:1008:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var7 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
    rn: Tablern,
}
impl addrmode3Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .map(|shl| self.immedH.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.immedL.disassembly()));
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_noff8),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 2i128 {
            return None;
        }
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldimmedH()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimmedL().disassembly()));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1024:1, end:1024:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var8 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
    rn: Tablern,
}
impl addrmode3Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off8: i128 = 0;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .map(|shl| self.immedH.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.immedL.disassembly());
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_off8),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 3i128 {
            return None;
        }
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldimmedH()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimmedL().disassembly());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1030:1, end:1030:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var9 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
    rn: Tablern,
}
impl addrmode3Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .map(|shl| self.immedH.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.immedL.disassembly()));
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_noff8),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 3i128 {
            return None;
        }
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldimmedH()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimmedL().disassembly()));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1058:1, end:1058:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var10 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2222().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1063:1, end:1063:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var11 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],-")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2222().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1046:1, end:1046:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var12 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
    rn: Tablern,
}
impl addrmode3Var12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off8: i128 = 0;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .map(|shl| self.immedH.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.immedL.disassembly());
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("],#"),
            DisplayElement::Number(true, calc_off8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2222().disassembly() != 1i128 {
            return None;
        }
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldimmedH()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimmedL().disassembly());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1052:1, end:1052:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var13 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
    rn: Tablern,
}
impl addrmode3Var13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .map(|shl| self.immedH.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.immedL.disassembly()));
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("],#"),
            DisplayElement::Number(true, calc_noff8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2222().disassembly() != 1i128 {
            return None;
        }
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldimmedH()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimmedL().disassembly()));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrmode3 {
    Var0(addrmode3Var0),
    Var1(addrmode3Var1),
    Var2(addrmode3Var2),
    Var3(addrmode3Var3),
    Var4(addrmode3Var4),
    Var5(addrmode3Var5),
    Var6(addrmode3Var6),
    Var7(addrmode3Var7),
    Var8(addrmode3Var8),
    Var9(addrmode3Var9),
    Var10(addrmode3Var10),
    Var11(addrmode3Var11),
    Var12(addrmode3Var12),
    Var13(addrmode3Var13),
}
impl Tableaddrmode3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            addrmode3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode3Var10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode3Var11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode3Var12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode3Var13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1074:1, end:1074:7))"]
#[derive(Clone, Debug)]
struct linc15Var0 {}
impl linc15Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1075:1, end:1075:7))"]
#[derive(Clone, Debug)]
struct linc15Var1 {}
impl linc15Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc15 {
    Var0(linc15Var0),
    Var1(linc15Var1),
}
impl Tablelinc15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc15Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc15Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1077:1, end:1077:7))"]
#[derive(Clone, Debug)]
struct linc14Var0 {}
impl linc14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0000().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1076:1, end:1076:7))"]
#[derive(Clone, Debug)]
struct linc14Var1 {
    linc15: Tablelinc15,
}
impl linc14Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        let linc15 = if let Some((len, table)) = Tablelinc15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1078:1, end:1078:7))"]
#[derive(Clone, Debug)]
struct linc14Var2 {
    linc15: Tablelinc15,
}
impl linc14Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 0i128 {
            return None;
        }
        let linc15 = if let Some((len, table)) = Tablelinc15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc14 {
    Var0(linc14Var0),
    Var1(linc14Var1),
    Var2(linc14Var2),
}
impl Tablelinc14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc14Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc14Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc14Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1080:1, end:1080:7))"]
#[derive(Clone, Debug)]
struct linc13Var0 {}
impl linc13Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0001().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1079:1, end:1079:7))"]
#[derive(Clone, Debug)]
struct linc13Var1 {
    linc14: Tablelinc14,
}
impl linc13Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        let linc14 = if let Some((len, table)) = Tablelinc14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1081:1, end:1081:7))"]
#[derive(Clone, Debug)]
struct linc13Var2 {
    linc14: Tablelinc14,
}
impl linc13Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 0i128 {
            return None;
        }
        let linc14 = if let Some((len, table)) = Tablelinc14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc13 {
    Var0(linc13Var0),
    Var1(linc13Var1),
    Var2(linc13Var2),
}
impl Tablelinc13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc13Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc13Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc13Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1083:1, end:1083:7))"]
#[derive(Clone, Debug)]
struct linc12Var0 {}
impl linc12Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0002().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1082:1, end:1082:7))"]
#[derive(Clone, Debug)]
struct linc12Var1 {
    linc13: Tablelinc13,
}
impl linc12Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        let linc13 = if let Some((len, table)) = Tablelinc13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1084:1, end:1084:7))"]
#[derive(Clone, Debug)]
struct linc12Var2 {
    linc13: Tablelinc13,
}
impl linc12Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 0i128 {
            return None;
        }
        let linc13 = if let Some((len, table)) = Tablelinc13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc12 {
    Var0(linc12Var0),
    Var1(linc12Var1),
    Var2(linc12Var2),
}
impl Tablelinc12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc12Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc12Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc12Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1086:1, end:1086:7))"]
#[derive(Clone, Debug)]
struct linc11Var0 {}
impl linc11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0003().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1085:1, end:1085:7))"]
#[derive(Clone, Debug)]
struct linc11Var1 {
    linc12: Tablelinc12,
}
impl linc11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        let linc12 = if let Some((len, table)) = Tablelinc12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1087:1, end:1087:7))"]
#[derive(Clone, Debug)]
struct linc11Var2 {
    linc12: Tablelinc12,
}
impl linc11Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let linc12 = if let Some((len, table)) = Tablelinc12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc11 {
    Var0(linc11Var0),
    Var1(linc11Var1),
    Var2(linc11Var2),
}
impl Tablelinc11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc11Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc11Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1089:1, end:1089:7))"]
#[derive(Clone, Debug)]
struct linc10Var0 {}
impl linc10Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0004().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1088:1, end:1088:7))"]
#[derive(Clone, Debug)]
struct linc10Var1 {
    linc11: Tablelinc11,
}
impl linc10Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        let linc11 = if let Some((len, table)) = Tablelinc11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1090:1, end:1090:7))"]
#[derive(Clone, Debug)]
struct linc10Var2 {
    linc11: Tablelinc11,
}
impl linc10Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 0i128 {
            return None;
        }
        let linc11 = if let Some((len, table)) = Tablelinc11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc10 {
    Var0(linc10Var0),
    Var1(linc10Var1),
    Var2(linc10Var2),
}
impl Tablelinc10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc10Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc10Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc10Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1092:1, end:1092:6))"]
#[derive(Clone, Debug)]
struct linc9Var0 {}
impl linc9Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0005().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1091:1, end:1091:6))"]
#[derive(Clone, Debug)]
struct linc9Var1 {
    linc10: Tablelinc10,
}
impl linc9Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        let linc10 = if let Some((len, table)) = Tablelinc10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1093:1, end:1093:6))"]
#[derive(Clone, Debug)]
struct linc9Var2 {
    linc10: Tablelinc10,
}
impl linc9Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 0i128 {
            return None;
        }
        let linc10 = if let Some((len, table)) = Tablelinc10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc9 {
    Var0(linc9Var0),
    Var1(linc9Var1),
    Var2(linc9Var2),
}
impl Tablelinc9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc9Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc9Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc9Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1095:1, end:1095:6))"]
#[derive(Clone, Debug)]
struct linc8Var0 {}
impl linc8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0006().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1094:1, end:1094:6))"]
#[derive(Clone, Debug)]
struct linc8Var1 {
    linc9: Tablelinc9,
}
impl linc8Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r7),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        let linc9 = if let Some((len, table)) =
            Tablelinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1096:1, end:1096:6))"]
#[derive(Clone, Debug)]
struct linc8Var2 {
    linc9: Tablelinc9,
}
impl linc8Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 0i128 {
            return None;
        }
        let linc9 = if let Some((len, table)) =
            Tablelinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc8 {
    Var0(linc8Var0),
    Var1(linc8Var1),
    Var2(linc8Var2),
}
impl Tablelinc8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc8Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc8Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1098:1, end:1098:6))"]
#[derive(Clone, Debug)]
struct linc7Var0 {}
impl linc7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0007().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1097:1, end:1097:6))"]
#[derive(Clone, Debug)]
struct linc7Var1 {
    linc8: Tablelinc8,
}
impl linc7Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        let linc8 = if let Some((len, table)) =
            Tablelinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1099:1, end:1099:6))"]
#[derive(Clone, Debug)]
struct linc7Var2 {
    linc8: Tablelinc8,
}
impl linc7Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 0i128 {
            return None;
        }
        let linc8 = if let Some((len, table)) =
            Tablelinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc7 {
    Var0(linc7Var0),
    Var1(linc7Var1),
    Var2(linc7Var2),
}
impl Tablelinc7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc7Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc7Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1101:1, end:1101:6))"]
#[derive(Clone, Debug)]
struct linc6Var0 {}
impl linc6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0008().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1100:1, end:1100:6))"]
#[derive(Clone, Debug)]
struct linc6Var1 {
    linc7: Tablelinc7,
}
impl linc6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r9),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        let linc7 = if let Some((len, table)) =
            Tablelinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1102:1, end:1102:6))"]
#[derive(Clone, Debug)]
struct linc6Var2 {
    linc7: Tablelinc7,
}
impl linc6Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 0i128 {
            return None;
        }
        let linc7 = if let Some((len, table)) =
            Tablelinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc6 {
    Var0(linc6Var0),
    Var1(linc6Var1),
    Var2(linc6Var2),
}
impl Tablelinc6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc6Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1104:1, end:1104:6))"]
#[derive(Clone, Debug)]
struct linc5Var0 {}
impl linc5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0009().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1103:1, end:1103:6))"]
#[derive(Clone, Debug)]
struct linc5Var1 {
    linc6: Tablelinc6,
}
impl linc5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r10),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        let linc6 = if let Some((len, table)) =
            Tablelinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1105:1, end:1105:6))"]
#[derive(Clone, Debug)]
struct linc5Var2 {
    linc6: Tablelinc6,
}
impl linc5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 0i128 {
            return None;
        }
        let linc6 = if let Some((len, table)) =
            Tablelinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc5 {
    Var0(linc5Var0),
    Var1(linc5Var1),
    Var2(linc5Var2),
}
impl Tablelinc5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1107:1, end:1107:6))"]
#[derive(Clone, Debug)]
struct linc4Var0 {}
impl linc4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0010().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1106:1, end:1106:6))"]
#[derive(Clone, Debug)]
struct linc4Var1 {
    linc5: Tablelinc5,
}
impl linc4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r11),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        let linc5 = if let Some((len, table)) =
            Tablelinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1108:1, end:1108:6))"]
#[derive(Clone, Debug)]
struct linc4Var2 {
    linc5: Tablelinc5,
}
impl linc4Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 0i128 {
            return None;
        }
        let linc5 = if let Some((len, table)) =
            Tablelinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc4 {
    Var0(linc4Var0),
    Var1(linc4Var1),
    Var2(linc4Var2),
}
impl Tablelinc4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc4Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1110:1, end:1110:6))"]
#[derive(Clone, Debug)]
struct linc3Var0 {}
impl linc3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0011().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1109:1, end:1109:6))"]
#[derive(Clone, Debug)]
struct linc3Var1 {
    linc4: Tablelinc4,
}
impl linc3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r12),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        let linc4 = if let Some((len, table)) =
            Tablelinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1111:1, end:1111:6))"]
#[derive(Clone, Debug)]
struct linc3Var2 {
    linc4: Tablelinc4,
}
impl linc3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 0i128 {
            return None;
        }
        let linc4 = if let Some((len, table)) =
            Tablelinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc3 {
    Var0(linc3Var0),
    Var1(linc3Var1),
    Var2(linc3Var2),
}
impl Tablelinc3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1113:1, end:1113:6))"]
#[derive(Clone, Debug)]
struct linc2Var0 {}
impl linc2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0012().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1112:1, end:1112:6))"]
#[derive(Clone, Debug)]
struct linc2Var1 {
    linc3: Tablelinc3,
}
impl linc2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::sp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        let linc3 = if let Some((len, table)) =
            Tablelinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1114:1, end:1114:6))"]
#[derive(Clone, Debug)]
struct linc2Var2 {
    linc3: Tablelinc3,
}
impl linc2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 0i128 {
            return None;
        }
        let linc3 = if let Some((len, table)) =
            Tablelinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc2 {
    Var0(linc2Var0),
    Var1(linc2Var1),
    Var2(linc2Var2),
}
impl Tablelinc2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1116:1, end:1116:6))"]
#[derive(Clone, Debug)]
struct linc1Var0 {}
impl linc1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0013().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1115:1, end:1115:6))"]
#[derive(Clone, Debug)]
struct linc1Var1 {
    linc2: Tablelinc2,
}
impl linc1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        let linc2 = if let Some((len, table)) =
            Tablelinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1117:1, end:1117:6))"]
#[derive(Clone, Debug)]
struct linc1Var2 {
    linc2: Tablelinc2,
}
impl linc1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 0i128 {
            return None;
        }
        let linc2 = if let Some((len, table)) =
            Tablelinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc1 {
    Var0(linc1Var0),
    Var1(linc1Var1),
    Var2(linc1Var2),
}
impl Tablelinc1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1119:1, end:1119:6))"]
#[derive(Clone, Debug)]
struct linc0Var0 {}
impl linc0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0014().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1118:1, end:1118:6))"]
#[derive(Clone, Debug)]
struct linc0Var1 {
    linc1: Tablelinc1,
}
impl linc0Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 1i128 {
            return None;
        }
        let linc1 = if let Some((len, table)) =
            Tablelinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1120:1, end:1120:6))"]
#[derive(Clone, Debug)]
struct linc0Var2 {
    linc1: Tablelinc1,
}
impl linc0Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 0i128 {
            return None;
        }
        let linc1 = if let Some((len, table)) =
            Tablelinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc0 {
    Var0(linc0Var0),
    Var1(linc0Var1),
    Var2(linc0Var2),
}
impl Tablelinc0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc0Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc0Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1121:1, end:1121:11))"]
#[derive(Clone, Debug)]
struct ldlist_incVar0 {
    linc0: Tablelinc0,
}
impl ldlist_incVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.linc0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let linc0 = if let Some((len, table)) =
            Tablelinc0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc0 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldlist_inc {
    Var0(ldlist_incVar0),
}
impl Tableldlist_inc {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = ldlist_incVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1124:1, end:1124:7))"]
#[derive(Clone, Debug)]
struct sinc15Var0 {}
impl sinc15Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1125:1, end:1125:7))"]
#[derive(Clone, Debug)]
struct sinc15Var1 {}
impl sinc15Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc15 {
    Var0(sinc15Var0),
    Var1(sinc15Var1),
}
impl Tablesinc15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc15Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc15Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1127:1, end:1127:7))"]
#[derive(Clone, Debug)]
struct sinc14Var0 {}
impl sinc14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0000().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1126:1, end:1126:7))"]
#[derive(Clone, Debug)]
struct sinc14Var1 {
    sinc15: Tablesinc15,
}
impl sinc14Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        let sinc15 = if let Some((len, table)) = Tablesinc15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1128:1, end:1128:7))"]
#[derive(Clone, Debug)]
struct sinc14Var2 {
    sinc15: Tablesinc15,
}
impl sinc14Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 0i128 {
            return None;
        }
        let sinc15 = if let Some((len, table)) = Tablesinc15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc14 {
    Var0(sinc14Var0),
    Var1(sinc14Var1),
    Var2(sinc14Var2),
}
impl Tablesinc14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc14Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc14Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc14Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1130:1, end:1130:7))"]
#[derive(Clone, Debug)]
struct sinc13Var0 {}
impl sinc13Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0001().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1129:1, end:1129:7))"]
#[derive(Clone, Debug)]
struct sinc13Var1 {
    sinc14: Tablesinc14,
}
impl sinc13Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        let sinc14 = if let Some((len, table)) = Tablesinc14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1131:1, end:1131:7))"]
#[derive(Clone, Debug)]
struct sinc13Var2 {
    sinc14: Tablesinc14,
}
impl sinc13Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 0i128 {
            return None;
        }
        let sinc14 = if let Some((len, table)) = Tablesinc14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc13 {
    Var0(sinc13Var0),
    Var1(sinc13Var1),
    Var2(sinc13Var2),
}
impl Tablesinc13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc13Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc13Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc13Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1133:1, end:1133:7))"]
#[derive(Clone, Debug)]
struct sinc12Var0 {}
impl sinc12Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0002().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1132:1, end:1132:7))"]
#[derive(Clone, Debug)]
struct sinc12Var1 {
    sinc13: Tablesinc13,
}
impl sinc12Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        let sinc13 = if let Some((len, table)) = Tablesinc13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1134:1, end:1134:7))"]
#[derive(Clone, Debug)]
struct sinc12Var2 {
    sinc13: Tablesinc13,
}
impl sinc12Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 0i128 {
            return None;
        }
        let sinc13 = if let Some((len, table)) = Tablesinc13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc12 {
    Var0(sinc12Var0),
    Var1(sinc12Var1),
    Var2(sinc12Var2),
}
impl Tablesinc12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc12Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc12Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc12Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1136:1, end:1136:7))"]
#[derive(Clone, Debug)]
struct sinc11Var0 {}
impl sinc11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0003().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1135:1, end:1135:7))"]
#[derive(Clone, Debug)]
struct sinc11Var1 {
    sinc12: Tablesinc12,
}
impl sinc11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        let sinc12 = if let Some((len, table)) = Tablesinc12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1137:1, end:1137:7))"]
#[derive(Clone, Debug)]
struct sinc11Var2 {
    sinc12: Tablesinc12,
}
impl sinc11Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let sinc12 = if let Some((len, table)) = Tablesinc12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc11 {
    Var0(sinc11Var0),
    Var1(sinc11Var1),
    Var2(sinc11Var2),
}
impl Tablesinc11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc11Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc11Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1139:1, end:1139:7))"]
#[derive(Clone, Debug)]
struct sinc10Var0 {}
impl sinc10Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0004().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1138:1, end:1138:7))"]
#[derive(Clone, Debug)]
struct sinc10Var1 {
    sinc11: Tablesinc11,
}
impl sinc10Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        let sinc11 = if let Some((len, table)) = Tablesinc11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1140:1, end:1140:7))"]
#[derive(Clone, Debug)]
struct sinc10Var2 {
    sinc11: Tablesinc11,
}
impl sinc10Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 0i128 {
            return None;
        }
        let sinc11 = if let Some((len, table)) = Tablesinc11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc10 {
    Var0(sinc10Var0),
    Var1(sinc10Var1),
    Var2(sinc10Var2),
}
impl Tablesinc10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc10Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc10Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc10Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1142:1, end:1142:6))"]
#[derive(Clone, Debug)]
struct sinc9Var0 {}
impl sinc9Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0005().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1141:1, end:1141:6))"]
#[derive(Clone, Debug)]
struct sinc9Var1 {
    sinc10: Tablesinc10,
}
impl sinc9Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        let sinc10 = if let Some((len, table)) = Tablesinc10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1143:1, end:1143:6))"]
#[derive(Clone, Debug)]
struct sinc9Var2 {
    sinc10: Tablesinc10,
}
impl sinc9Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 0i128 {
            return None;
        }
        let sinc10 = if let Some((len, table)) = Tablesinc10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc9 {
    Var0(sinc9Var0),
    Var1(sinc9Var1),
    Var2(sinc9Var2),
}
impl Tablesinc9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc9Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc9Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc9Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1145:1, end:1145:6))"]
#[derive(Clone, Debug)]
struct sinc8Var0 {}
impl sinc8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0006().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1144:1, end:1144:6))"]
#[derive(Clone, Debug)]
struct sinc8Var1 {
    sinc9: Tablesinc9,
}
impl sinc8Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r7),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        let sinc9 = if let Some((len, table)) =
            Tablesinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1146:1, end:1146:6))"]
#[derive(Clone, Debug)]
struct sinc8Var2 {
    sinc9: Tablesinc9,
}
impl sinc8Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 0i128 {
            return None;
        }
        let sinc9 = if let Some((len, table)) =
            Tablesinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc8 {
    Var0(sinc8Var0),
    Var1(sinc8Var1),
    Var2(sinc8Var2),
}
impl Tablesinc8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc8Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc8Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1148:1, end:1148:6))"]
#[derive(Clone, Debug)]
struct sinc7Var0 {}
impl sinc7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0007().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1147:1, end:1147:6))"]
#[derive(Clone, Debug)]
struct sinc7Var1 {
    sinc8: Tablesinc8,
}
impl sinc7Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        let sinc8 = if let Some((len, table)) =
            Tablesinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1149:1, end:1149:6))"]
#[derive(Clone, Debug)]
struct sinc7Var2 {
    sinc8: Tablesinc8,
}
impl sinc7Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 0i128 {
            return None;
        }
        let sinc8 = if let Some((len, table)) =
            Tablesinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc7 {
    Var0(sinc7Var0),
    Var1(sinc7Var1),
    Var2(sinc7Var2),
}
impl Tablesinc7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc7Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc7Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1151:1, end:1151:6))"]
#[derive(Clone, Debug)]
struct sinc6Var0 {}
impl sinc6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0008().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1150:1, end:1150:6))"]
#[derive(Clone, Debug)]
struct sinc6Var1 {
    sinc7: Tablesinc7,
}
impl sinc6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r9),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        let sinc7 = if let Some((len, table)) =
            Tablesinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1152:1, end:1152:6))"]
#[derive(Clone, Debug)]
struct sinc6Var2 {
    sinc7: Tablesinc7,
}
impl sinc6Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 0i128 {
            return None;
        }
        let sinc7 = if let Some((len, table)) =
            Tablesinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc6 {
    Var0(sinc6Var0),
    Var1(sinc6Var1),
    Var2(sinc6Var2),
}
impl Tablesinc6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc6Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1154:1, end:1154:6))"]
#[derive(Clone, Debug)]
struct sinc5Var0 {}
impl sinc5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0009().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1153:1, end:1153:6))"]
#[derive(Clone, Debug)]
struct sinc5Var1 {
    sinc6: Tablesinc6,
}
impl sinc5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r10),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        let sinc6 = if let Some((len, table)) =
            Tablesinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1155:1, end:1155:6))"]
#[derive(Clone, Debug)]
struct sinc5Var2 {
    sinc6: Tablesinc6,
}
impl sinc5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 0i128 {
            return None;
        }
        let sinc6 = if let Some((len, table)) =
            Tablesinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc5 {
    Var0(sinc5Var0),
    Var1(sinc5Var1),
    Var2(sinc5Var2),
}
impl Tablesinc5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1157:1, end:1157:6))"]
#[derive(Clone, Debug)]
struct sinc4Var0 {}
impl sinc4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0010().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1156:1, end:1156:6))"]
#[derive(Clone, Debug)]
struct sinc4Var1 {
    sinc5: Tablesinc5,
}
impl sinc4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r11),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        let sinc5 = if let Some((len, table)) =
            Tablesinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1158:1, end:1158:6))"]
#[derive(Clone, Debug)]
struct sinc4Var2 {
    sinc5: Tablesinc5,
}
impl sinc4Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 0i128 {
            return None;
        }
        let sinc5 = if let Some((len, table)) =
            Tablesinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc4 {
    Var0(sinc4Var0),
    Var1(sinc4Var1),
    Var2(sinc4Var2),
}
impl Tablesinc4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc4Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1160:1, end:1160:6))"]
#[derive(Clone, Debug)]
struct sinc3Var0 {}
impl sinc3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0011().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1159:1, end:1159:6))"]
#[derive(Clone, Debug)]
struct sinc3Var1 {
    sinc4: Tablesinc4,
}
impl sinc3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r12),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        let sinc4 = if let Some((len, table)) =
            Tablesinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1161:1, end:1161:6))"]
#[derive(Clone, Debug)]
struct sinc3Var2 {
    sinc4: Tablesinc4,
}
impl sinc3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 0i128 {
            return None;
        }
        let sinc4 = if let Some((len, table)) =
            Tablesinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc3 {
    Var0(sinc3Var0),
    Var1(sinc3Var1),
    Var2(sinc3Var2),
}
impl Tablesinc3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1163:1, end:1163:6))"]
#[derive(Clone, Debug)]
struct sinc2Var0 {}
impl sinc2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0012().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1162:1, end:1162:6))"]
#[derive(Clone, Debug)]
struct sinc2Var1 {
    sinc3: Tablesinc3,
}
impl sinc2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::sp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        let sinc3 = if let Some((len, table)) =
            Tablesinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1164:1, end:1164:6))"]
#[derive(Clone, Debug)]
struct sinc2Var2 {
    sinc3: Tablesinc3,
}
impl sinc2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 0i128 {
            return None;
        }
        let sinc3 = if let Some((len, table)) =
            Tablesinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc2 {
    Var0(sinc2Var0),
    Var1(sinc2Var1),
    Var2(sinc2Var2),
}
impl Tablesinc2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1166:1, end:1166:6))"]
#[derive(Clone, Debug)]
struct sinc1Var0 {}
impl sinc1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0013().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1165:1, end:1165:6))"]
#[derive(Clone, Debug)]
struct sinc1Var1 {
    sinc2: Tablesinc2,
}
impl sinc1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        let sinc2 = if let Some((len, table)) =
            Tablesinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1167:1, end:1167:6))"]
#[derive(Clone, Debug)]
struct sinc1Var2 {
    sinc2: Tablesinc2,
}
impl sinc1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 0i128 {
            return None;
        }
        let sinc2 = if let Some((len, table)) =
            Tablesinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc1 {
    Var0(sinc1Var0),
    Var1(sinc1Var1),
    Var2(sinc1Var2),
}
impl Tablesinc1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1169:1, end:1169:6))"]
#[derive(Clone, Debug)]
struct sinc0Var0 {}
impl sinc0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0014().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1168:1, end:1168:6))"]
#[derive(Clone, Debug)]
struct sinc0Var1 {
    sinc1: Tablesinc1,
}
impl sinc0Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 1i128 {
            return None;
        }
        let sinc1 = if let Some((len, table)) =
            Tablesinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1170:1, end:1170:6))"]
#[derive(Clone, Debug)]
struct sinc0Var2 {
    sinc1: Tablesinc1,
}
impl sinc0Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 0i128 {
            return None;
        }
        let sinc1 = if let Some((len, table)) =
            Tablesinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc0 {
    Var0(sinc0Var0),
    Var1(sinc0Var1),
    Var2(sinc0Var2),
}
impl Tablesinc0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc0Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc0Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1171:1, end:1171:11))"]
#[derive(Clone, Debug)]
struct stlist_incVar0 {
    sinc0: Tablesinc0,
}
impl stlist_incVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.sinc0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let sinc0 = if let Some((len, table)) =
            Tablesinc0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablestlist_inc {
    Var0(stlist_incVar0),
}
impl Tablestlist_inc {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = stlist_incVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1175:1, end:1175:7))"]
#[derive(Clone, Debug)]
struct ldec15Var0 {}
impl ldec15Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1176:1, end:1176:7))"]
#[derive(Clone, Debug)]
struct ldec15Var1 {}
impl ldec15Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tableldec15 {
    Var0(ldec15Var0),
    Var1(ldec15Var1),
}
impl Tableldec15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec15Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec15Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1178:1, end:1178:7))"]
#[derive(Clone, Debug)]
struct ldec14Var0 {}
impl ldec14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1515().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1177:1, end:1177:7))"]
#[derive(Clone, Debug)]
struct ldec14Var1 {
    ldec15: Tableldec15,
}
impl ldec14Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        let ldec15 = if let Some((len, table)) = Tableldec15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1179:1, end:1179:7))"]
#[derive(Clone, Debug)]
struct ldec14Var2 {
    ldec15: Tableldec15,
}
impl ldec14Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 0i128 {
            return None;
        }
        let ldec15 = if let Some((len, table)) = Tableldec15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec15 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec14 {
    Var0(ldec14Var0),
    Var1(ldec14Var1),
    Var2(ldec14Var2),
}
impl Tableldec14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec14Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec14Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec14Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1181:1, end:1181:7))"]
#[derive(Clone, Debug)]
struct ldec13Var0 {}
impl ldec13Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1415().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1180:1, end:1180:7))"]
#[derive(Clone, Debug)]
struct ldec13Var1 {
    ldec14: Tableldec14,
}
impl ldec13Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        let ldec14 = if let Some((len, table)) = Tableldec14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1182:1, end:1182:7))"]
#[derive(Clone, Debug)]
struct ldec13Var2 {
    ldec14: Tableldec14,
}
impl ldec13Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 0i128 {
            return None;
        }
        let ldec14 = if let Some((len, table)) = Tableldec14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec14 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec13 {
    Var0(ldec13Var0),
    Var1(ldec13Var1),
    Var2(ldec13Var2),
}
impl Tableldec13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec13Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec13Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec13Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1184:1, end:1184:7))"]
#[derive(Clone, Debug)]
struct ldec12Var0 {}
impl ldec12Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1315().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1183:1, end:1183:7))"]
#[derive(Clone, Debug)]
struct ldec12Var1 {
    ldec13: Tableldec13,
}
impl ldec12Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r12),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        let ldec13 = if let Some((len, table)) = Tableldec13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1185:1, end:1185:7))"]
#[derive(Clone, Debug)]
struct ldec12Var2 {
    ldec13: Tableldec13,
}
impl ldec12Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 0i128 {
            return None;
        }
        let ldec13 = if let Some((len, table)) = Tableldec13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec13 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec12 {
    Var0(ldec12Var0),
    Var1(ldec12Var1),
    Var2(ldec12Var2),
}
impl Tableldec12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec12Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec12Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec12Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1187:1, end:1187:7))"]
#[derive(Clone, Debug)]
struct ldec11Var0 {}
impl ldec11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1186:1, end:1186:7))"]
#[derive(Clone, Debug)]
struct ldec11Var1 {
    ldec12: Tableldec12,
}
impl ldec11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r11),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        let ldec12 = if let Some((len, table)) = Tableldec12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1188:1, end:1188:7))"]
#[derive(Clone, Debug)]
struct ldec11Var2 {
    ldec12: Tableldec12,
}
impl ldec11Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 0i128 {
            return None;
        }
        let ldec12 = if let Some((len, table)) = Tableldec12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec12 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec11 {
    Var0(ldec11Var0),
    Var1(ldec11Var1),
    Var2(ldec11Var2),
}
impl Tableldec11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec11Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec11Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1190:1, end:1190:7))"]
#[derive(Clone, Debug)]
struct ldec10Var0 {}
impl ldec10Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1115().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1189:1, end:1189:7))"]
#[derive(Clone, Debug)]
struct ldec10Var1 {
    ldec11: Tableldec11,
}
impl ldec10Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r10),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        let ldec11 = if let Some((len, table)) = Tableldec11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1191:1, end:1191:7))"]
#[derive(Clone, Debug)]
struct ldec10Var2 {
    ldec11: Tableldec11,
}
impl ldec10Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 0i128 {
            return None;
        }
        let ldec11 = if let Some((len, table)) = Tableldec11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec11 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec10 {
    Var0(ldec10Var0),
    Var1(ldec10Var1),
    Var2(ldec10Var2),
}
impl Tableldec10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec10Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec10Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec10Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1193:1, end:1193:6))"]
#[derive(Clone, Debug)]
struct ldec9Var0 {}
impl ldec9Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1015().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1192:1, end:1192:6))"]
#[derive(Clone, Debug)]
struct ldec9Var1 {
    ldec10: Tableldec10,
}
impl ldec9Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r9),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        let ldec10 = if let Some((len, table)) = Tableldec10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1194:1, end:1194:6))"]
#[derive(Clone, Debug)]
struct ldec9Var2 {
    ldec10: Tableldec10,
}
impl ldec9Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 0i128 {
            return None;
        }
        let ldec10 = if let Some((len, table)) = Tableldec10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec10 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec9 {
    Var0(ldec9Var0),
    Var1(ldec9Var1),
    Var2(ldec9Var2),
}
impl Tableldec9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec9Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec9Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec9Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1196:1, end:1196:6))"]
#[derive(Clone, Debug)]
struct ldec8Var0 {}
impl ldec8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0915().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1195:1, end:1195:6))"]
#[derive(Clone, Debug)]
struct ldec8Var1 {
    ldec9: Tableldec9,
}
impl ldec8Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r8),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        let ldec9 = if let Some((len, table)) =
            Tableldec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1197:1, end:1197:6))"]
#[derive(Clone, Debug)]
struct ldec8Var2 {
    ldec9: Tableldec9,
}
impl ldec8Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 0i128 {
            return None;
        }
        let ldec9 = if let Some((len, table)) =
            Tableldec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec9 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec8 {
    Var0(ldec8Var0),
    Var1(ldec8Var1),
    Var2(ldec8Var2),
}
impl Tableldec8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec8Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec8Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1199:1, end:1199:6))"]
#[derive(Clone, Debug)]
struct ldec7Var0 {}
impl ldec7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0815().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1198:1, end:1198:6))"]
#[derive(Clone, Debug)]
struct ldec7Var1 {
    ldec8: Tableldec8,
}
impl ldec7Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r7),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        let ldec8 = if let Some((len, table)) =
            Tableldec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1200:1, end:1200:6))"]
#[derive(Clone, Debug)]
struct ldec7Var2 {
    ldec8: Tableldec8,
}
impl ldec7Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 0i128 {
            return None;
        }
        let ldec8 = if let Some((len, table)) =
            Tableldec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec7 {
    Var0(ldec7Var0),
    Var1(ldec7Var1),
    Var2(ldec7Var2),
}
impl Tableldec7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec7Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec7Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1202:1, end:1202:6))"]
#[derive(Clone, Debug)]
struct ldec6Var0 {}
impl ldec6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0715().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1201:1, end:1201:6))"]
#[derive(Clone, Debug)]
struct ldec6Var1 {
    ldec7: Tableldec7,
}
impl ldec6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        let ldec7 = if let Some((len, table)) =
            Tableldec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1203:1, end:1203:6))"]
#[derive(Clone, Debug)]
struct ldec6Var2 {
    ldec7: Tableldec7,
}
impl ldec6Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 0i128 {
            return None;
        }
        let ldec7 = if let Some((len, table)) =
            Tableldec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec7 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec6 {
    Var0(ldec6Var0),
    Var1(ldec6Var1),
    Var2(ldec6Var2),
}
impl Tableldec6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec6Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1205:1, end:1205:6))"]
#[derive(Clone, Debug)]
struct ldec5Var0 {}
impl ldec5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0615().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1204:1, end:1204:6))"]
#[derive(Clone, Debug)]
struct ldec5Var1 {
    ldec6: Tableldec6,
}
impl ldec5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        let ldec6 = if let Some((len, table)) =
            Tableldec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1206:1, end:1206:6))"]
#[derive(Clone, Debug)]
struct ldec5Var2 {
    ldec6: Tableldec6,
}
impl ldec5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 0i128 {
            return None;
        }
        let ldec6 = if let Some((len, table)) =
            Tableldec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec6 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec5 {
    Var0(ldec5Var0),
    Var1(ldec5Var1),
    Var2(ldec5Var2),
}
impl Tableldec5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1208:1, end:1208:6))"]
#[derive(Clone, Debug)]
struct ldec4Var0 {}
impl ldec4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0515().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1207:1, end:1207:6))"]
#[derive(Clone, Debug)]
struct ldec4Var1 {
    ldec5: Tableldec5,
}
impl ldec4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        let ldec5 = if let Some((len, table)) =
            Tableldec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1209:1, end:1209:6))"]
#[derive(Clone, Debug)]
struct ldec4Var2 {
    ldec5: Tableldec5,
}
impl ldec4Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let ldec5 = if let Some((len, table)) =
            Tableldec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec5 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec4 {
    Var0(ldec4Var0),
    Var1(ldec4Var1),
    Var2(ldec4Var2),
}
impl Tableldec4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec4Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1211:1, end:1211:6))"]
#[derive(Clone, Debug)]
struct ldec3Var0 {}
impl ldec3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0415().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1210:1, end:1210:6))"]
#[derive(Clone, Debug)]
struct ldec3Var1 {
    ldec4: Tableldec4,
}
impl ldec3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        let ldec4 = if let Some((len, table)) =
            Tableldec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1212:1, end:1212:6))"]
#[derive(Clone, Debug)]
struct ldec3Var2 {
    ldec4: Tableldec4,
}
impl ldec3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 0i128 {
            return None;
        }
        let ldec4 = if let Some((len, table)) =
            Tableldec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec4 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec3 {
    Var0(ldec3Var0),
    Var1(ldec3Var1),
    Var2(ldec3Var2),
}
impl Tableldec3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1214:1, end:1214:6))"]
#[derive(Clone, Debug)]
struct ldec2Var0 {}
impl ldec2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0315().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1213:1, end:1213:6))"]
#[derive(Clone, Debug)]
struct ldec2Var1 {
    ldec3: Tableldec3,
}
impl ldec2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        let ldec3 = if let Some((len, table)) =
            Tableldec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1215:1, end:1215:6))"]
#[derive(Clone, Debug)]
struct ldec2Var2 {
    ldec3: Tableldec3,
}
impl ldec2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 0i128 {
            return None;
        }
        let ldec3 = if let Some((len, table)) =
            Tableldec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec3 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec2 {
    Var0(ldec2Var0),
    Var1(ldec2Var1),
    Var2(ldec2Var2),
}
impl Tableldec2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1217:1, end:1217:6))"]
#[derive(Clone, Debug)]
struct ldec1Var0 {}
impl ldec1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0215().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1216:1, end:1216:6))"]
#[derive(Clone, Debug)]
struct ldec1Var1 {
    ldec2: Tableldec2,
}
impl ldec1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        let ldec2 = if let Some((len, table)) =
            Tableldec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1218:1, end:1218:6))"]
#[derive(Clone, Debug)]
struct ldec1Var2 {
    ldec2: Tableldec2,
}
impl ldec1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 0i128 {
            return None;
        }
        let ldec2 = if let Some((len, table)) =
            Tableldec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec2 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec1 {
    Var0(ldec1Var0),
    Var1(ldec1Var1),
    Var2(ldec1Var2),
}
impl Tableldec1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1220:1, end:1220:6))"]
#[derive(Clone, Debug)]
struct ldec0Var0 {}
impl ldec0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0115().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1219:1, end:1219:6))"]
#[derive(Clone, Debug)]
struct ldec0Var1 {
    ldec1: Tableldec1,
}
impl ldec0Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 1i128 {
            return None;
        }
        let ldec1 = if let Some((len, table)) =
            Tableldec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1221:1, end:1221:6))"]
#[derive(Clone, Debug)]
struct ldec0Var2 {
    ldec1: Tableldec1,
}
impl ldec0Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 0i128 {
            return None;
        }
        let ldec1 = if let Some((len, table)) =
            Tableldec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec0 {
    Var0(ldec0Var0),
    Var1(ldec0Var1),
    Var2(ldec0Var2),
}
impl Tableldec0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec0Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec0Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1222:1, end:1222:11))"]
#[derive(Clone, Debug)]
struct ldlist_decVar0 {
    ldec0: Tableldec0,
}
impl ldlist_decVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.ldec0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let ldec0 = if let Some((len, table)) =
            Tableldec0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec0 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldlist_dec {
    Var0(ldlist_decVar0),
}
impl Tableldlist_dec {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = ldlist_decVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1225:1, end:1225:7))"]
#[derive(Clone, Debug)]
struct sdec15Var0 {}
impl sdec15Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1226:1, end:1226:7))"]
#[derive(Clone, Debug)]
struct sdec15Var1 {}
impl sdec15Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec15 {
    Var0(sdec15Var0),
    Var1(sdec15Var1),
}
impl Tablesdec15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec15Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec15Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1228:1, end:1228:7))"]
#[derive(Clone, Debug)]
struct sdec14Var0 {}
impl sdec14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1515().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1227:1, end:1227:7))"]
#[derive(Clone, Debug)]
struct sdec14Var1 {
    sdec15: Tablesdec15,
}
impl sdec14Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        let sdec15 = if let Some((len, table)) = Tablesdec15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1229:1, end:1229:7))"]
#[derive(Clone, Debug)]
struct sdec14Var2 {
    sdec15: Tablesdec15,
}
impl sdec14Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 0i128 {
            return None;
        }
        let sdec15 = if let Some((len, table)) = Tablesdec15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec14 {
    Var0(sdec14Var0),
    Var1(sdec14Var1),
    Var2(sdec14Var2),
}
impl Tablesdec14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec14Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec14Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec14Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1231:1, end:1231:7))"]
#[derive(Clone, Debug)]
struct sdec13Var0 {}
impl sdec13Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1415().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1230:1, end:1230:7))"]
#[derive(Clone, Debug)]
struct sdec13Var1 {
    sdec14: Tablesdec14,
}
impl sdec13Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        let sdec14 = if let Some((len, table)) = Tablesdec14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1232:1, end:1232:7))"]
#[derive(Clone, Debug)]
struct sdec13Var2 {
    sdec14: Tablesdec14,
}
impl sdec13Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 0i128 {
            return None;
        }
        let sdec14 = if let Some((len, table)) = Tablesdec14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec13 {
    Var0(sdec13Var0),
    Var1(sdec13Var1),
    Var2(sdec13Var2),
}
impl Tablesdec13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec13Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec13Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec13Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1234:1, end:1234:7))"]
#[derive(Clone, Debug)]
struct sdec12Var0 {}
impl sdec12Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1315().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1233:1, end:1233:7))"]
#[derive(Clone, Debug)]
struct sdec12Var1 {
    sdec13: Tablesdec13,
}
impl sdec12Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r12),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        let sdec13 = if let Some((len, table)) = Tablesdec13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1235:1, end:1235:7))"]
#[derive(Clone, Debug)]
struct sdec12Var2 {
    sdec13: Tablesdec13,
}
impl sdec12Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 0i128 {
            return None;
        }
        let sdec13 = if let Some((len, table)) = Tablesdec13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec12 {
    Var0(sdec12Var0),
    Var1(sdec12Var1),
    Var2(sdec12Var2),
}
impl Tablesdec12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec12Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec12Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec12Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1237:1, end:1237:7))"]
#[derive(Clone, Debug)]
struct sdec11Var0 {}
impl sdec11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1236:1, end:1236:7))"]
#[derive(Clone, Debug)]
struct sdec11Var1 {
    sdec12: Tablesdec12,
}
impl sdec11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r11),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        let sdec12 = if let Some((len, table)) = Tablesdec12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1238:1, end:1238:7))"]
#[derive(Clone, Debug)]
struct sdec11Var2 {
    sdec12: Tablesdec12,
}
impl sdec11Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 0i128 {
            return None;
        }
        let sdec12 = if let Some((len, table)) = Tablesdec12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec11 {
    Var0(sdec11Var0),
    Var1(sdec11Var1),
    Var2(sdec11Var2),
}
impl Tablesdec11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec11Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec11Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1240:1, end:1240:7))"]
#[derive(Clone, Debug)]
struct sdec10Var0 {}
impl sdec10Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1115().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1239:1, end:1239:7))"]
#[derive(Clone, Debug)]
struct sdec10Var1 {
    sdec11: Tablesdec11,
}
impl sdec10Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r10),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        let sdec11 = if let Some((len, table)) = Tablesdec11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1241:1, end:1241:7))"]
#[derive(Clone, Debug)]
struct sdec10Var2 {
    sdec11: Tablesdec11,
}
impl sdec10Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 0i128 {
            return None;
        }
        let sdec11 = if let Some((len, table)) = Tablesdec11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec10 {
    Var0(sdec10Var0),
    Var1(sdec10Var1),
    Var2(sdec10Var2),
}
impl Tablesdec10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec10Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec10Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec10Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1243:1, end:1243:6))"]
#[derive(Clone, Debug)]
struct sdec9Var0 {}
impl sdec9Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1015().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1242:1, end:1242:6))"]
#[derive(Clone, Debug)]
struct sdec9Var1 {
    sdec10: Tablesdec10,
}
impl sdec9Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r9),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        let sdec10 = if let Some((len, table)) = Tablesdec10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1244:1, end:1244:6))"]
#[derive(Clone, Debug)]
struct sdec9Var2 {
    sdec10: Tablesdec10,
}
impl sdec9Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 0i128 {
            return None;
        }
        let sdec10 = if let Some((len, table)) = Tablesdec10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec9 {
    Var0(sdec9Var0),
    Var1(sdec9Var1),
    Var2(sdec9Var2),
}
impl Tablesdec9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec9Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec9Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec9Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1246:1, end:1246:6))"]
#[derive(Clone, Debug)]
struct sdec8Var0 {}
impl sdec8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0915().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1245:1, end:1245:6))"]
#[derive(Clone, Debug)]
struct sdec8Var1 {
    sdec9: Tablesdec9,
}
impl sdec8Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r8),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        let sdec9 = if let Some((len, table)) =
            Tablesdec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1247:1, end:1247:6))"]
#[derive(Clone, Debug)]
struct sdec8Var2 {
    sdec9: Tablesdec9,
}
impl sdec8Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 0i128 {
            return None;
        }
        let sdec9 = if let Some((len, table)) =
            Tablesdec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec8 {
    Var0(sdec8Var0),
    Var1(sdec8Var1),
    Var2(sdec8Var2),
}
impl Tablesdec8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec8Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec8Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1249:1, end:1249:6))"]
#[derive(Clone, Debug)]
struct sdec7Var0 {}
impl sdec7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0815().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1248:1, end:1248:6))"]
#[derive(Clone, Debug)]
struct sdec7Var1 {
    sdec8: Tablesdec8,
}
impl sdec7Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r7),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        let sdec8 = if let Some((len, table)) =
            Tablesdec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1250:1, end:1250:6))"]
#[derive(Clone, Debug)]
struct sdec7Var2 {
    sdec8: Tablesdec8,
}
impl sdec7Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 0i128 {
            return None;
        }
        let sdec8 = if let Some((len, table)) =
            Tablesdec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec7 {
    Var0(sdec7Var0),
    Var1(sdec7Var1),
    Var2(sdec7Var2),
}
impl Tablesdec7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec7Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec7Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1252:1, end:1252:6))"]
#[derive(Clone, Debug)]
struct sdec6Var0 {}
impl sdec6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0715().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1251:1, end:1251:6))"]
#[derive(Clone, Debug)]
struct sdec6Var1 {
    sdec7: Tablesdec7,
}
impl sdec6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        let sdec7 = if let Some((len, table)) =
            Tablesdec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1253:1, end:1253:6))"]
#[derive(Clone, Debug)]
struct sdec6Var2 {
    sdec7: Tablesdec7,
}
impl sdec6Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 0i128 {
            return None;
        }
        let sdec7 = if let Some((len, table)) =
            Tablesdec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec6 {
    Var0(sdec6Var0),
    Var1(sdec6Var1),
    Var2(sdec6Var2),
}
impl Tablesdec6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec6Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1255:1, end:1255:6))"]
#[derive(Clone, Debug)]
struct sdec5Var0 {}
impl sdec5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0615().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1254:1, end:1254:6))"]
#[derive(Clone, Debug)]
struct sdec5Var1 {
    sdec6: Tablesdec6,
}
impl sdec5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        let sdec6 = if let Some((len, table)) =
            Tablesdec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1256:1, end:1256:6))"]
#[derive(Clone, Debug)]
struct sdec5Var2 {
    sdec6: Tablesdec6,
}
impl sdec5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 0i128 {
            return None;
        }
        let sdec6 = if let Some((len, table)) =
            Tablesdec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec5 {
    Var0(sdec5Var0),
    Var1(sdec5Var1),
    Var2(sdec5Var2),
}
impl Tablesdec5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1258:1, end:1258:6))"]
#[derive(Clone, Debug)]
struct sdec4Var0 {}
impl sdec4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0515().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1257:1, end:1257:6))"]
#[derive(Clone, Debug)]
struct sdec4Var1 {
    sdec5: Tablesdec5,
}
impl sdec4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        let sdec5 = if let Some((len, table)) =
            Tablesdec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1259:1, end:1259:6))"]
#[derive(Clone, Debug)]
struct sdec4Var2 {
    sdec5: Tablesdec5,
}
impl sdec4Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let sdec5 = if let Some((len, table)) =
            Tablesdec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec4 {
    Var0(sdec4Var0),
    Var1(sdec4Var1),
    Var2(sdec4Var2),
}
impl Tablesdec4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec4Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1261:1, end:1261:6))"]
#[derive(Clone, Debug)]
struct sdec3Var0 {}
impl sdec3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0415().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1260:1, end:1260:6))"]
#[derive(Clone, Debug)]
struct sdec3Var1 {
    sdec4: Tablesdec4,
}
impl sdec3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        let sdec4 = if let Some((len, table)) =
            Tablesdec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1262:1, end:1262:6))"]
#[derive(Clone, Debug)]
struct sdec3Var2 {
    sdec4: Tablesdec4,
}
impl sdec3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 0i128 {
            return None;
        }
        let sdec4 = if let Some((len, table)) =
            Tablesdec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec3 {
    Var0(sdec3Var0),
    Var1(sdec3Var1),
    Var2(sdec3Var2),
}
impl Tablesdec3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1264:1, end:1264:6))"]
#[derive(Clone, Debug)]
struct sdec2Var0 {}
impl sdec2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0315().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1263:1, end:1263:6))"]
#[derive(Clone, Debug)]
struct sdec2Var1 {
    sdec3: Tablesdec3,
}
impl sdec2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        let sdec3 = if let Some((len, table)) =
            Tablesdec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1265:1, end:1265:6))"]
#[derive(Clone, Debug)]
struct sdec2Var2 {
    sdec3: Tablesdec3,
}
impl sdec2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 0i128 {
            return None;
        }
        let sdec3 = if let Some((len, table)) =
            Tablesdec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec2 {
    Var0(sdec2Var0),
    Var1(sdec2Var1),
    Var2(sdec2Var2),
}
impl Tablesdec2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1267:1, end:1267:6))"]
#[derive(Clone, Debug)]
struct sdec1Var0 {}
impl sdec1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0215().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1266:1, end:1266:6))"]
#[derive(Clone, Debug)]
struct sdec1Var1 {
    sdec2: Tablesdec2,
}
impl sdec1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        let sdec2 = if let Some((len, table)) =
            Tablesdec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1268:1, end:1268:6))"]
#[derive(Clone, Debug)]
struct sdec1Var2 {
    sdec2: Tablesdec2,
}
impl sdec1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 0i128 {
            return None;
        }
        let sdec2 = if let Some((len, table)) =
            Tablesdec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec1 {
    Var0(sdec1Var0),
    Var1(sdec1Var1),
    Var2(sdec1Var2),
}
impl Tablesdec1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1270:1, end:1270:6))"]
#[derive(Clone, Debug)]
struct sdec0Var0 {}
impl sdec0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0115().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1269:1, end:1269:6))"]
#[derive(Clone, Debug)]
struct sdec0Var1 {
    sdec1: Tablesdec1,
}
impl sdec0Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 1i128 {
            return None;
        }
        let sdec1 = if let Some((len, table)) =
            Tablesdec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1271:1, end:1271:6))"]
#[derive(Clone, Debug)]
struct sdec0Var2 {
    sdec1: Tablesdec1,
}
impl sdec0Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 0i128 {
            return None;
        }
        let sdec1 = if let Some((len, table)) =
            Tablesdec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec0 {
    Var0(sdec0Var0),
    Var1(sdec0Var1),
    Var2(sdec0Var2),
}
impl Tablesdec0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec0Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec0Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1273:1, end:1273:11))"]
#[derive(Clone, Debug)]
struct stlist_decVar0 {
    sdec0: Tablesdec0,
}
impl stlist_decVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.sdec0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let sdec0 = if let Some((len, table)) =
            Tablesdec0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablestlist_dec {
    Var0(stlist_decVar0),
}
impl Tablestlist_dec {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = stlist_decVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1278:1, end:1278:8))"]
#[derive(Clone, Debug)]
struct reglistVar0 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1283:1, end:1283:8))"]
#[derive(Clone, Debug)]
struct reglistVar1 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1288:1, end:1288:8))"]
#[derive(Clone, Debug)]
struct reglistVar2 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1293:1, end:1293:8))"]
#[derive(Clone, Debug)]
struct reglistVar3 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1298:1, end:1298:8))"]
#[derive(Clone, Debug)]
struct reglistVar4 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1303:1, end:1303:8))"]
#[derive(Clone, Debug)]
struct reglistVar5 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1308:1, end:1308:8))"]
#[derive(Clone, Debug)]
struct reglistVar6 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1313:1, end:1313:8))"]
#[derive(Clone, Debug)]
struct reglistVar7 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1318:1, end:1318:8))"]
#[derive(Clone, Debug)]
struct reglistVar8 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1323:1, end:1323:8))"]
#[derive(Clone, Debug)]
struct reglistVar9 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1328:1, end:1328:8))"]
#[derive(Clone, Debug)]
struct reglistVar10 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1333:1, end:1333:8))"]
#[derive(Clone, Debug)]
struct reglistVar11 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1338:1, end:1338:8))"]
#[derive(Clone, Debug)]
struct reglistVar12 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1343:1, end:1343:8))"]
#[derive(Clone, Debug)]
struct reglistVar13 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1348:1, end:1348:8))"]
#[derive(Clone, Debug)]
struct reglistVar14 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1353:1, end:1353:8))"]
#[derive(Clone, Debug)]
struct reglistVar15 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1358:1, end:1358:8))"]
#[derive(Clone, Debug)]
struct reglistVar16 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) = Tablestlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1363:1, end:1363:8))"]
#[derive(Clone, Debug)]
struct reglistVar17 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) = Tablestlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1374:1, end:1374:8))"]
#[derive(Clone, Debug)]
struct reglistVar18 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) = Tablestlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1380:1, end:1380:8))"]
#[derive(Clone, Debug)]
struct reglistVar19 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) = Tablestlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1385:1, end:1385:8))"]
#[derive(Clone, Debug)]
struct reglistVar20 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) = Tablestlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1390:1, end:1390:8))"]
#[derive(Clone, Debug)]
struct reglistVar21 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) = Tablestlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1395:1, end:1395:8))"]
#[derive(Clone, Debug)]
struct reglistVar22 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) = Tablestlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1400:1, end:1400:8))"]
#[derive(Clone, Debug)]
struct reglistVar23 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) = Tablestlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1405:1, end:1405:8))"]
#[derive(Clone, Debug)]
struct reglistVar24 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) = Tablestlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1410:1, end:1410:8))"]
#[derive(Clone, Debug)]
struct reglistVar25 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) = Tablestlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1415:1, end:1415:8))"]
#[derive(Clone, Debug)]
struct reglistVar26 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) = Tablestlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1420:1, end:1420:8))"]
#[derive(Clone, Debug)]
struct reglistVar27 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) = Tablestlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1425:1, end:1425:8))"]
#[derive(Clone, Debug)]
struct reglistVar28 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) = Tablestlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[derive(Clone, Debug)]
enum Tablereglist {
    Var0(reglistVar0),
    Var1(reglistVar1),
    Var2(reglistVar2),
    Var3(reglistVar3),
    Var4(reglistVar4),
    Var5(reglistVar5),
    Var6(reglistVar6),
    Var7(reglistVar7),
    Var8(reglistVar8),
    Var9(reglistVar9),
    Var10(reglistVar10),
    Var11(reglistVar11),
    Var12(reglistVar12),
    Var13(reglistVar13),
    Var14(reglistVar14),
    Var15(reglistVar15),
    Var16(reglistVar16),
    Var17(reglistVar17),
    Var18(reglistVar18),
    Var19(reglistVar19),
    Var20(reglistVar20),
    Var21(reglistVar21),
    Var22(reglistVar22),
    Var23(reglistVar23),
    Var24(reglistVar24),
    Var25(reglistVar25),
    Var26(reglistVar26),
    Var27(reglistVar27),
    Var28(reglistVar28),
}
impl Tablereglist {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            reglistVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar16::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar17::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar18::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar19::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar20::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar21::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar22::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar23::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar24::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar25::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar26::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar27::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar28::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1431:1, end:1431:5))"]
#[derive(Clone, Debug)]
struct mdirVar0 {}
impl mdirVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ia")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1432:1, end:1432:5))"]
#[derive(Clone, Debug)]
struct mdirVar1 {}
impl mdirVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ib")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1433:1, end:1433:5))"]
#[derive(Clone, Debug)]
struct mdirVar2 {}
impl mdirVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("da")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1434:1, end:1434:5))"]
#[derive(Clone, Debug)]
struct mdirVar3 {}
impl mdirVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("db")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablemdir {
    Var0(mdirVar0),
    Var1(mdirVar1),
    Var2(mdirVar2),
    Var3(mdirVar3),
}
impl Tablemdir {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            mdirVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            mdirVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            mdirVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            mdirVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1439:1, end:1439:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var0 {
    immed: TokenField_immed,
    rn: Tablern,
}
impl addrmode5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off8: i128 = 0;
        calc_off8 = self.immed.disassembly().wrapping_mul(4i128);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_off8),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        calc_off8 = token_parser
            .TokenFieldimmed()
            .disassembly()
            .wrapping_mul(4i128);
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed = token_parser.TokenFieldimmed();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1440:1, end:1440:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var1 {
    immed: TokenField_immed,
    rn: Tablern,
}
impl addrmode5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-self.immed.disassembly().wrapping_mul(4i128));
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_noff8),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        calc_noff8 = (-token_parser
            .TokenFieldimmed()
            .disassembly()
            .wrapping_mul(4i128));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed = token_parser.TokenFieldimmed();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1441:1, end:1441:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var2 {
    immed: TokenField_immed,
    rn: Tablern,
}
impl addrmode5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off8: i128 = 0;
        calc_off8 = self.immed.disassembly().wrapping_mul(4i128);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_off8),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        calc_off8 = token_parser
            .TokenFieldimmed()
            .disassembly()
            .wrapping_mul(4i128);
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed = token_parser.TokenFieldimmed();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1442:1, end:1442:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var3 {
    immed: TokenField_immed,
    rn: Tablern,
}
impl addrmode5Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-self.immed.disassembly().wrapping_mul(4i128));
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_noff8),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        calc_noff8 = (-token_parser
            .TokenFieldimmed()
            .disassembly()
            .wrapping_mul(4i128));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed = token_parser.TokenFieldimmed();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1443:1, end:1443:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var4 {
    immed: TokenField_immed,
    rn: Tablern,
}
impl addrmode5Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off8: i128 = 0;
        calc_off8 = self.immed.disassembly().wrapping_mul(4i128);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("],#"),
            DisplayElement::Number(true, calc_off8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        calc_off8 = token_parser
            .TokenFieldimmed()
            .disassembly()
            .wrapping_mul(4i128);
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed = token_parser.TokenFieldimmed();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1444:1, end:1444:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var5 {
    immed: TokenField_immed,
    rn: Tablern,
}
impl addrmode5Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-self.immed.disassembly().wrapping_mul(4i128));
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("],#"),
            DisplayElement::Number(true, calc_noff8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        calc_noff8 = (-token_parser
            .TokenFieldimmed()
            .disassembly()
            .wrapping_mul(4i128));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed = token_parser.TokenFieldimmed();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1445:1, end:1445:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var6 {
    immed: TokenField_immed,
    rn: Tablern,
}
impl addrmode5Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("],{"),
            self.immed.display(),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed = token_parser.TokenFieldimmed();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrmode5 {
    Var0(addrmode5Var0),
    Var1(addrmode5Var1),
    Var2(addrmode5Var2),
    Var3(addrmode5Var3),
    Var4(addrmode5Var4),
    Var5(addrmode5Var5),
    Var6(addrmode5Var6),
}
impl Tableaddrmode5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            addrmode5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode5Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode5Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode5Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode5Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1449:1, end:1449:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar0 {}
impl cpsrmaskVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1450:1, end:1450:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar1 {}
impl cpsrmaskVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_c")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1451:1, end:1451:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar2 {}
impl cpsrmaskVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_x")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1452:1, end:1452:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar3 {}
impl cpsrmaskVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cx")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1453:1, end:1453:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar4 {}
impl cpsrmaskVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_s")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1454:1, end:1454:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar5 {}
impl cpsrmaskVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1455:1, end:1455:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar6 {}
impl cpsrmaskVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_xs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 6i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1456:1, end:1456:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar7 {}
impl cpsrmaskVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cxs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 7i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1457:1, end:1457:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar8 {}
impl cpsrmaskVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_f")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 8i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1458:1, end:1458:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar9 {}
impl cpsrmaskVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 9i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1459:1, end:1459:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar10 {}
impl cpsrmaskVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_xf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 10i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1460:1, end:1460:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar11 {}
impl cpsrmaskVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cxf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 11i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1461:1, end:1461:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar12 {}
impl cpsrmaskVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_sf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 12i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1462:1, end:1462:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar13 {}
impl cpsrmaskVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_csf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 13i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1463:1, end:1463:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar14 {}
impl cpsrmaskVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_xsf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 14i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1464:1, end:1464:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar15 {}
impl cpsrmaskVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cxsf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 15i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablecpsrmask {
    Var0(cpsrmaskVar0),
    Var1(cpsrmaskVar1),
    Var2(cpsrmaskVar2),
    Var3(cpsrmaskVar3),
    Var4(cpsrmaskVar4),
    Var5(cpsrmaskVar5),
    Var6(cpsrmaskVar6),
    Var7(cpsrmaskVar7),
    Var8(cpsrmaskVar8),
    Var9(cpsrmaskVar9),
    Var10(cpsrmaskVar10),
    Var11(cpsrmaskVar11),
    Var12(cpsrmaskVar12),
    Var13(cpsrmaskVar13),
    Var14(cpsrmaskVar14),
    Var15(cpsrmaskVar15),
}
impl Tablecpsrmask {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            cpsrmaskVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1468:1, end:1468:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar0 {}
impl spsrmaskVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1469:1, end:1469:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar1 {}
impl spsrmaskVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_c")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1470:1, end:1470:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar2 {}
impl spsrmaskVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_x")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1471:1, end:1471:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar3 {}
impl spsrmaskVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cx")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1472:1, end:1472:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar4 {}
impl spsrmaskVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_s")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1473:1, end:1473:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar5 {}
impl spsrmaskVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1474:1, end:1474:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar6 {}
impl spsrmaskVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_xs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 6i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1475:1, end:1475:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar7 {}
impl spsrmaskVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cxs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 7i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1476:1, end:1476:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar8 {}
impl spsrmaskVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_f")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 8i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1477:1, end:1477:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar9 {}
impl spsrmaskVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 9i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1478:1, end:1478:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar10 {}
impl spsrmaskVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_xf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 10i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1479:1, end:1479:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar11 {}
impl spsrmaskVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cxf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 11i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1480:1, end:1480:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar12 {}
impl spsrmaskVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_sf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 12i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1481:1, end:1481:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar13 {}
impl spsrmaskVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_csf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 13i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1482:1, end:1482:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar14 {}
impl spsrmaskVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_xsf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 14i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1483:1, end:1483:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar15 {}
impl spsrmaskVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cxsf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 15i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablespsrmask {
    Var0(spsrmaskVar0),
    Var1(spsrmaskVar1),
    Var2(spsrmaskVar2),
    Var3(spsrmaskVar3),
    Var4(spsrmaskVar4),
    Var5(spsrmaskVar5),
    Var6(spsrmaskVar6),
    Var7(spsrmaskVar7),
    Var8(spsrmaskVar8),
    Var9(spsrmaskVar9),
    Var10(spsrmaskVar10),
    Var11(spsrmaskVar11),
    Var12(spsrmaskVar12),
    Var13(spsrmaskVar13),
    Var14(spsrmaskVar14),
    Var15(spsrmaskVar15),
}
impl Tablespsrmask {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            spsrmaskVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1570:1, end:1570:10))"]
#[derive(Clone, Debug)]
struct immed12_4Var0 {
    immed12: TokenField_immed12,
    immed4: TokenField_immed4,
}
impl immed12_4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_tmp: i128 = 0;
        calc_tmp = (u32::try_from(4i128)
            .ok()
            .map(|shl| self.immed12.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.immed4.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Number(true, calc_tmp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_tmp: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_TMode_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        calc_tmp = (u32::try_from(4i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldimmed12()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimmed4().disassembly());
        let immed12 = token_parser.TokenFieldimmed12();
        let immed4 = token_parser.TokenFieldimmed4();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed12, immed4 }))
    }
}
#[derive(Clone, Debug)]
enum Tableimmed12_4 {
    Var0(immed12_4Var0),
}
impl Tableimmed12_4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            immed12_4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1984:1, end:1984:16))"]
#[derive(Clone, Debug)]
struct ArmPCRelImmed12Var0 {
    immed: TokenField_immed,
    rotate: TokenField_rotate,
}
impl ArmPCRelImmed12Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                ((u32::try_from(32i128.wrapping_sub(
                    self.rotate.disassembly().wrapping_mul(2i128),
                ))
                .ok()
                .map(|shl| self.immed.disassembly().checked_shl(shl))
                .flatten()
                .unwrap_or(0)
                    | u32::try_from(
                        self.rotate.disassembly().wrapping_mul(2i128),
                    )
                    .ok()
                    .map(|shr| self.immed.disassembly().checked_shr(shr))
                    .flatten()
                    .unwrap_or(0))
                    & 4294967295i128),
            );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloff)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                ((u32::try_from(
                    32i128.wrapping_sub(
                        token_parser
                            .TokenFieldrotate()
                            .disassembly()
                            .wrapping_mul(2i128),
                    ),
                )
                .ok()
                .map(|shl| {
                    token_parser
                        .TokenFieldimmed()
                        .disassembly()
                        .checked_shl(shl)
                })
                .flatten()
                .unwrap_or(0)
                    | u32::try_from(
                        token_parser
                            .TokenFieldrotate()
                            .disassembly()
                            .wrapping_mul(2i128),
                    )
                    .ok()
                    .map(|shr| {
                        token_parser
                            .TokenFieldimmed()
                            .disassembly()
                            .checked_shr(shr)
                    })
                    .flatten()
                    .unwrap_or(0))
                    & 4294967295i128),
            );
        let immed = token_parser.TokenFieldimmed();
        let rotate = token_parser.TokenFieldrotate();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed, rotate }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1990:1, end:1990:16))"]
#[derive(Clone, Debug)]
struct ArmPCRelImmed12Var1 {
    immed: TokenField_immed,
    rotate: TokenField_rotate,
}
impl ArmPCRelImmed12Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                ((u32::try_from(32i128.wrapping_sub(
                    self.rotate.disassembly().wrapping_mul(2i128),
                ))
                .ok()
                .map(|shl| self.immed.disassembly().checked_shl(shl))
                .flatten()
                .unwrap_or(0)
                    | u32::try_from(
                        self.rotate.disassembly().wrapping_mul(2i128),
                    )
                    .ok()
                    .map(|shr| self.immed.disassembly().checked_shr(shr))
                    .flatten()
                    .unwrap_or(0))
                    & 4294967295i128),
            ),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloff)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                ((u32::try_from(
                    32i128.wrapping_sub(
                        token_parser
                            .TokenFieldrotate()
                            .disassembly()
                            .wrapping_mul(2i128),
                    ),
                )
                .ok()
                .map(|shl| {
                    token_parser
                        .TokenFieldimmed()
                        .disassembly()
                        .checked_shl(shl)
                })
                .flatten()
                .unwrap_or(0)
                    | u32::try_from(
                        token_parser
                            .TokenFieldrotate()
                            .disassembly()
                            .wrapping_mul(2i128),
                    )
                    .ok()
                    .map(|shr| {
                        token_parser
                            .TokenFieldimmed()
                            .disassembly()
                            .checked_shr(shr)
                    })
                    .flatten()
                    .unwrap_or(0))
                    & 4294967295i128),
            ),
        );
        let immed = token_parser.TokenFieldimmed();
        let rotate = token_parser.TokenFieldrotate();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed, rotate }))
    }
}
#[derive(Clone, Debug)]
enum TableArmPCRelImmed12 {
    Var0(ArmPCRelImmed12Var0),
    Var1(ArmPCRelImmed12Var1),
}
impl TableArmPCRelImmed12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = ArmPCRelImmed12Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = ArmPCRelImmed12Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:269:1, end:269:5))"]
#[derive(Clone, Debug)]
struct thccVar0 {}
impl thccVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthcond().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:270:1, end:270:5))"]
#[derive(Clone, Debug)]
struct thccVar1 {}
impl thccVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthcond().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:271:1, end:271:5))"]
#[derive(Clone, Debug)]
struct thccVar2 {}
impl thccVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthcond().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:272:1, end:272:5))"]
#[derive(Clone, Debug)]
struct thccVar3 {}
impl thccVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cc")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthcond().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:273:1, end:273:5))"]
#[derive(Clone, Debug)]
struct thccVar4 {}
impl thccVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mi")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthcond().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:274:1, end:274:5))"]
#[derive(Clone, Debug)]
struct thccVar5 {}
impl thccVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("pl")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthcond().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:275:1, end:275:5))"]
#[derive(Clone, Debug)]
struct thccVar6 {}
impl thccVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("vs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthcond().disassembly() != 6i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:276:1, end:276:5))"]
#[derive(Clone, Debug)]
struct thccVar7 {}
impl thccVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("vc")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthcond().disassembly() != 7i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:277:1, end:277:5))"]
#[derive(Clone, Debug)]
struct thccVar8 {}
impl thccVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("hi")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthcond().disassembly() != 8i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:278:1, end:278:5))"]
#[derive(Clone, Debug)]
struct thccVar9 {}
impl thccVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ls")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthcond().disassembly() != 9i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:279:1, end:279:5))"]
#[derive(Clone, Debug)]
struct thccVar10 {}
impl thccVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthcond().disassembly() != 10i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:280:1, end:280:5))"]
#[derive(Clone, Debug)]
struct thccVar11 {}
impl thccVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthcond().disassembly() != 11i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:281:1, end:281:5))"]
#[derive(Clone, Debug)]
struct thccVar12 {}
impl thccVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthcond().disassembly() != 12i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:282:1, end:282:5))"]
#[derive(Clone, Debug)]
struct thccVar13 {}
impl thccVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthcond().disassembly() != 13i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablethcc {
    Var0(thccVar0),
    Var1(thccVar1),
    Var2(thccVar2),
    Var3(thccVar3),
    Var4(thccVar4),
    Var5(thccVar5),
    Var6(thccVar6),
    Var7(thccVar7),
    Var8(thccVar8),
    Var9(thccVar9),
    Var10(thccVar10),
    Var11(thccVar11),
    Var12(thccVar12),
    Var13(thccVar13),
}
impl Tablethcc {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thccVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thccVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thccVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thccVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thccVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thccVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thccVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thccVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thccVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thccVar9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thccVar10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thccVar11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thccVar12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thccVar13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:353:1, end:353:8))"]
#[derive(Clone, Debug)]
struct Hrd0002Var0 {}
impl Hrd0002Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldhrd0002().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldh1().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:351:1, end:351:8))"]
#[derive(Clone, Debug)]
struct Hrd0002Var1 {
    Rd0002: TokenField_Rd0002,
}
impl Hrd0002Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rd0002.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldh1().disassembly() != 0i128 {
            return None;
        }
        let Rd0002 = token_parser.TokenFieldRd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rd0002 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:352:1, end:352:8))"]
#[derive(Clone, Debug)]
struct Hrd0002Var2 {
    hrd0002: TokenField_hrd0002,
}
impl Hrd0002Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.hrd0002.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldh1().disassembly() != 1i128 {
            return None;
        }
        let hrd0002 = token_parser.TokenFieldhrd0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { hrd0002 }))
    }
}
#[derive(Clone, Debug)]
enum TableHrd0002 {
    Var0(Hrd0002Var0),
    Var1(Hrd0002Var1),
    Var2(Hrd0002Var2),
}
impl TableHrd0002 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Hrd0002Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Hrd0002Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Hrd0002Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:357:1, end:357:8))"]
#[derive(Clone, Debug)]
struct Hrn0002Var0 {}
impl Hrn0002Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldhrn0002().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldh1().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:355:1, end:355:8))"]
#[derive(Clone, Debug)]
struct Hrn0002Var1 {
    Rn0002: TokenField_Rn0002,
}
impl Hrn0002Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rn0002.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldh1().disassembly() != 0i128 {
            return None;
        }
        let Rn0002 = token_parser.TokenFieldRn0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0002 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:356:1, end:356:8))"]
#[derive(Clone, Debug)]
struct Hrn0002Var2 {
    hrn0002: TokenField_hrn0002,
}
impl Hrn0002Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.hrn0002.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldh1().disassembly() != 1i128 {
            return None;
        }
        let hrn0002 = token_parser.TokenFieldhrn0002();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { hrn0002 }))
    }
}
#[derive(Clone, Debug)]
enum TableHrn0002 {
    Var0(Hrn0002Var0),
    Var1(Hrn0002Var1),
    Var2(Hrn0002Var2),
}
impl TableHrn0002 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Hrn0002Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Hrn0002Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Hrn0002Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:361:1, end:361:8))"]
#[derive(Clone, Debug)]
struct Hrm0305Var0 {}
impl Hrm0305Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldhrm0305().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldh2().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:359:1, end:359:8))"]
#[derive(Clone, Debug)]
struct Hrm0305Var1 {
    Rm0305: TokenField_Rm0305,
}
impl Hrm0305Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rm0305.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldh2().disassembly() != 0i128 {
            return None;
        }
        let Rm0305 = token_parser.TokenFieldRm0305();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rm0305 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:360:1, end:360:8))"]
#[derive(Clone, Debug)]
struct Hrm0305Var2 {
    hrm0305: TokenField_hrm0305,
}
impl Hrm0305Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.hrm0305.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldh2().disassembly() != 1i128 {
            return None;
        }
        let hrm0305 = token_parser.TokenFieldhrm0305();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { hrm0305 }))
    }
}
#[derive(Clone, Debug)]
enum TableHrm0305 {
    Var0(Hrm0305Var0),
    Var1(Hrm0305Var1),
    Var2(Hrm0305Var2),
}
impl TableHrm0305 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Hrm0305Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Hrm0305Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Hrm0305Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:368:1, end:368:7))"]
#[derive(Clone, Debug)]
struct Immed8Var0 {
    immed8: TokenField_immed8,
}
impl Immed8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.immed8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let immed8 = token_parser.TokenFieldimmed8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed8 }))
    }
}
#[derive(Clone, Debug)]
enum TableImmed8 {
    Var0(Immed8Var0),
}
impl TableImmed8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Immed8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:369:1, end:369:7))"]
#[derive(Clone, Debug)]
struct Immed3Var0 {
    immed3: TokenField_immed3,
}
impl Immed3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.immed3.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let immed3 = token_parser.TokenFieldimmed3();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed3 }))
    }
}
#[derive(Clone, Debug)]
enum TableImmed3 {
    Var0(Immed3Var0),
}
impl TableImmed3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Immed3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:371:1, end:371:7))"]
#[derive(Clone, Debug)]
struct Pcrel8Var0 {
    immed8: TokenField_immed8,
}
impl Pcrel8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128)
            & 4294967292i128)
            .wrapping_add(4i128.wrapping_mul(self.immed8.disassembly()));
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Number(true, calc_reloc),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_reloc =
            (i128::try_from(inst_start).unwrap().wrapping_add(4i128)
                & 4294967292i128)
                .wrapping_add(4i128.wrapping_mul(
                    token_parser.TokenFieldimmed8().disassembly(),
                ));
        let immed8 = token_parser.TokenFieldimmed8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed8 }))
    }
}
#[derive(Clone, Debug)]
enum TablePcrel8 {
    Var0(Pcrel8Var0),
}
impl TablePcrel8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Pcrel8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:388:1, end:388:7))"]
#[derive(Clone, Debug)]
struct Sprel8Var0 {
    immed8: TokenField_immed8,
}
impl Sprel8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_immval: i128 = 0;
        calc_immval = self.immed8.disassembly().wrapping_mul(4i128);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_immval),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_immval: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_immval = token_parser
            .TokenFieldimmed8()
            .disassembly()
            .wrapping_mul(4i128);
        let immed8 = token_parser.TokenFieldimmed8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed8 }))
    }
}
#[derive(Clone, Debug)]
enum TableSprel8 {
    Var0(Sprel8Var0),
}
impl TableSprel8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Sprel8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:389:1, end:389:9))"]
#[derive(Clone, Debug)]
struct Immed7_4Var0 {
    immed7: TokenField_immed7,
}
impl Immed7_4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_immval: i128 = 0;
        calc_immval = self.immed7.disassembly().wrapping_mul(4i128);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Number(true, calc_immval),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_immval: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_immval = token_parser
            .TokenFieldimmed7()
            .disassembly()
            .wrapping_mul(4i128);
        let immed7 = token_parser.TokenFieldimmed7();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed7 }))
    }
}
#[derive(Clone, Debug)]
enum TableImmed7_4 {
    Var0(Immed7_4Var0),
}
impl TableImmed7_4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Immed7_4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:390:1, end:390:7))"]
#[derive(Clone, Debug)]
struct Immed5Var0 {
    immed5: TokenField_immed5,
}
impl Immed5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.immed5.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let immed5 = token_parser.TokenFieldimmed5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed5 }))
    }
}
#[derive(Clone, Debug)]
enum TableImmed5 {
    Var0(Immed5Var0),
}
impl TableImmed5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Immed5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:534:1, end:534:6))"]
#[derive(Clone, Debug)]
struct Addr5Var0 {
    thc0909: TokenField_thc0909,
    imm5: TokenField_imm5,
}
impl Addr5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                (u32::try_from(6i128)
                    .ok()
                    .map(|shl| self.thc0909.disassembly().checked_shl(shl))
                    .flatten()
                    .unwrap_or(0)
                    | u32::try_from(1i128)
                        .ok()
                        .map(|shl| self.imm5.disassembly().checked_shl(shl))
                        .flatten()
                        .unwrap_or(0)),
            );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                (u32::try_from(6i128)
                    .ok()
                    .map(|shl| {
                        token_parser
                            .TokenFieldthc0909()
                            .disassembly()
                            .checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0)
                    | u32::try_from(1i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldimm5()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0)),
            );
        let imm5 = token_parser.TokenFieldimm5();
        let thc0909 = token_parser.TokenFieldthc0909();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm5, thc0909 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr5 {
    Var0(Addr5Var0),
}
impl TableAddr5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Addr5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:540:1, end:540:6))"]
#[derive(Clone, Debug)]
struct Addr8Var0 {
    soffset8: TokenField_soffset8,
}
impl Addr8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(2i128.wrapping_mul(self.soffset8.disassembly()));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_reloc =
            i128::try_from(inst_start)
                .unwrap()
                .wrapping_add(4i128)
                .wrapping_add(2i128.wrapping_mul(
                    token_parser.TokenFieldsoffset8().disassembly(),
                ));
        let soffset8 = token_parser.TokenFieldsoffset8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { soffset8 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr8 {
    Var0(Addr8Var0),
}
impl TableAddr8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Addr8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:546:1, end:546:7))"]
#[derive(Clone, Debug)]
struct Addr11Var0 {
    soffset11: TokenField_soffset11,
}
impl Addr11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(2i128.wrapping_mul(self.soffset11.disassembly()));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(2i128.wrapping_mul(
                token_parser.TokenFieldsoffset11().disassembly(),
            ));
        let soffset11 = token_parser.TokenFieldsoffset11();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { soffset11 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr11 {
    Var0(Addr11Var0),
}
impl TableAddr11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Addr11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:568:1, end:568:9))"]
#[derive(Clone, Debug)]
struct ThAddr24Var0 {
    part2J1: TokenField_part2J1,
    part2J2: TokenField_part2J2,
    offset10: TokenField_offset10,
    part2off: TokenField_part2off,
}
impl ThAddr24Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                (((u32::try_from(23i128)
                    .ok()
                    .map(|shl| {
                        (self.part2J1.disassembly() ^ 1i128).checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0)
                    | u32::try_from(22i128)
                        .ok()
                        .map(|shl| {
                            (self.part2J2.disassembly() ^ 1i128)
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .map(|shl| self.offset10.disassembly().checked_shl(shl))
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(1i128)
                        .ok()
                        .map(|shl| self.part2off.disassembly().checked_shl(shl))
                        .flatten()
                        .unwrap_or(0)),
            );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldoffset10S().disassembly() != 0i128 {
            return None;
        }
        let offset10 = token_parser.TokenFieldoffset10();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                (((u32::try_from(23i128)
                    .ok()
                    .map(|shl| {
                        (token_parser.TokenFieldpart2J1().disassembly() ^ 1i128)
                            .checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0)
                    | u32::try_from(22i128)
                        .ok()
                        .map(|shl| {
                            (token_parser.TokenFieldpart2J2().disassembly()
                                ^ 1i128)
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldoffset10()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(1i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldpart2off()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0)),
            );
        let part2J1 = token_parser.TokenFieldpart2J1();
        let part2J2 = token_parser.TokenFieldpart2J2();
        let part2off = token_parser.TokenFieldpart2off();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                offset10,
                part2J1,
                part2J2,
                part2off,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:574:1, end:574:9))"]
#[derive(Clone, Debug)]
struct ThAddr24Var1 {
    part2J1: TokenField_part2J1,
    part2J2: TokenField_part2J2,
    offset10: TokenField_offset10,
    part2off: TokenField_part2off,
}
impl ThAddr24Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                ((((u32::try_from(24i128)
                    .ok()
                    .map(|shl| (-1i128).checked_shl(shl))
                    .flatten()
                    .unwrap_or(0)
                    | u32::try_from(23i128)
                        .ok()
                        .map(|shl| self.part2J1.disassembly().checked_shl(shl))
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(22i128)
                        .ok()
                        .map(|shl| self.part2J2.disassembly().checked_shl(shl))
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .map(|shl| self.offset10.disassembly().checked_shl(shl))
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(1i128)
                        .ok()
                        .map(|shl| self.part2off.disassembly().checked_shl(shl))
                        .flatten()
                        .unwrap_or(0)),
            );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldoffset10S().disassembly() != 1i128 {
            return None;
        }
        let offset10 = token_parser.TokenFieldoffset10();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                ((((u32::try_from(24i128)
                    .ok()
                    .map(|shl| (-1i128).checked_shl(shl))
                    .flatten()
                    .unwrap_or(0)
                    | u32::try_from(23i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldpart2J1()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(22i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldpart2J2()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldoffset10()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(1i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldpart2off()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0)),
            );
        let part2J1 = token_parser.TokenFieldpart2J1();
        let part2J2 = token_parser.TokenFieldpart2J2();
        let part2off = token_parser.TokenFieldpart2off();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                offset10,
                part2J1,
                part2J2,
                part2off,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableThAddr24 {
    Var0(ThAddr24Var0),
    Var1(ThAddr24Var1),
}
impl TableThAddr24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ThAddr24Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ThAddr24Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:582:1, end:582:12))"]
#[derive(Clone, Debug)]
struct ThArmAddr23Var0 {
    part2J1: TokenField_part2J1,
    part2J2: TokenField_part2J2,
    offset10: TokenField_offset10,
    part2off_10: TokenField_part2off_10,
}
impl ThArmAddr23Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128)
            & 4294967292i128)
            .wrapping_add(
                (((u32::try_from(23i128)
                    .ok()
                    .map(|shl| {
                        (self.part2J1.disassembly() ^ 1i128).checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0)
                    | u32::try_from(22i128)
                        .ok()
                        .map(|shl| {
                            (self.part2J2.disassembly() ^ 1i128)
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .map(|shl| self.offset10.disassembly().checked_shl(shl))
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(2i128)
                        .ok()
                        .map(|shl| {
                            self.part2off_10.disassembly().checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0)),
            );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldoffset10S().disassembly() != 0i128 {
            return None;
        }
        let offset10 = token_parser.TokenFieldoffset10();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128)
            & 4294967292i128)
            .wrapping_add(
                (((u32::try_from(23i128)
                    .ok()
                    .map(|shl| {
                        (token_parser.TokenFieldpart2J1().disassembly() ^ 1i128)
                            .checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0)
                    | u32::try_from(22i128)
                        .ok()
                        .map(|shl| {
                            (token_parser.TokenFieldpart2J2().disassembly()
                                ^ 1i128)
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldoffset10()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(2i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldpart2off_10()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0)),
            );
        let part2J1 = token_parser.TokenFieldpart2J1();
        let part2J2 = token_parser.TokenFieldpart2J2();
        let part2off_10 = token_parser.TokenFieldpart2off_10();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                offset10,
                part2J1,
                part2J2,
                part2off_10,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:588:1, end:588:12))"]
#[derive(Clone, Debug)]
struct ThArmAddr23Var1 {
    part2J1: TokenField_part2J1,
    part2J2: TokenField_part2J2,
    offset10: TokenField_offset10,
    part2off_10: TokenField_part2off_10,
}
impl ThArmAddr23Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128)
            & 4294967292i128)
            .wrapping_add(
                ((((u32::try_from(24i128)
                    .ok()
                    .map(|shl| (-1i128).checked_shl(shl))
                    .flatten()
                    .unwrap_or(0)
                    | u32::try_from(23i128)
                        .ok()
                        .map(|shl| self.part2J1.disassembly().checked_shl(shl))
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(22i128)
                        .ok()
                        .map(|shl| self.part2J2.disassembly().checked_shl(shl))
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .map(|shl| self.offset10.disassembly().checked_shl(shl))
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(2i128)
                        .ok()
                        .map(|shl| {
                            self.part2off_10.disassembly().checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0)),
            );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldoffset10S().disassembly() != 1i128 {
            return None;
        }
        let offset10 = token_parser.TokenFieldoffset10();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128)
            & 4294967292i128)
            .wrapping_add(
                ((((u32::try_from(24i128)
                    .ok()
                    .map(|shl| (-1i128).checked_shl(shl))
                    .flatten()
                    .unwrap_or(0)
                    | u32::try_from(23i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldpart2J1()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(22i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldpart2J2()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldoffset10()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0))
                    | u32::try_from(2i128)
                        .ok()
                        .map(|shl| {
                            token_parser
                                .TokenFieldpart2off_10()
                                .disassembly()
                                .checked_shl(shl)
                        })
                        .flatten()
                        .unwrap_or(0)),
            );
        let part2J1 = token_parser.TokenFieldpart2J1();
        let part2J2 = token_parser.TokenFieldpart2J2();
        let part2off_10 = token_parser.TokenFieldpart2off_10();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                offset10,
                part2J1,
                part2J2,
                part2off_10,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableThArmAddr23 {
    Var0(ThArmAddr23Var0),
    Var1(ThArmAddr23Var1),
}
impl TableThArmAddr23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = ThArmAddr23Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = ThArmAddr23Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:597:1, end:597:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar0 {
    Rn0810: TokenField_Rn0810,
}
impl Rn_exclaimVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rn0810.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldthc0000().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:598:1, end:598:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar1 {
    Rn0810: TokenField_Rn0810,
}
impl Rn_exclaimVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rn0810.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0101().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:599:1, end:599:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar2 {
    Rn0810: TokenField_Rn0810,
}
impl Rn_exclaimVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rn0810.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldthc0202().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:600:1, end:600:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar3 {
    Rn0810: TokenField_Rn0810,
}
impl Rn_exclaimVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rn0810.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldthc0303().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:601:1, end:601:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar4 {
    Rn0810: TokenField_Rn0810,
}
impl Rn_exclaimVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rn0810.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:602:1, end:602:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar5 {
    Rn0810: TokenField_Rn0810,
}
impl Rn_exclaimVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rn0810.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:603:1, end:603:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar6 {
    Rn0810: TokenField_Rn0810,
}
impl Rn_exclaimVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rn0810.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldthc0606().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:604:1, end:604:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar7 {
    Rn0810: TokenField_Rn0810,
}
impl Rn_exclaimVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rn0810.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldthc0707().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:605:1, end:605:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar8 {
    Rn0810: TokenField_Rn0810,
}
impl Rn_exclaimVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.Rn0810.display(), DisplayElement::Literal("!")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let Rn0810 = token_parser.TokenFieldRn0810();
        let thc0810 = token_parser.TokenFieldthc0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[derive(Clone, Debug)]
enum TableRn_exclaim {
    Var0(Rn_exclaimVar0),
    Var1(Rn_exclaimVar1),
    Var2(Rn_exclaimVar2),
    Var3(Rn_exclaimVar3),
    Var4(Rn_exclaimVar4),
    Var5(Rn_exclaimVar5),
    Var6(Rn_exclaimVar6),
    Var7(Rn_exclaimVar7),
    Var8(Rn_exclaimVar8),
}
impl TableRn_exclaim {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = Rn_exclaimVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaimVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaimVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaimVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaimVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaimVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaimVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaimVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaimVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:607:1, end:607:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar0 {}
impl Rn_exclaim_WBVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldthc0000().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:608:1, end:608:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar1 {}
impl Rn_exclaim_WBVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0101().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:609:1, end:609:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar2 {}
impl Rn_exclaim_WBVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldthc0202().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:610:1, end:610:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar3 {}
impl Rn_exclaim_WBVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldthc0303().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:611:1, end:611:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar4 {}
impl Rn_exclaim_WBVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:612:1, end:612:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar5 {}
impl Rn_exclaim_WBVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:613:1, end:613:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar6 {}
impl Rn_exclaim_WBVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldthc0606().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:614:1, end:614:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar7 {}
impl Rn_exclaim_WBVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0810().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldthc0707().disassembly() != 1i128 {
            return None;
        }
        let Rn0810 = token_parser.TokenFieldRn0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:615:1, end:615:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar8 {}
impl Rn_exclaim_WBVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let Rn0810 = token_parser.TokenFieldRn0810();
        let thc0810 = token_parser.TokenFieldthc0810();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableRn_exclaim_WB {
    Var0(Rn_exclaim_WBVar0),
    Var1(Rn_exclaim_WBVar1),
    Var2(Rn_exclaim_WBVar2),
    Var3(Rn_exclaim_WBVar3),
    Var4(Rn_exclaim_WBVar4),
    Var5(Rn_exclaim_WBVar5),
    Var6(Rn_exclaim_WBVar6),
    Var7(Rn_exclaim_WBVar7),
    Var8(Rn_exclaim_WBVar8),
}
impl TableRn_exclaim_WB {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = Rn_exclaim_WBVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaim_WBVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaim_WBVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaim_WBVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaim_WBVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaim_WBVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaim_WBVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaim_WBVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) = Rn_exclaim_WBVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:618:1, end:618:9))"]
#[derive(Clone, Debug)]
struct LdRtype0Var0 {}
impl LdRtype0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0107().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:619:1, end:619:9))"]
#[derive(Clone, Debug)]
struct LdRtype0Var1 {}
impl LdRtype0Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:620:1, end:620:9))"]
#[derive(Clone, Debug)]
struct LdRtype0Var2 {}
impl LdRtype0Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableLdRtype0 {
    Var0(LdRtype0Var0),
    Var1(LdRtype0Var1),
    Var2(LdRtype0Var2),
}
impl TableLdRtype0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LdRtype0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LdRtype0Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LdRtype0Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:621:1, end:621:9))"]
#[derive(Clone, Debug)]
struct LdRtype1Var0 {
    LdRtype0: TableLdRtype0,
}
impl LdRtype1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0207().disassembly() != 0i128 {
            return None;
        }
        let LdRtype0 = if let Some((len, table)) = TableLdRtype0::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:622:1, end:622:9))"]
#[derive(Clone, Debug)]
struct LdRtype1Var1 {
    LdRtype0: TableLdRtype0,
}
impl LdRtype1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 1i128 {
            return None;
        }
        let LdRtype0 = if let Some((len, table)) = TableLdRtype0::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:623:1, end:623:9))"]
#[derive(Clone, Debug)]
struct LdRtype1Var2 {
    LdRtype0: TableLdRtype0,
}
impl LdRtype1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 0i128 {
            return None;
        }
        let LdRtype0 = if let Some((len, table)) = TableLdRtype0::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype0 }))
    }
}
#[derive(Clone, Debug)]
enum TableLdRtype1 {
    Var0(LdRtype1Var0),
    Var1(LdRtype1Var1),
    Var2(LdRtype1Var2),
}
impl TableLdRtype1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LdRtype1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LdRtype1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LdRtype1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:624:1, end:624:9))"]
#[derive(Clone, Debug)]
struct LdRtype2Var0 {
    LdRtype1: TableLdRtype1,
}
impl LdRtype2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0307().disassembly() != 0i128 {
            return None;
        }
        let LdRtype1 = if let Some((len, table)) = TableLdRtype1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:625:1, end:625:9))"]
#[derive(Clone, Debug)]
struct LdRtype2Var1 {
    LdRtype1: TableLdRtype1,
}
impl LdRtype2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 1i128 {
            return None;
        }
        let LdRtype1 = if let Some((len, table)) = TableLdRtype1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:626:1, end:626:9))"]
#[derive(Clone, Debug)]
struct LdRtype2Var2 {
    LdRtype1: TableLdRtype1,
}
impl LdRtype2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 0i128 {
            return None;
        }
        let LdRtype1 = if let Some((len, table)) = TableLdRtype1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype1 }))
    }
}
#[derive(Clone, Debug)]
enum TableLdRtype2 {
    Var0(LdRtype2Var0),
    Var1(LdRtype2Var1),
    Var2(LdRtype2Var2),
}
impl TableLdRtype2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LdRtype2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LdRtype2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LdRtype2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:627:1, end:627:9))"]
#[derive(Clone, Debug)]
struct LdRtype3Var0 {
    LdRtype2: TableLdRtype2,
}
impl LdRtype3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0407().disassembly() != 0i128 {
            return None;
        }
        let LdRtype2 = if let Some((len, table)) = TableLdRtype2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:628:1, end:628:9))"]
#[derive(Clone, Debug)]
struct LdRtype3Var1 {
    LdRtype2: TableLdRtype2,
}
impl LdRtype3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 1i128 {
            return None;
        }
        let LdRtype2 = if let Some((len, table)) = TableLdRtype2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:629:1, end:629:9))"]
#[derive(Clone, Debug)]
struct LdRtype3Var2 {
    LdRtype2: TableLdRtype2,
}
impl LdRtype3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 0i128 {
            return None;
        }
        let LdRtype2 = if let Some((len, table)) = TableLdRtype2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype2 }))
    }
}
#[derive(Clone, Debug)]
enum TableLdRtype3 {
    Var0(LdRtype3Var0),
    Var1(LdRtype3Var1),
    Var2(LdRtype3Var2),
}
impl TableLdRtype3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LdRtype3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LdRtype3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LdRtype3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:630:1, end:630:9))"]
#[derive(Clone, Debug)]
struct LdRtype4Var0 {
    LdRtype3: TableLdRtype3,
}
impl LdRtype4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0507().disassembly() != 0i128 {
            return None;
        }
        let LdRtype3 = if let Some((len, table)) = TableLdRtype3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:631:1, end:631:9))"]
#[derive(Clone, Debug)]
struct LdRtype4Var1 {
    LdRtype3: TableLdRtype3,
}
impl LdRtype4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        let LdRtype3 = if let Some((len, table)) = TableLdRtype3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:632:1, end:632:9))"]
#[derive(Clone, Debug)]
struct LdRtype4Var2 {
    LdRtype3: TableLdRtype3,
}
impl LdRtype4Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 0i128 {
            return None;
        }
        let LdRtype3 = if let Some((len, table)) = TableLdRtype3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype3 }))
    }
}
#[derive(Clone, Debug)]
enum TableLdRtype4 {
    Var0(LdRtype4Var0),
    Var1(LdRtype4Var1),
    Var2(LdRtype4Var2),
}
impl TableLdRtype4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LdRtype4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LdRtype4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LdRtype4Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:633:1, end:633:9))"]
#[derive(Clone, Debug)]
struct LdRtype5Var0 {
    LdRtype4: TableLdRtype4,
}
impl LdRtype5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0607().disassembly() != 0i128 {
            return None;
        }
        let LdRtype4 = if let Some((len, table)) = TableLdRtype4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:634:1, end:634:9))"]
#[derive(Clone, Debug)]
struct LdRtype5Var1 {
    LdRtype4: TableLdRtype4,
}
impl LdRtype5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        let LdRtype4 = if let Some((len, table)) = TableLdRtype4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:635:1, end:635:9))"]
#[derive(Clone, Debug)]
struct LdRtype5Var2 {
    LdRtype4: TableLdRtype4,
}
impl LdRtype5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 0i128 {
            return None;
        }
        let LdRtype4 = if let Some((len, table)) = TableLdRtype4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype4 }))
    }
}
#[derive(Clone, Debug)]
enum TableLdRtype5 {
    Var0(LdRtype5Var0),
    Var1(LdRtype5Var1),
    Var2(LdRtype5Var2),
}
impl TableLdRtype5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LdRtype5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LdRtype5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LdRtype5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:636:1, end:636:9))"]
#[derive(Clone, Debug)]
struct LdRtype6Var0 {
    LdRtype5: TableLdRtype5,
}
impl LdRtype6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0707().disassembly() != 0i128 {
            return None;
        }
        let LdRtype5 = if let Some((len, table)) = TableLdRtype5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:637:1, end:637:9))"]
#[derive(Clone, Debug)]
struct LdRtype6Var1 {
    LdRtype5: TableLdRtype5,
}
impl LdRtype6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 1i128 {
            return None;
        }
        let LdRtype5 = if let Some((len, table)) = TableLdRtype5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:638:1, end:638:9))"]
#[derive(Clone, Debug)]
struct LdRtype6Var2 {
    LdRtype5: TableLdRtype5,
}
impl LdRtype6Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 0i128 {
            return None;
        }
        let LdRtype5 = if let Some((len, table)) = TableLdRtype5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype5 }))
    }
}
#[derive(Clone, Debug)]
enum TableLdRtype6 {
    Var0(LdRtype6Var0),
    Var1(LdRtype6Var1),
    Var2(LdRtype6Var2),
}
impl TableLdRtype6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LdRtype6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LdRtype6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LdRtype6Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:639:1, end:639:7))"]
#[derive(Clone, Debug)]
struct ldlistVar0 {
    LdRtype6: TableLdRtype6,
}
impl ldlistVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0707().disassembly() != 1i128 {
            return None;
        }
        let LdRtype6 = if let Some((len, table)) = TableLdRtype6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:640:1, end:640:7))"]
#[derive(Clone, Debug)]
struct ldlistVar1 {
    LdRtype6: TableLdRtype6,
}
impl ldlistVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.LdRtype6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0707().disassembly() != 0i128 {
            return None;
        }
        let LdRtype6 = if let Some((len, table)) = TableLdRtype6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype6 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldlist {
    Var0(ldlistVar0),
    Var1(ldlistVar1),
}
impl Tableldlist {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldlistVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldlistVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:643:1, end:643:9))"]
#[derive(Clone, Debug)]
struct StrType0Var0 {}
impl StrType0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0107().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:644:1, end:644:9))"]
#[derive(Clone, Debug)]
struct StrType0Var1 {}
impl StrType0Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:645:1, end:645:9))"]
#[derive(Clone, Debug)]
struct StrType0Var2 {}
impl StrType0Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableStrType0 {
    Var0(StrType0Var0),
    Var1(StrType0Var1),
    Var2(StrType0Var2),
}
impl TableStrType0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            StrType0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType0Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType0Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:646:1, end:646:9))"]
#[derive(Clone, Debug)]
struct StrType1Var0 {
    StrType0: TableStrType0,
}
impl StrType1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0207().disassembly() != 0i128 {
            return None;
        }
        let StrType0 = if let Some((len, table)) = TableStrType0::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:647:1, end:647:9))"]
#[derive(Clone, Debug)]
struct StrType1Var1 {
    StrType0: TableStrType0,
}
impl StrType1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 1i128 {
            return None;
        }
        let StrType0 = if let Some((len, table)) = TableStrType0::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:648:1, end:648:9))"]
#[derive(Clone, Debug)]
struct StrType1Var2 {
    StrType0: TableStrType0,
}
impl StrType1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 0i128 {
            return None;
        }
        let StrType0 = if let Some((len, table)) = TableStrType0::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType0 }))
    }
}
#[derive(Clone, Debug)]
enum TableStrType1 {
    Var0(StrType1Var0),
    Var1(StrType1Var1),
    Var2(StrType1Var2),
}
impl TableStrType1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            StrType1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:649:1, end:649:9))"]
#[derive(Clone, Debug)]
struct StrType2Var0 {
    StrType1: TableStrType1,
}
impl StrType2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0307().disassembly() != 0i128 {
            return None;
        }
        let StrType1 = if let Some((len, table)) = TableStrType1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:650:1, end:650:9))"]
#[derive(Clone, Debug)]
struct StrType2Var1 {
    StrType1: TableStrType1,
}
impl StrType2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 1i128 {
            return None;
        }
        let StrType1 = if let Some((len, table)) = TableStrType1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:651:1, end:651:9))"]
#[derive(Clone, Debug)]
struct StrType2Var2 {
    StrType1: TableStrType1,
}
impl StrType2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 0i128 {
            return None;
        }
        let StrType1 = if let Some((len, table)) = TableStrType1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType1 }))
    }
}
#[derive(Clone, Debug)]
enum TableStrType2 {
    Var0(StrType2Var0),
    Var1(StrType2Var1),
    Var2(StrType2Var2),
}
impl TableStrType2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            StrType2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:652:1, end:652:9))"]
#[derive(Clone, Debug)]
struct StrType3Var0 {
    StrType2: TableStrType2,
}
impl StrType3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0407().disassembly() != 0i128 {
            return None;
        }
        let StrType2 = if let Some((len, table)) = TableStrType2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:653:1, end:653:9))"]
#[derive(Clone, Debug)]
struct StrType3Var1 {
    StrType2: TableStrType2,
}
impl StrType3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 1i128 {
            return None;
        }
        let StrType2 = if let Some((len, table)) = TableStrType2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:654:1, end:654:9))"]
#[derive(Clone, Debug)]
struct StrType3Var2 {
    StrType2: TableStrType2,
}
impl StrType3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 0i128 {
            return None;
        }
        let StrType2 = if let Some((len, table)) = TableStrType2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType2 }))
    }
}
#[derive(Clone, Debug)]
enum TableStrType3 {
    Var0(StrType3Var0),
    Var1(StrType3Var1),
    Var2(StrType3Var2),
}
impl TableStrType3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            StrType3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:655:1, end:655:9))"]
#[derive(Clone, Debug)]
struct StrType4Var0 {
    StrType3: TableStrType3,
}
impl StrType4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0507().disassembly() != 0i128 {
            return None;
        }
        let StrType3 = if let Some((len, table)) = TableStrType3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:656:1, end:656:9))"]
#[derive(Clone, Debug)]
struct StrType4Var1 {
    StrType3: TableStrType3,
}
impl StrType4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        let StrType3 = if let Some((len, table)) = TableStrType3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:657:1, end:657:9))"]
#[derive(Clone, Debug)]
struct StrType4Var2 {
    StrType3: TableStrType3,
}
impl StrType4Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 0i128 {
            return None;
        }
        let StrType3 = if let Some((len, table)) = TableStrType3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType3 }))
    }
}
#[derive(Clone, Debug)]
enum TableStrType4 {
    Var0(StrType4Var0),
    Var1(StrType4Var1),
    Var2(StrType4Var2),
}
impl TableStrType4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            StrType4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType4Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:658:1, end:658:9))"]
#[derive(Clone, Debug)]
struct StrType5Var0 {
    StrType4: TableStrType4,
}
impl StrType5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0607().disassembly() != 0i128 {
            return None;
        }
        let StrType4 = if let Some((len, table)) = TableStrType4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:659:1, end:659:9))"]
#[derive(Clone, Debug)]
struct StrType5Var1 {
    StrType4: TableStrType4,
}
impl StrType5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        let StrType4 = if let Some((len, table)) = TableStrType4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:660:1, end:660:9))"]
#[derive(Clone, Debug)]
struct StrType5Var2 {
    StrType4: TableStrType4,
}
impl StrType5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 0i128 {
            return None;
        }
        let StrType4 = if let Some((len, table)) = TableStrType4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType4 }))
    }
}
#[derive(Clone, Debug)]
enum TableStrType5 {
    Var0(StrType5Var0),
    Var1(StrType5Var1),
    Var2(StrType5Var2),
}
impl TableStrType5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            StrType5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:661:1, end:661:9))"]
#[derive(Clone, Debug)]
struct StrType6Var0 {
    StrType5: TableStrType5,
}
impl StrType6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0707().disassembly() != 0i128 {
            return None;
        }
        let StrType5 = if let Some((len, table)) = TableStrType5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:662:1, end:662:9))"]
#[derive(Clone, Debug)]
struct StrType6Var1 {
    StrType5: TableStrType5,
}
impl StrType6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 1i128 {
            return None;
        }
        let StrType5 = if let Some((len, table)) = TableStrType5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:663:1, end:663:9))"]
#[derive(Clone, Debug)]
struct StrType6Var2 {
    StrType5: TableStrType5,
}
impl StrType6Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 0i128 {
            return None;
        }
        let StrType5 = if let Some((len, table)) = TableStrType5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType5 }))
    }
}
#[derive(Clone, Debug)]
enum TableStrType6 {
    Var0(StrType6Var0),
    Var1(StrType6Var1),
    Var2(StrType6Var2),
}
impl TableStrType6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            StrType6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType6Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:664:1, end:664:9))"]
#[derive(Clone, Debug)]
struct StrType7Var0 {
    StrType6: TableStrType6,
}
impl StrType7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0707().disassembly() != 1i128 {
            return None;
        }
        let StrType6 = if let Some((len, table)) = TableStrType6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:665:1, end:665:9))"]
#[derive(Clone, Debug)]
struct StrType7Var1 {
    StrType6: TableStrType6,
}
impl StrType7Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0707().disassembly() != 0i128 {
            return None;
        }
        let StrType6 = if let Some((len, table)) = TableStrType6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType6 }))
    }
}
#[derive(Clone, Debug)]
enum TableStrType7 {
    Var0(StrType7Var0),
    Var1(StrType7Var1),
}
impl TableStrType7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            StrType7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            StrType7Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:666:1, end:666:8))"]
#[derive(Clone, Debug)]
struct strlistVar0 {
    StrType7: TableStrType7,
}
impl strlistVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.StrType7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let StrType7 = if let Some((len, table)) = TableStrType7::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablestrlist {
    Var0(strlistVar0),
}
impl Tablestrlist {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            strlistVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:672:1, end:672:9))"]
#[derive(Clone, Debug)]
struct PshType7Var0 {}
impl PshType7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0707().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:673:1, end:673:9))"]
#[derive(Clone, Debug)]
struct PshType7Var1 {}
impl PshType7Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0707().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablePshType7 {
    Var0(PshType7Var0),
    Var1(PshType7Var1),
}
impl TablePshType7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            PshType7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            PshType7Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:675:1, end:675:9))"]
#[derive(Clone, Debug)]
struct PshType6Var0 {}
impl PshType6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0707().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:674:1, end:674:9))"]
#[derive(Clone, Debug)]
struct PshType6Var1 {
    PshType7: TablePshType7,
}
impl PshType6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.PshType7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 0i128 {
            return None;
        }
        let PshType7 = if let Some((len, table)) = TablePshType7::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:676:1, end:676:9))"]
#[derive(Clone, Debug)]
struct PshType6Var2 {
    PshType7: TablePshType7,
}
impl PshType6Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.PshType7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 1i128 {
            return None;
        }
        let PshType7 = if let Some((len, table)) = TablePshType7::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType7 }))
    }
}
#[derive(Clone, Debug)]
enum TablePshType6 {
    Var0(PshType6Var0),
    Var1(PshType6Var1),
    Var2(PshType6Var2),
}
impl TablePshType6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            PshType6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            PshType6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            PshType6Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:678:1, end:678:9))"]
#[derive(Clone, Debug)]
struct PshType5Var0 {}
impl PshType5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0607().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:677:1, end:677:9))"]
#[derive(Clone, Debug)]
struct PshType5Var1 {
    PshType6: TablePshType6,
}
impl PshType5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.PshType6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 0i128 {
            return None;
        }
        let PshType6 = if let Some((len, table)) = TablePshType6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:679:1, end:679:9))"]
#[derive(Clone, Debug)]
struct PshType5Var2 {
    PshType6: TablePshType6,
}
impl PshType5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.PshType6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        let PshType6 = if let Some((len, table)) = TablePshType6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType6 }))
    }
}
#[derive(Clone, Debug)]
enum TablePshType5 {
    Var0(PshType5Var0),
    Var1(PshType5Var1),
    Var2(PshType5Var2),
}
impl TablePshType5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            PshType5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            PshType5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            PshType5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:681:1, end:681:9))"]
#[derive(Clone, Debug)]
struct PshType4Var0 {}
impl PshType4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0507().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:680:1, end:680:9))"]
#[derive(Clone, Debug)]
struct PshType4Var1 {
    PshType5: TablePshType5,
}
impl PshType4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.PshType5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 0i128 {
            return None;
        }
        let PshType5 = if let Some((len, table)) = TablePshType5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:682:1, end:682:9))"]
#[derive(Clone, Debug)]
struct PshType4Var2 {
    PshType5: TablePshType5,
}
impl PshType4Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.PshType5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        let PshType5 = if let Some((len, table)) = TablePshType5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType5 }))
    }
}
#[derive(Clone, Debug)]
enum TablePshType4 {
    Var0(PshType4Var0),
    Var1(PshType4Var1),
    Var2(PshType4Var2),
}
impl TablePshType4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            PshType4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            PshType4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            PshType4Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:684:1, end:684:9))"]
#[derive(Clone, Debug)]
struct PshType3Var0 {}
impl PshType3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0407().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:683:1, end:683:9))"]
#[derive(Clone, Debug)]
struct PshType3Var1 {
    PshType4: TablePshType4,
}
impl PshType3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.PshType4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 0i128 {
            return None;
        }
        let PshType4 = if let Some((len, table)) = TablePshType4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:685:1, end:685:9))"]
#[derive(Clone, Debug)]
struct PshType3Var2 {
    PshType4: TablePshType4,
}
impl PshType3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.PshType4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 1i128 {
            return None;
        }
        let PshType4 = if let Some((len, table)) = TablePshType4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType4 }))
    }
}
#[derive(Clone, Debug)]
enum TablePshType3 {
    Var0(PshType3Var0),
    Var1(PshType3Var1),
    Var2(PshType3Var2),
}
impl TablePshType3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            PshType3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            PshType3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            PshType3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:687:1, end:687:9))"]
#[derive(Clone, Debug)]
struct PshType2Var0 {}
impl PshType2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0307().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:686:1, end:686:9))"]
#[derive(Clone, Debug)]
struct PshType2Var1 {
    PshType3: TablePshType3,
}
impl PshType2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.PshType3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 0i128 {
            return None;
        }
        let PshType3 = if let Some((len, table)) = TablePshType3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:688:1, end:688:9))"]
#[derive(Clone, Debug)]
struct PshType2Var2 {
    PshType3: TablePshType3,
}
impl PshType2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.PshType3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 1i128 {
            return None;
        }
        let PshType3 = if let Some((len, table)) = TablePshType3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType3 }))
    }
}
#[derive(Clone, Debug)]
enum TablePshType2 {
    Var0(PshType2Var0),
    Var1(PshType2Var1),
    Var2(PshType2Var2),
}
impl TablePshType2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            PshType2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            PshType2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            PshType2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:690:1, end:690:9))"]
#[derive(Clone, Debug)]
struct PshType1Var0 {}
impl PshType1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0207().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:689:1, end:689:9))"]
#[derive(Clone, Debug)]
struct PshType1Var1 {
    PshType2: TablePshType2,
}
impl PshType1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.PshType2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 0i128 {
            return None;
        }
        let PshType2 = if let Some((len, table)) = TablePshType2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:691:1, end:691:9))"]
#[derive(Clone, Debug)]
struct PshType1Var2 {
    PshType2: TablePshType2,
}
impl PshType1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.PshType2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 1i128 {
            return None;
        }
        let PshType2 = if let Some((len, table)) = TablePshType2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType2 }))
    }
}
#[derive(Clone, Debug)]
enum TablePshType1 {
    Var0(PshType1Var0),
    Var1(PshType1Var1),
    Var2(PshType1Var2),
}
impl TablePshType1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            PshType1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            PshType1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            PshType1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:693:1, end:693:8))"]
#[derive(Clone, Debug)]
struct pshlistVar0 {}
impl pshlistVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0107().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:692:1, end:692:8))"]
#[derive(Clone, Debug)]
struct pshlistVar1 {
    PshType1: TablePshType1,
}
impl pshlistVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.PshType1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 0i128 {
            return None;
        }
        let PshType1 = if let Some((len, table)) = TablePshType1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:694:1, end:694:8))"]
#[derive(Clone, Debug)]
struct pshlistVar2 {
    PshType1: TablePshType1,
}
impl pshlistVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.PshType1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 1i128 {
            return None;
        }
        let PshType1 = if let Some((len, table)) = TablePshType1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablepshlist {
    Var0(pshlistVar0),
    Var1(pshlistVar1),
    Var2(pshlistVar2),
}
impl Tablepshlist {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            pshlistVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            pshlistVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            pshlistVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:697:1, end:697:10))"]
#[derive(Clone, Debug)]
struct thrlist15Var0 {}
impl thrlist15Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0115().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:698:1, end:698:10))"]
#[derive(Clone, Debug)]
struct thrlist15Var1 {}
impl thrlist15Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:699:1, end:699:10))"]
#[derive(Clone, Debug)]
struct thrlist15Var2 {}
impl thrlist15Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist15 {
    Var0(thrlist15Var0),
    Var1(thrlist15Var1),
    Var2(thrlist15Var2),
}
impl Tablethrlist15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist15Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist15Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist15Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:700:1, end:700:10))"]
#[derive(Clone, Debug)]
struct thrlist14Var0 {
    thrlist15: Tablethrlist15,
}
impl thrlist14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0215().disassembly() != 0i128 {
            return None;
        }
        let thrlist15 = if let Some((len, table)) = Tablethrlist15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:701:1, end:701:10))"]
#[derive(Clone, Debug)]
struct thrlist14Var1 {
    thrlist15: Tablethrlist15,
}
impl thrlist14Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 1i128 {
            return None;
        }
        let thrlist15 = if let Some((len, table)) = Tablethrlist15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:702:1, end:702:10))"]
#[derive(Clone, Debug)]
struct thrlist14Var2 {
    thrlist15: Tablethrlist15,
}
impl thrlist14Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 0i128 {
            return None;
        }
        let thrlist15 = if let Some((len, table)) = Tablethrlist15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist14 {
    Var0(thrlist14Var0),
    Var1(thrlist14Var1),
    Var2(thrlist14Var2),
}
impl Tablethrlist14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist14Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist14Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist14Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:703:1, end:703:10))"]
#[derive(Clone, Debug)]
struct thrlist13Var0 {
    thrlist14: Tablethrlist14,
}
impl thrlist13Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0315().disassembly() != 0i128 {
            return None;
        }
        let thrlist14 = if let Some((len, table)) = Tablethrlist14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:704:1, end:704:10))"]
#[derive(Clone, Debug)]
struct thrlist13Var1 {
    thrlist14: Tablethrlist14,
}
impl thrlist13Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 1i128 {
            return None;
        }
        let thrlist14 = if let Some((len, table)) = Tablethrlist14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:705:1, end:705:10))"]
#[derive(Clone, Debug)]
struct thrlist13Var2 {
    thrlist14: Tablethrlist14,
}
impl thrlist13Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 0i128 {
            return None;
        }
        let thrlist14 = if let Some((len, table)) = Tablethrlist14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist13 {
    Var0(thrlist13Var0),
    Var1(thrlist13Var1),
    Var2(thrlist13Var2),
}
impl Tablethrlist13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist13Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist13Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist13Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:706:1, end:706:10))"]
#[derive(Clone, Debug)]
struct thrlist12Var0 {
    thrlist13: Tablethrlist13,
}
impl thrlist12Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0415().disassembly() != 0i128 {
            return None;
        }
        let thrlist13 = if let Some((len, table)) = Tablethrlist13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:707:1, end:707:10))"]
#[derive(Clone, Debug)]
struct thrlist12Var1 {
    thrlist13: Tablethrlist13,
}
impl thrlist12Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 1i128 {
            return None;
        }
        let thrlist13 = if let Some((len, table)) = Tablethrlist13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:708:1, end:708:10))"]
#[derive(Clone, Debug)]
struct thrlist12Var2 {
    thrlist13: Tablethrlist13,
}
impl thrlist12Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 0i128 {
            return None;
        }
        let thrlist13 = if let Some((len, table)) = Tablethrlist13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist12 {
    Var0(thrlist12Var0),
    Var1(thrlist12Var1),
    Var2(thrlist12Var2),
}
impl Tablethrlist12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist12Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist12Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist12Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:709:1, end:709:10))"]
#[derive(Clone, Debug)]
struct thrlist11Var0 {
    thrlist12: Tablethrlist12,
}
impl thrlist11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0515().disassembly() != 0i128 {
            return None;
        }
        let thrlist12 = if let Some((len, table)) = Tablethrlist12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:710:1, end:710:10))"]
#[derive(Clone, Debug)]
struct thrlist11Var1 {
    thrlist12: Tablethrlist12,
}
impl thrlist11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        let thrlist12 = if let Some((len, table)) = Tablethrlist12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:711:1, end:711:10))"]
#[derive(Clone, Debug)]
struct thrlist11Var2 {
    thrlist12: Tablethrlist12,
}
impl thrlist11Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 0i128 {
            return None;
        }
        let thrlist12 = if let Some((len, table)) = Tablethrlist12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist11 {
    Var0(thrlist11Var0),
    Var1(thrlist11Var1),
    Var2(thrlist11Var2),
}
impl Tablethrlist11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist11Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist11Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:712:1, end:712:10))"]
#[derive(Clone, Debug)]
struct thrlist10Var0 {
    thrlist11: Tablethrlist11,
}
impl thrlist10Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0615().disassembly() != 0i128 {
            return None;
        }
        let thrlist11 = if let Some((len, table)) = Tablethrlist11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:713:1, end:713:10))"]
#[derive(Clone, Debug)]
struct thrlist10Var1 {
    thrlist11: Tablethrlist11,
}
impl thrlist10Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        let thrlist11 = if let Some((len, table)) = Tablethrlist11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:714:1, end:714:10))"]
#[derive(Clone, Debug)]
struct thrlist10Var2 {
    thrlist11: Tablethrlist11,
}
impl thrlist10Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 0i128 {
            return None;
        }
        let thrlist11 = if let Some((len, table)) = Tablethrlist11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist10 {
    Var0(thrlist10Var0),
    Var1(thrlist10Var1),
    Var2(thrlist10Var2),
}
impl Tablethrlist10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist10Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist10Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist10Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:715:1, end:715:9))"]
#[derive(Clone, Debug)]
struct thrlist9Var0 {
    thrlist10: Tablethrlist10,
}
impl thrlist9Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0715().disassembly() != 0i128 {
            return None;
        }
        let thrlist10 = if let Some((len, table)) = Tablethrlist10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:716:1, end:716:9))"]
#[derive(Clone, Debug)]
struct thrlist9Var1 {
    thrlist10: Tablethrlist10,
}
impl thrlist9Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 1i128 {
            return None;
        }
        let thrlist10 = if let Some((len, table)) = Tablethrlist10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:717:1, end:717:9))"]
#[derive(Clone, Debug)]
struct thrlist9Var2 {
    thrlist10: Tablethrlist10,
}
impl thrlist9Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 0i128 {
            return None;
        }
        let thrlist10 = if let Some((len, table)) = Tablethrlist10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist9 {
    Var0(thrlist9Var0),
    Var1(thrlist9Var1),
    Var2(thrlist9Var2),
}
impl Tablethrlist9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist9Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist9Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist9Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:718:1, end:718:9))"]
#[derive(Clone, Debug)]
struct thrlist8Var0 {
    thrlist9: Tablethrlist9,
}
impl thrlist8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0815().disassembly() != 0i128 {
            return None;
        }
        let thrlist9 = if let Some((len, table)) = Tablethrlist9::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:719:1, end:719:9))"]
#[derive(Clone, Debug)]
struct thrlist8Var1 {
    thrlist9: Tablethrlist9,
}
impl thrlist8Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r7),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0707().disassembly() != 1i128 {
            return None;
        }
        let thrlist9 = if let Some((len, table)) = Tablethrlist9::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:720:1, end:720:9))"]
#[derive(Clone, Debug)]
struct thrlist8Var2 {
    thrlist9: Tablethrlist9,
}
impl thrlist8Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0707().disassembly() != 0i128 {
            return None;
        }
        let thrlist9 = if let Some((len, table)) = Tablethrlist9::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist8 {
    Var0(thrlist8Var0),
    Var1(thrlist8Var1),
    Var2(thrlist8Var2),
}
impl Tablethrlist8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist8Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist8Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:721:1, end:721:9))"]
#[derive(Clone, Debug)]
struct thrlist7Var0 {
    thrlist8: Tablethrlist8,
}
impl thrlist7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0808().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0915().disassembly() != 0i128 {
            return None;
        }
        let thrlist8 = if let Some((len, table)) = Tablethrlist8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:722:1, end:722:9))"]
#[derive(Clone, Debug)]
struct thrlist7Var1 {
    thrlist8: Tablethrlist8,
}
impl thrlist7Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r8),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0808().disassembly() != 1i128 {
            return None;
        }
        let thrlist8 = if let Some((len, table)) = Tablethrlist8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:723:1, end:723:9))"]
#[derive(Clone, Debug)]
struct thrlist7Var2 {
    thrlist8: Tablethrlist8,
}
impl thrlist7Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0808().disassembly() != 0i128 {
            return None;
        }
        let thrlist8 = if let Some((len, table)) = Tablethrlist8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist7 {
    Var0(thrlist7Var0),
    Var1(thrlist7Var1),
    Var2(thrlist7Var2),
}
impl Tablethrlist7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist7Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist7Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:724:1, end:724:9))"]
#[derive(Clone, Debug)]
struct thrlist6Var0 {
    thrlist7: Tablethrlist7,
}
impl thrlist6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0909().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc1015().disassembly() != 0i128 {
            return None;
        }
        let thrlist7 = if let Some((len, table)) = Tablethrlist7::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:725:1, end:725:9))"]
#[derive(Clone, Debug)]
struct thrlist6Var1 {
    thrlist7: Tablethrlist7,
}
impl thrlist6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r9),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0909().disassembly() != 1i128 {
            return None;
        }
        let thrlist7 = if let Some((len, table)) = Tablethrlist7::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:726:1, end:726:9))"]
#[derive(Clone, Debug)]
struct thrlist6Var2 {
    thrlist7: Tablethrlist7,
}
impl thrlist6Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0909().disassembly() != 0i128 {
            return None;
        }
        let thrlist7 = if let Some((len, table)) = Tablethrlist7::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist6 {
    Var0(thrlist6Var0),
    Var1(thrlist6Var1),
    Var2(thrlist6Var2),
}
impl Tablethrlist6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist6Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:727:1, end:727:9))"]
#[derive(Clone, Debug)]
struct thrlist5Var0 {
    thrlist6: Tablethrlist6,
}
impl thrlist5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1010().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc1115().disassembly() != 0i128 {
            return None;
        }
        let thrlist6 = if let Some((len, table)) = Tablethrlist6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:728:1, end:728:9))"]
#[derive(Clone, Debug)]
struct thrlist5Var1 {
    thrlist6: Tablethrlist6,
}
impl thrlist5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r10),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1010().disassembly() != 1i128 {
            return None;
        }
        let thrlist6 = if let Some((len, table)) = Tablethrlist6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:729:1, end:729:9))"]
#[derive(Clone, Debug)]
struct thrlist5Var2 {
    thrlist6: Tablethrlist6,
}
impl thrlist5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1010().disassembly() != 0i128 {
            return None;
        }
        let thrlist6 = if let Some((len, table)) = Tablethrlist6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist5 {
    Var0(thrlist5Var0),
    Var1(thrlist5Var1),
    Var2(thrlist5Var2),
}
impl Tablethrlist5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:730:1, end:730:9))"]
#[derive(Clone, Debug)]
struct thrlist4Var0 {
    thrlist5: Tablethrlist5,
}
impl thrlist4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1111().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc1215().disassembly() != 0i128 {
            return None;
        }
        let thrlist5 = if let Some((len, table)) = Tablethrlist5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:731:1, end:731:9))"]
#[derive(Clone, Debug)]
struct thrlist4Var1 {
    thrlist5: Tablethrlist5,
}
impl thrlist4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r11),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1111().disassembly() != 1i128 {
            return None;
        }
        let thrlist5 = if let Some((len, table)) = Tablethrlist5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:732:1, end:732:9))"]
#[derive(Clone, Debug)]
struct thrlist4Var2 {
    thrlist5: Tablethrlist5,
}
impl thrlist4Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1111().disassembly() != 0i128 {
            return None;
        }
        let thrlist5 = if let Some((len, table)) = Tablethrlist5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist4 {
    Var0(thrlist4Var0),
    Var1(thrlist4Var1),
    Var2(thrlist4Var2),
}
impl Tablethrlist4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist4Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:733:1, end:733:9))"]
#[derive(Clone, Debug)]
struct thrlist3Var0 {
    thrlist4: Tablethrlist4,
}
impl thrlist3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1212().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc1315().disassembly() != 0i128 {
            return None;
        }
        let thrlist4 = if let Some((len, table)) = Tablethrlist4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:734:1, end:734:9))"]
#[derive(Clone, Debug)]
struct thrlist3Var1 {
    thrlist4: Tablethrlist4,
}
impl thrlist3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r12),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1212().disassembly() != 1i128 {
            return None;
        }
        let thrlist4 = if let Some((len, table)) = Tablethrlist4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:735:1, end:735:9))"]
#[derive(Clone, Debug)]
struct thrlist3Var2 {
    thrlist4: Tablethrlist4,
}
impl thrlist3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1212().disassembly() != 0i128 {
            return None;
        }
        let thrlist4 = if let Some((len, table)) = Tablethrlist4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist3 {
    Var0(thrlist3Var0),
    Var1(thrlist3Var1),
    Var2(thrlist3Var2),
}
impl Tablethrlist3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:736:1, end:736:9))"]
#[derive(Clone, Debug)]
struct thrlist2Var0 {
    thrlist3: Tablethrlist3,
}
impl thrlist2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1313().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc1415().disassembly() != 0i128 {
            return None;
        }
        let thrlist3 = if let Some((len, table)) = Tablethrlist3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:737:1, end:737:9))"]
#[derive(Clone, Debug)]
struct thrlist2Var1 {
    thrlist3: Tablethrlist3,
}
impl thrlist2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1313().disassembly() != 1i128 {
            return None;
        }
        let thrlist3 = if let Some((len, table)) = Tablethrlist3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:738:1, end:738:9))"]
#[derive(Clone, Debug)]
struct thrlist2Var2 {
    thrlist3: Tablethrlist3,
}
impl thrlist2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1313().disassembly() != 0i128 {
            return None;
        }
        let thrlist3 = if let Some((len, table)) = Tablethrlist3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist2 {
    Var0(thrlist2Var0),
    Var1(thrlist2Var1),
    Var2(thrlist2Var2),
}
impl Tablethrlist2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:739:1, end:739:9))"]
#[derive(Clone, Debug)]
struct thrlist1Var0 {
    thrlist2: Tablethrlist2,
}
impl thrlist1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1414().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc1515().disassembly() != 0i128 {
            return None;
        }
        let thrlist2 = if let Some((len, table)) = Tablethrlist2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:740:1, end:740:9))"]
#[derive(Clone, Debug)]
struct thrlist1Var1 {
    thrlist2: Tablethrlist2,
}
impl thrlist1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1414().disassembly() != 1i128 {
            return None;
        }
        let thrlist2 = if let Some((len, table)) = Tablethrlist2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:741:1, end:741:9))"]
#[derive(Clone, Debug)]
struct thrlist1Var2 {
    thrlist2: Tablethrlist2,
}
impl thrlist1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thrlist2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1414().disassembly() != 0i128 {
            return None;
        }
        let thrlist2 = if let Some((len, table)) = Tablethrlist2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist1 {
    Var0(thrlist1Var0),
    Var1(thrlist1Var1),
    Var2(thrlist1Var2),
}
impl Tablethrlist1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thrlist1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thrlist1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:742:1, end:742:14))"]
#[derive(Clone, Debug)]
struct thldrlist_incVar0 {
    thrlist1: Tablethrlist1,
}
impl thldrlist_incVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.thrlist1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1515().disassembly() != 1i128 {
            return None;
        }
        let thrlist1 = if let Some((len, table)) = Tablethrlist1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:743:1, end:743:14))"]
#[derive(Clone, Debug)]
struct thldrlist_incVar1 {
    thrlist1: Tablethrlist1,
}
impl thldrlist_incVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.thrlist1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1515().disassembly() != 0i128 {
            return None;
        }
        let thrlist1 = if let Some((len, table)) = Tablethrlist1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethldrlist_inc {
    Var0(thldrlist_incVar0),
    Var1(thldrlist_incVar1),
}
impl Tablethldrlist_inc {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = thldrlist_incVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = thldrlist_incVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:848:1, end:848:9))"]
#[derive(Clone, Debug)]
struct thsdec15Var0 {}
impl thsdec15Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1515().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:849:1, end:849:9))"]
#[derive(Clone, Debug)]
struct thsdec15Var1 {}
impl thsdec15Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1515().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec15 {
    Var0(thsdec15Var0),
    Var1(thsdec15Var1),
}
impl Tablethsdec15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec15Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec15Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:850:1, end:850:9))"]
#[derive(Clone, Debug)]
struct thsdec14Var0 {
    thsdec15: Tablethsdec15,
}
impl thsdec14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1414().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc1515().disassembly() != 0i128 {
            return None;
        }
        let thsdec15 = if let Some((len, table)) = Tablethsdec15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:851:1, end:851:9))"]
#[derive(Clone, Debug)]
struct thsdec14Var1 {
    thsdec15: Tablethsdec15,
}
impl thsdec14Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1414().disassembly() != 1i128 {
            return None;
        }
        let thsdec15 = if let Some((len, table)) = Tablethsdec15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:852:1, end:852:9))"]
#[derive(Clone, Debug)]
struct thsdec14Var2 {
    thsdec15: Tablethsdec15,
}
impl thsdec14Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thsdec15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1414().disassembly() != 0i128 {
            return None;
        }
        let thsdec15 = if let Some((len, table)) = Tablethsdec15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec14 {
    Var0(thsdec14Var0),
    Var1(thsdec14Var1),
    Var2(thsdec14Var2),
}
impl Tablethsdec14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec14Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec14Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec14Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:853:1, end:853:9))"]
#[derive(Clone, Debug)]
struct thsdec13Var0 {}
impl thsdec13Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1313().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc1415().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:854:1, end:854:9))"]
#[derive(Clone, Debug)]
struct thsdec13Var1 {
    thsdec14: Tablethsdec14,
}
impl thsdec13Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1313().disassembly() != 1i128 {
            return None;
        }
        let thsdec14 = if let Some((len, table)) = Tablethsdec14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:855:1, end:855:9))"]
#[derive(Clone, Debug)]
struct thsdec13Var2 {
    thsdec14: Tablethsdec14,
}
impl thsdec13Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thsdec14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1313().disassembly() != 0i128 {
            return None;
        }
        let thsdec14 = if let Some((len, table)) = Tablethsdec14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec13 {
    Var0(thsdec13Var0),
    Var1(thsdec13Var1),
    Var2(thsdec13Var2),
}
impl Tablethsdec13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec13Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec13Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec13Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:856:1, end:856:9))"]
#[derive(Clone, Debug)]
struct thsdec12Var0 {}
impl thsdec12Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1212().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc1315().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:857:1, end:857:9))"]
#[derive(Clone, Debug)]
struct thsdec12Var1 {
    thsdec13: Tablethsdec13,
}
impl thsdec12Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r12),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1212().disassembly() != 1i128 {
            return None;
        }
        let thsdec13 = if let Some((len, table)) = Tablethsdec13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:858:1, end:858:9))"]
#[derive(Clone, Debug)]
struct thsdec12Var2 {
    thsdec13: Tablethsdec13,
}
impl thsdec12Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thsdec13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1212().disassembly() != 0i128 {
            return None;
        }
        let thsdec13 = if let Some((len, table)) = Tablethsdec13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec12 {
    Var0(thsdec12Var0),
    Var1(thsdec12Var1),
    Var2(thsdec12Var2),
}
impl Tablethsdec12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec12Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec12Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec12Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:859:1, end:859:9))"]
#[derive(Clone, Debug)]
struct thsdec11Var0 {}
impl thsdec11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1111().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc1215().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:860:1, end:860:9))"]
#[derive(Clone, Debug)]
struct thsdec11Var1 {
    thsdec12: Tablethsdec12,
}
impl thsdec11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r11),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1111().disassembly() != 1i128 {
            return None;
        }
        let thsdec12 = if let Some((len, table)) = Tablethsdec12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:861:1, end:861:9))"]
#[derive(Clone, Debug)]
struct thsdec11Var2 {
    thsdec12: Tablethsdec12,
}
impl thsdec11Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thsdec12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1111().disassembly() != 0i128 {
            return None;
        }
        let thsdec12 = if let Some((len, table)) = Tablethsdec12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec11 {
    Var0(thsdec11Var0),
    Var1(thsdec11Var1),
    Var2(thsdec11Var2),
}
impl Tablethsdec11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec11Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec11Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:862:1, end:862:9))"]
#[derive(Clone, Debug)]
struct thsdec10Var0 {}
impl thsdec10Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1010().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc1115().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:863:1, end:863:9))"]
#[derive(Clone, Debug)]
struct thsdec10Var1 {
    thsdec11: Tablethsdec11,
}
impl thsdec10Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r10),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1010().disassembly() != 1i128 {
            return None;
        }
        let thsdec11 = if let Some((len, table)) = Tablethsdec11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:864:1, end:864:9))"]
#[derive(Clone, Debug)]
struct thsdec10Var2 {
    thsdec11: Tablethsdec11,
}
impl thsdec10Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thsdec11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc1010().disassembly() != 0i128 {
            return None;
        }
        let thsdec11 = if let Some((len, table)) = Tablethsdec11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec10 {
    Var0(thsdec10Var0),
    Var1(thsdec10Var1),
    Var2(thsdec10Var2),
}
impl Tablethsdec10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec10Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec10Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec10Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:865:1, end:865:8))"]
#[derive(Clone, Debug)]
struct thsdec9Var0 {}
impl thsdec9Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0909().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc1015().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:866:1, end:866:8))"]
#[derive(Clone, Debug)]
struct thsdec9Var1 {
    thsdec10: Tablethsdec10,
}
impl thsdec9Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r9),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0909().disassembly() != 1i128 {
            return None;
        }
        let thsdec10 = if let Some((len, table)) = Tablethsdec10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:867:1, end:867:8))"]
#[derive(Clone, Debug)]
struct thsdec9Var2 {
    thsdec10: Tablethsdec10,
}
impl thsdec9Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thsdec10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0909().disassembly() != 0i128 {
            return None;
        }
        let thsdec10 = if let Some((len, table)) = Tablethsdec10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec9 {
    Var0(thsdec9Var0),
    Var1(thsdec9Var1),
    Var2(thsdec9Var2),
}
impl Tablethsdec9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec9Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec9Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec9Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:868:1, end:868:8))"]
#[derive(Clone, Debug)]
struct thsdec8Var0 {}
impl thsdec8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0808().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0915().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:869:1, end:869:8))"]
#[derive(Clone, Debug)]
struct thsdec8Var1 {
    thsdec9: Tablethsdec9,
}
impl thsdec8Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r8),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0808().disassembly() != 1i128 {
            return None;
        }
        let thsdec9 = if let Some((len, table)) = Tablethsdec9::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:870:1, end:870:8))"]
#[derive(Clone, Debug)]
struct thsdec8Var2 {
    thsdec9: Tablethsdec9,
}
impl thsdec8Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thsdec9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0808().disassembly() != 0i128 {
            return None;
        }
        let thsdec9 = if let Some((len, table)) = Tablethsdec9::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec8 {
    Var0(thsdec8Var0),
    Var1(thsdec8Var1),
    Var2(thsdec8Var2),
}
impl Tablethsdec8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec8Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec8Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:871:1, end:871:8))"]
#[derive(Clone, Debug)]
struct thsdec7Var0 {}
impl thsdec7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0815().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:872:1, end:872:8))"]
#[derive(Clone, Debug)]
struct thsdec7Var1 {
    thsdec8: Tablethsdec8,
}
impl thsdec7Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r7),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0707().disassembly() != 1i128 {
            return None;
        }
        let thsdec8 = if let Some((len, table)) = Tablethsdec8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:873:1, end:873:8))"]
#[derive(Clone, Debug)]
struct thsdec7Var2 {
    thsdec8: Tablethsdec8,
}
impl thsdec7Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thsdec8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0707().disassembly() != 0i128 {
            return None;
        }
        let thsdec8 = if let Some((len, table)) = Tablethsdec8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec7 {
    Var0(thsdec7Var0),
    Var1(thsdec7Var1),
    Var2(thsdec7Var2),
}
impl Tablethsdec7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec7Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec7Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:874:1, end:874:8))"]
#[derive(Clone, Debug)]
struct thsdec6Var0 {}
impl thsdec6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0715().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:875:1, end:875:8))"]
#[derive(Clone, Debug)]
struct thsdec6Var1 {
    thsdec7: Tablethsdec7,
}
impl thsdec6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 1i128 {
            return None;
        }
        let thsdec7 = if let Some((len, table)) = Tablethsdec7::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:876:1, end:876:8))"]
#[derive(Clone, Debug)]
struct thsdec6Var2 {
    thsdec7: Tablethsdec7,
}
impl thsdec6Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thsdec7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0606().disassembly() != 0i128 {
            return None;
        }
        let thsdec7 = if let Some((len, table)) = Tablethsdec7::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec6 {
    Var0(thsdec6Var0),
    Var1(thsdec6Var1),
    Var2(thsdec6Var2),
}
impl Tablethsdec6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec6Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:877:1, end:877:8))"]
#[derive(Clone, Debug)]
struct thsdec5Var0 {}
impl thsdec5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0615().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:878:1, end:878:8))"]
#[derive(Clone, Debug)]
struct thsdec5Var1 {
    thsdec6: Tablethsdec6,
}
impl thsdec5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        let thsdec6 = if let Some((len, table)) = Tablethsdec6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:879:1, end:879:8))"]
#[derive(Clone, Debug)]
struct thsdec5Var2 {
    thsdec6: Tablethsdec6,
}
impl thsdec5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thsdec6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 0i128 {
            return None;
        }
        let thsdec6 = if let Some((len, table)) = Tablethsdec6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec5 {
    Var0(thsdec5Var0),
    Var1(thsdec5Var1),
    Var2(thsdec5Var2),
}
impl Tablethsdec5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:880:1, end:880:8))"]
#[derive(Clone, Debug)]
struct thsdec4Var0 {}
impl thsdec4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0515().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:881:1, end:881:8))"]
#[derive(Clone, Debug)]
struct thsdec4Var1 {
    thsdec5: Tablethsdec5,
}
impl thsdec4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        let thsdec5 = if let Some((len, table)) = Tablethsdec5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:882:1, end:882:8))"]
#[derive(Clone, Debug)]
struct thsdec4Var2 {
    thsdec5: Tablethsdec5,
}
impl thsdec4Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thsdec5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0404().disassembly() != 0i128 {
            return None;
        }
        let thsdec5 = if let Some((len, table)) = Tablethsdec5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec4 {
    Var0(thsdec4Var0),
    Var1(thsdec4Var1),
    Var2(thsdec4Var2),
}
impl Tablethsdec4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec4Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:883:1, end:883:8))"]
#[derive(Clone, Debug)]
struct thsdec3Var0 {}
impl thsdec3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0415().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:884:1, end:884:8))"]
#[derive(Clone, Debug)]
struct thsdec3Var1 {
    thsdec4: Tablethsdec4,
}
impl thsdec3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 1i128 {
            return None;
        }
        let thsdec4 = if let Some((len, table)) = Tablethsdec4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:885:1, end:885:8))"]
#[derive(Clone, Debug)]
struct thsdec3Var2 {
    thsdec4: Tablethsdec4,
}
impl thsdec3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thsdec4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0303().disassembly() != 0i128 {
            return None;
        }
        let thsdec4 = if let Some((len, table)) = Tablethsdec4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec3 {
    Var0(thsdec3Var0),
    Var1(thsdec3Var1),
    Var2(thsdec3Var2),
}
impl Tablethsdec3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:886:1, end:886:8))"]
#[derive(Clone, Debug)]
struct thsdec2Var0 {}
impl thsdec2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0415().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:887:1, end:887:8))"]
#[derive(Clone, Debug)]
struct thsdec2Var1 {
    thsdec3: Tablethsdec3,
}
impl thsdec2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 1i128 {
            return None;
        }
        let thsdec3 = if let Some((len, table)) = Tablethsdec3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:888:1, end:888:8))"]
#[derive(Clone, Debug)]
struct thsdec2Var2 {
    thsdec3: Tablethsdec3,
}
impl thsdec2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thsdec3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0202().disassembly() != 0i128 {
            return None;
        }
        let thsdec3 = if let Some((len, table)) = Tablethsdec3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec2 {
    Var0(thsdec2Var0),
    Var1(thsdec2Var1),
    Var2(thsdec2Var2),
}
impl Tablethsdec2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:889:1, end:889:8))"]
#[derive(Clone, Debug)]
struct thsdec1Var0 {}
impl thsdec1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0215().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:890:1, end:890:8))"]
#[derive(Clone, Debug)]
struct thsdec1Var1 {
    thsdec2: Tablethsdec2,
}
impl thsdec1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 1i128 {
            return None;
        }
        let thsdec2 = if let Some((len, table)) = Tablethsdec2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:891:1, end:891:8))"]
#[derive(Clone, Debug)]
struct thsdec1Var2 {
    thsdec2: Tablethsdec2,
}
impl thsdec1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.thsdec2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0101().disassembly() != 0i128 {
            return None;
        }
        let thsdec2 = if let Some((len, table)) = Tablethsdec2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec1 {
    Var0(thsdec1Var0),
    Var1(thsdec1Var1),
    Var2(thsdec1Var2),
}
impl Tablethsdec1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thsdec1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thsdec1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:892:1, end:892:14))"]
#[derive(Clone, Debug)]
struct thstrlist_decVar0 {}
impl thstrlist_decVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("{"),
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldthc0115().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:893:1, end:893:14))"]
#[derive(Clone, Debug)]
struct thstrlist_decVar1 {
    thsdec1: Tablethsdec1,
}
impl thstrlist_decVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("{"),
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 1i128 {
            return None;
        }
        let thsdec1 = if let Some((len, table)) = Tablethsdec1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:894:1, end:894:14))"]
#[derive(Clone, Debug)]
struct thstrlist_decVar2 {
    thsdec1: Tablethsdec1,
}
impl thstrlist_decVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.thsdec1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0000().disassembly() != 0i128 {
            return None;
        }
        let thsdec1 = if let Some((len, table)) = Tablethsdec1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethstrlist_dec {
    Var0(thstrlist_decVar0),
    Var1(thstrlist_decVar1),
    Var2(thstrlist_decVar2),
}
impl Tablethstrlist_dec {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = thstrlist_decVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = thstrlist_decVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = thstrlist_decVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:896:1, end:896:8))"]
#[derive(Clone, Debug)]
struct ldbraceVar0 {
    ldlist: Tableldlist,
}
impl ldbraceVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.ldlist.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let ldlist = if let Some((len, table)) = Tableldlist::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldlist }))
    }
}
#[derive(Clone, Debug)]
enum Tableldbrace {
    Var0(ldbraceVar0),
}
impl Tableldbrace {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldbraceVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:897:1, end:897:8))"]
#[derive(Clone, Debug)]
struct stbraceVar0 {
    strlist: Tablestrlist,
}
impl stbraceVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.strlist.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let strlist = if let Some((len, table)) = Tablestrlist::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { strlist }))
    }
}
#[derive(Clone, Debug)]
enum Tablestbrace {
    Var0(stbraceVar0),
}
impl Tablestbrace {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            stbraceVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:898:1, end:898:8))"]
#[derive(Clone, Debug)]
struct psbraceVar0 {
    pshlist: Tablepshlist,
}
impl psbraceVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.pshlist.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let pshlist = if let Some((len, table)) = Tablepshlist::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { pshlist }))
    }
}
#[derive(Clone, Debug)]
enum Tablepsbrace {
    Var0(psbraceVar0),
}
impl Tablepsbrace {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            psbraceVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:902:1, end:902:9))"]
#[derive(Clone, Debug)]
struct pclbraceVar0 {}
impl pclbraceVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("{"),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0007().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:901:1, end:901:9))"]
#[derive(Clone, Debug)]
struct pclbraceVar1 {
    ldlist: Tableldlist,
}
impl pclbraceVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.ldlist.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let ldlist = if let Some((len, table)) = Tableldlist::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldlist }))
    }
}
#[derive(Clone, Debug)]
enum Tablepclbrace {
    Var0(pclbraceVar0),
    Var1(pclbraceVar1),
}
impl Tablepclbrace {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            pclbraceVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            pclbraceVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:904:1, end:904:9))"]
#[derive(Clone, Debug)]
struct pcpbraceVar0 {}
impl pcpbraceVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("{"),
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0007().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:903:1, end:903:9))"]
#[derive(Clone, Debug)]
struct pcpbraceVar1 {
    pshlist: Tablepshlist,
}
impl pcpbraceVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.pshlist.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let pshlist = if let Some((len, table)) = Tablepshlist::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { pshlist }))
    }
}
#[derive(Clone, Debug)]
enum Tablepcpbrace {
    Var0(pcpbraceVar0),
    Var1(pcpbraceVar1),
}
impl Tablepcpbrace {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            pcpbraceVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            pcpbraceVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:928:1, end:928:12))"]
#[derive(Clone, Debug)]
struct RnIndirect4Var0 {
    Rn0305: TokenField_Rn0305,
    immed5: TokenField_immed5,
}
impl RnIndirect4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_immval: i128 = 0;
        calc_immval = self.immed5.disassembly().wrapping_mul(4i128);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.Rn0305.display(),
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_immval),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_immval: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_immval = token_parser
            .TokenFieldimmed5()
            .disassembly()
            .wrapping_mul(4i128);
        let Rn0305 = token_parser.TokenFieldRn0305();
        let immed5 = token_parser.TokenFieldimmed5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0305, immed5 }))
    }
}
#[derive(Clone, Debug)]
enum TableRnIndirect4 {
    Var0(RnIndirect4Var0),
}
impl TableRnIndirect4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RnIndirect4Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:929:1, end:929:12))"]
#[derive(Clone, Debug)]
struct RnIndirect2Var0 {
    Rn0305: TokenField_Rn0305,
    immed5: TokenField_immed5,
}
impl RnIndirect2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_immval: i128 = 0;
        calc_immval = self.immed5.disassembly().wrapping_mul(2i128);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.Rn0305.display(),
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_immval),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_immval: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_immval = token_parser
            .TokenFieldimmed5()
            .disassembly()
            .wrapping_mul(2i128);
        let Rn0305 = token_parser.TokenFieldRn0305();
        let immed5 = token_parser.TokenFieldimmed5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0305, immed5 }))
    }
}
#[derive(Clone, Debug)]
enum TableRnIndirect2 {
    Var0(RnIndirect2Var0),
}
impl TableRnIndirect2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RnIndirect2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:930:1, end:930:12))"]
#[derive(Clone, Debug)]
struct RnIndirect1Var0 {
    Rn0305: TokenField_Rn0305,
    immed5: TokenField_immed5,
}
impl RnIndirect1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.Rn0305.display(),
            DisplayElement::Literal(",#"),
            self.immed5.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let Rn0305 = token_parser.TokenFieldRn0305();
        let immed5 = token_parser.TokenFieldimmed5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0305, immed5 }))
    }
}
#[derive(Clone, Debug)]
enum TableRnIndirect1 {
    Var0(RnIndirect1Var0),
}
impl TableRnIndirect1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RnIndirect1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:932:1, end:932:13))"]
#[derive(Clone, Debug)]
struct RnRmIndirectVar0 {
    Rn0305: TokenField_Rn0305,
    Rm0608: TokenField_Rm0608,
}
impl RnRmIndirectVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.Rn0305.display(),
            DisplayElement::Literal(","),
            self.Rm0608.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let Rn0305 = token_parser.TokenFieldRn0305();
        let Rm0608 = token_parser.TokenFieldRm0608();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0305, Rm0608 }))
    }
}
#[derive(Clone, Debug)]
enum TableRnRmIndirect {
    Var0(RnRmIndirectVar0),
}
impl TableRnRmIndirect {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RnRmIndirectVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:934:1, end:934:15))"]
#[derive(Clone, Debug)]
struct Pcrel8IndirectVar0 {
    immed8: TokenField_immed8,
}
impl Pcrel8IndirectVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128)
            & 4294967292i128)
            .wrapping_add(4i128.wrapping_mul(self.immed8.disassembly()));
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Number(true, calc_reloc),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_reloc =
            (i128::try_from(inst_start).unwrap().wrapping_add(4i128)
                & 4294967292i128)
                .wrapping_add(4i128.wrapping_mul(
                    token_parser.TokenFieldimmed8().disassembly(),
                ));
        let immed8 = token_parser.TokenFieldimmed8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed8 }))
    }
}
#[derive(Clone, Debug)]
enum TablePcrel8Indirect {
    Var0(Pcrel8IndirectVar0),
}
impl TablePcrel8Indirect {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = Pcrel8IndirectVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:940:1, end:940:15))"]
#[derive(Clone, Debug)]
struct Sprel8IndirectVar0 {
    immed8: TokenField_immed8,
}
impl Sprel8IndirectVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_immval: i128 = 0;
        calc_immval = self.immed8.disassembly().wrapping_mul(4i128);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_immval),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_immval: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        calc_immval = token_parser
            .TokenFieldimmed8()
            .disassembly()
            .wrapping_mul(4i128);
        let immed8 = token_parser.TokenFieldimmed8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed8 }))
    }
}
#[derive(Clone, Debug)]
enum TableSprel8Indirect {
    Var0(Sprel8IndirectVar0),
}
impl TableSprel8Indirect {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = Sprel8IndirectVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:957:1, end:957:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar0 {}
impl thSRSModeVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("usr")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthsrsMode().disassembly() != 8i128 {
            return None;
        }
        let thc0004 = token_parser.TokenFieldthc0004();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:958:1, end:958:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar1 {}
impl thSRSModeVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("fiq")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthsrsMode().disassembly() != 9i128 {
            return None;
        }
        let thc0004 = token_parser.TokenFieldthc0004();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:959:1, end:959:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar2 {}
impl thSRSModeVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("irq")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthsrsMode().disassembly() != 10i128 {
            return None;
        }
        let thc0004 = token_parser.TokenFieldthc0004();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:960:1, end:960:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar3 {}
impl thSRSModeVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("svc")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthsrsMode().disassembly() != 11i128 {
            return None;
        }
        let thc0004 = token_parser.TokenFieldthc0004();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:961:1, end:961:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar4 {}
impl thSRSModeVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mon")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthsrsMode().disassembly() != 14i128 {
            return None;
        }
        let thc0004 = token_parser.TokenFieldthc0004();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:962:1, end:962:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar5 {}
impl thSRSModeVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("abt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthsrsMode().disassembly() != 15i128 {
            return None;
        }
        let thc0004 = token_parser.TokenFieldthc0004();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:963:1, end:963:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar6 {}
impl thSRSModeVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("und")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthsrsMode().disassembly() != 19i128 {
            return None;
        }
        let thc0004 = token_parser.TokenFieldthc0004();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:964:1, end:964:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar7 {}
impl thSRSModeVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sys")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthsrsMode().disassembly() != 23i128 {
            return None;
        }
        let thc0004 = token_parser.TokenFieldthc0004();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:965:1, end:965:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar8 {
    thsrsMode: TokenField_thsrsMode,
}
impl thSRSModeVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.thsrsMode.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let thsrsMode = token_parser.TokenFieldthsrsMode();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsrsMode }))
    }
}
#[derive(Clone, Debug)]
enum TablethSRSMode {
    Var0(thSRSModeVar0),
    Var1(thSRSModeVar1),
    Var2(thSRSModeVar2),
    Var3(thSRSModeVar3),
    Var4(thSRSModeVar4),
    Var5(thSRSModeVar5),
    Var6(thSRSModeVar6),
    Var7(thSRSModeVar7),
    Var8(thSRSModeVar8),
}
impl TablethSRSMode {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thSRSModeVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thSRSModeVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thSRSModeVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thSRSModeVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thSRSModeVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thSRSModeVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thSRSModeVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thSRSModeVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thSRSModeVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1480:1, end:1480:5))"]
#[derive(Clone, Debug)]
struct bxnsVar0 {}
impl bxnsVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ns")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldthc0002().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1479:1, end:1479:5))"]
#[derive(Clone, Debug)]
struct bxnsVar1 {}
impl bxnsVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let thc0003 = token_parser.TokenFieldthc0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablebxns {
    Var0(bxnsVar0),
    Var1(bxnsVar1),
}
impl Tablebxns {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            bxnsVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            bxnsVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3834:1, end:3834:7))"]
#[derive(Clone, Debug)]
struct thXBITVar0 {}
impl thXBITVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3835:1, end:3835:7))"]
#[derive(Clone, Debug)]
struct thXBITVar1 {}
impl thXBITVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let Rn0003 = token_parser.TokenFieldRn0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldthc0505().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablethXBIT {
    Var0(thXBITVar0),
    Var1(thXBITVar1),
}
impl TablethXBIT {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thXBITVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thXBITVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3837:1, end:3837:7))"]
#[derive(Clone, Debug)]
struct thYBITVar0 {}
impl thYBITVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldthc0404().disassembly() != 0i128 {
            return None;
        }
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3838:1, end:3838:7))"]
#[derive(Clone, Debug)]
struct thYBITVar1 {}
impl thYBITVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablethYBIT {
    Var0(thYBITVar0),
    Var1(thYBITVar1),
}
impl TablethYBIT {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thYBITVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thYBITVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3848:1, end:3848:8))"]
#[derive(Clone, Debug)]
struct thdXbotVar0 {}
impl thdXbotVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldthc0404().disassembly() != 0i128 {
            return None;
        }
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3849:1, end:3849:8))"]
#[derive(Clone, Debug)]
struct thdXbotVar1 {}
impl thdXbotVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("X")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablethdXbot {
    Var0(thdXbotVar0),
    Var1(thdXbotVar1),
}
impl TablethdXbot {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thdXbotVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thdXbotVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3851:1, end:3851:8))"]
#[derive(Clone, Debug)]
struct thdXtopVar0 {}
impl thdXtopVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldthc0404().disassembly() != 0i128 {
            return None;
        }
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3852:1, end:3852:8))"]
#[derive(Clone, Debug)]
struct thdXtopVar1 {}
impl thdXtopVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("X")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldthc0404().disassembly() != 1i128 {
            return None;
        }
        let Rm0003 = token_parser.TokenFieldRm0003();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablethdXtop {
    Var0(thdXtopVar0),
    Var1(thdXtopVar1),
}
impl TablethdXtop {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            thdXtopVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            thdXtopVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
pub fn parse_instruction<T>(
    tokens: &[u8],
    context: &mut T,
    inst_start: u32,
    global_set: &mut impl GlobalSetTrait,
) -> Option<(u32, Vec<DisplayElement>)>
where
    T: ContextTrait + Clone,
{
    let (inst_len, instruction) =
        Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(
        &mut display,
        context,
        inst_start,
        inst_next,
        global_set,
    );
    Some((inst_next, display))
}
